var R=new Uint32Array(256);for(let G=0;G<256;G++){let J=G;for(let $=0;$<8;$++)J=J>>>1^(J&1?3988292384:0);R[G]=J}function c(G){let J=-1;for(let $=0;$<G.length;$++)J=R[(J^G[$])&255]^J>>>8;return~J>>>0}function S(G){let J=new TextEncoder,$=[],j=22;for(let[Y,K]of G){let A=J.encode(Y);j+=30+A.length+K.length,j+=46+A.length}let X=new Uint8Array(j),U=new DataView(X.buffer),V=0;for(let[Y,K]of G){let A=J.encode(Y),M=c(K),B=V;U.setUint32(V,67324752,!0),V+=4,U.setUint16(V,20,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint32(V,M,!0),V+=4,U.setUint32(V,K.length,!0),V+=4,U.setUint32(V,K.length,!0),V+=4,U.setUint16(V,A.length,!0),V+=2,U.setUint16(V,0,!0),V+=2,X.set(A,V),V+=A.length,X.set(K,V),V+=K.length,$.push({name:A,data:K,crc:M,offset:B})}let Z=V;for(let Y of $)U.setUint32(V,33639248,!0),V+=4,U.setUint16(V,20,!0),V+=2,U.setUint16(V,20,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint32(V,Y.crc,!0),V+=4,U.setUint32(V,Y.data.length,!0),V+=4,U.setUint32(V,Y.data.length,!0),V+=4,U.setUint16(V,Y.name.length,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint32(V,0,!0),V+=4,U.setUint32(V,Y.offset,!0),V+=4,X.set(Y.name,V),V+=Y.name.length;let W=V-Z;return U.setUint32(V,101010256,!0),V+=4,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,$.length,!0),V+=2,U.setUint16(V,$.length,!0),V+=2,U.setUint32(V,W,!0),V+=4,U.setUint32(V,Z,!0),V+=4,U.setUint16(V,0,!0),V+=2,X.slice(0,V)}var Q=null,L=null,E=!1,g=[],w=new Map,k=new Map,b=new Set,x=new Set,N=new Map,y=134217728;function n(){let J=new URLSearchParams(self.location.search).get("token");return J?`?token=${encodeURIComponent(J)}`:""}async function p(){let G=performance.now(),J=await fetch(`/zstd.wasm${n()}`).then((V)=>V.arrayBuffer());console.log(`[Worker] fetch zstd.wasm: ${(performance.now()-G).toFixed(0)}ms (${J.byteLength} bytes)`);let $=null,j={args_sizes_get:(V,Z)=>{let W=new DataView($.buffer);return W.setUint32(V,0,!0),W.setUint32(Z,0,!0),0},args_get:()=>0,environ_sizes_get:(V,Z)=>{let W=new DataView($.buffer);return W.setUint32(V,0,!0),W.setUint32(Z,0,!0),0},environ_get:()=>0,clock_time_get:()=>0,fd_close:()=>0,fd_fdstat_get:()=>0,fd_prestat_get:()=>8,fd_prestat_dir_name:()=>8,fd_read:()=>0,fd_seek:()=>0,fd_write:()=>0,proc_exit:()=>{},random_get:()=>0},X=performance.now(),{instance:U}=await WebAssembly.instantiate(J,{wasi_snapshot_preview1:j});$=U.exports.memory,Q=U.exports,console.log(`[Worker] WASM compile: ${(performance.now()-X).toFixed(0)}ms`),console.log(`[Worker] initWasm total: ${(performance.now()-G).toFixed(0)}ms`)}async function f(G){L=G,console.log("[Worker] OPFS root received from main thread"),E=!0,console.log("[Worker] OPFS ready");let J=g.splice(0);if(J.length>0){console.log(`[Worker] Flushing ${J.length} queued OPFS operations`);for(let $ of J)self.dispatchEvent(new MessageEvent("message",{data:$.msg}))}self.postMessage({type:"opfs-ready"})}function q(G){if(E)return!1;return console.log(`[Worker] OPFS not ready, queuing: ${G.type}`),g.push({msg:G}),!0}function v(G){if(!Q)throw new Error("WASM not initialized");let J=G.length,$=Q.zstd_alloc(J);if($===0)throw new Error("zstd alloc failed");new Uint8Array(Q.memory.buffer,$,J).set(G);let j=Q.zstd_frame_content_size($,J);if(j===0||j>y)j=Math.min(J*8,y);let X=Q.zstd_alloc(j);if(X===0)throw Q.zstd_free($,J),new Error("zstd alloc failed");try{let U=Q.zstd_decompress(X,j,$,J);if(U===0)throw new Error("zstd decompression failed");return new Uint8Array(Q.memory.buffer.slice(X,X+U))}finally{Q.zstd_free($,J),Q.zstd_free(X,j)}}function d(G,J){if(!Q)throw new Error("WASM not initialized");let $=G.length,j=Q.zstd_compress_bound($),X=Q.zstd_alloc($),U=Q.zstd_alloc(j);if(X===0||U===0){if(X)Q.zstd_free(X,$);if(U)Q.zstd_free(U,j);throw new Error("zstd alloc failed")}try{new Uint8Array(Q.memory.buffer,X,$).set(G);let V=Q.zstd_compress(U,j,X,$,J);if(V===0)throw new Error("zstd compression failed");return new Uint8Array(Q.memory.buffer.slice(U,U+V))}finally{Q.zstd_free(X,$),Q.zstd_free(U,j)}}async function _(G,J){return G.getDirectoryHandle(J,{create:!0})}async function l(G){if(!L)return;for(let[J,$]of w)if(J.startsWith(`${G}/`)){try{$.flush()}catch{}try{$.close()}catch{}w.delete(J)}try{await(await L.getDirectoryHandle("termweb-transfers")).removeEntry(String(G),{recursive:!0})}catch{}}var i="termweb-temp";async function o(G){if(!L)return;try{await(await L.getDirectoryHandle(i)).removeEntry(String(G),{recursive:!0})}catch{}}var H="termweb-cache";async function O(G){if(!L)throw new Error("OPFS not available");let J=await _(L,H),$=G.replace(/^\/+/,"");if($){for(let j of $.split("/"))if(j)J=await _(J,j)}return J}async function z(G){let J=await O(G);return _(J,"files")}async function C(G){try{let X=await(await(await(await O(G)).getFileHandle(".termweb-meta")).getFile()).text();return JSON.parse(X)}catch{return{}}}async function h(G,J){let X=await(await(await O(G)).getFileHandle(".termweb-meta",{create:!0})).createSyncAccessHandle();try{let U=new TextEncoder().encode(JSON.stringify(J));X.truncate(0),X.write(U,{at:0}),X.flush()}finally{X.close()}}async function r(G,J,$,j){let X=await z(G),U=J.split("/"),V=X;for(let K=0;K<U.length-1;K++)V=await _(V,U[K]);let W=await(await V.getFileHandle(U[U.length-1],{create:!0})).createSyncAccessHandle();try{W.truncate(0),W.write(new Uint8Array($),{at:0}),W.flush()}finally{W.close()}let Y=await C(G);Y[J]=j,await h(G,Y)}async function T(G,J){let $=await z(G),j=J.split("/"),X=$;for(let Z=0;Z<j.length-1;Z++)X=await X.getDirectoryHandle(j[Z]);return(await(await X.getFileHandle(j[j.length-1])).getFile()).arrayBuffer()}async function s(G,J){let $=await C(G);delete $[J],await h(G,$);try{let j=await z(G),X=J.split("/"),U=j;for(let V=0;V<X.length-1;V++)U=await U.getDirectoryHandle(X[V]);await U.removeEntry(X[X.length-1])}catch{}}async function a(){if(!L)return;try{await L.removeEntry(H,{recursive:!0})}catch{}}async function t(G){if(!L)return;try{let J=await L.getDirectoryHandle(H),$=G.replace(/^\/+/,"");if($){let j=$.split("/").filter((U)=>U);if(j.length===0)return;let X=J;for(let U=0;U<j.length-1;U++)X=await X.getDirectoryHandle(j[U]);await X.removeEntry(j[j.length-1],{recursive:!0})}}catch{}}async function e(){if(!L)return{totalBytes:0,fileCount:0};let G=0,J=0;async function $(j){for await(let[,X]of j)if(X.kind==="file"){let U=await X.getFile();G+=U.size,J++}else await $(X)}try{let j=await L.getDirectoryHandle(H);await $(j)}catch{}return{totalBytes:G,fileCount:J}}function JJ(G){let J=0,$=0;for(let j=0;j<G.length;j++)J=J+G[j]&65535,$=$+J&65535;return($<<16|J)>>>0}function VJ(G){let J=0xcbf29ce484222325n,$=0x100000001b3n;for(let j=0;j<G.length;j++)J^=BigInt(G[j]),J=J*$&0xFFFFFFFFFFFFFFFFn;return J}async function $J(G,J,$){let j=new Uint8Array(await T(G,J)),X=Math.ceil(j.length/$),U=new Uint32Array(X),V=new BigUint64Array(X);for(let Z=0;Z<X;Z++){let W=Z*$,Y=Math.min(W+$,j.length),K=j.subarray(W,Y);U[Z]=JJ(K),V[Z]=VJ(K)}return{rolling:U,strong:V}}function UJ(G,J){let $=new DataView(J.buffer,J.byteOffset,J.byteLength),j=[],X=0,U=0;while(U<J.length){let W=J[U];if(U+=1,W===0){let Y=Number($.getBigUint64(U,!0));U+=8;let K=$.getUint32(U,!0);U+=4;let A=G.slice(Y,Y+K);j.push(A),X+=A.length}else if(W===1){let Y=$.getUint32(U,!0);U+=4;let K=J.slice(U,U+Y);j.push(K),X+=Y,U+=Y}else break}let V=new Uint8Array(X),Z=0;for(let W of j)V.set(W,Z),Z+=W.length;return V}async function m(G){if(!L)return;try{let X=await(await(await(await L.getDirectoryHandle("transfers",{create:!0})).getDirectoryHandle(`${G.transferId}`,{create:!0})).getFileHandle("metadata.json",{create:!0})).createWritable();await X.write(JSON.stringify(G)),await X.close(),console.log(`[Worker] Saved metadata for transfer ${G.transferId}`)}catch(J){console.error("[Worker] Failed to save transfer metadata:",J)}}async function D(G){if(!L)return null;try{let U=await(await(await(await(await L.getDirectoryHandle("transfers",{create:!1})).getDirectoryHandle(`${G}`,{create:!1})).getFileHandle("metadata.json",{create:!1})).getFile()).text();return JSON.parse(U)}catch{return null}}async function u(G,J,$){if(x.has(G))return;let j=await D(G);if(!j)return;if(!j.completedFiles.includes(J))j.completedFiles.push(J);j.bytesTransferred+=$,j.lastUpdateTime=Date.now(),await m(j)}async function P(G){if(!L)return;try{await(await L.getDirectoryHandle("transfers",{create:!1})).removeEntry(`${G}`,{recursive:!0}),console.log(`[Worker] Deleted metadata for transfer ${G}`)}catch(J){console.error("[Worker] Failed to delete transfer metadata:",J)}}async function jJ(){if(!L)return[];try{let G=await L.getDirectoryHandle("transfers",{create:!1}),J=[];for await(let $ of G.values())if($.kind==="directory"){let j=parseInt($.name),X=await D(j);if(X)J.push(X)}return J}catch{return[]}}self.onmessage=async(G)=>{let J=G.data;try{switch(J.type){case"init":{await p(),self.postMessage({type:"init-done"});break}case"set-opfs-root":{if(J.opfsRoot)f(J.opfsRoot).catch(($)=>{console.error("[Worker] OPFS activation failed:",$)});break}case"decompress":{let j=v(new Uint8Array(J.data)).buffer;self.postMessage({type:"decompressed",id:J.id,data:j},[j]);break}case"compress":{let j=d(new Uint8Array(J.data),J.level||3).buffer;self.postMessage({type:"compressed",id:J.id,data:j},[j]);break}case"decompress-and-write":{let{transferId:$,fileIndex:j,filePath:X,compressedData:U,fileSize:V}=J,Z=`${$}/${X}`,Y=(k.get(Z)||Promise.resolve()).then(async()=>{try{if(x.has($))return;if(b.has(Z))return;let K=v(new Uint8Array(U));if(!N.has($))N.set($,new Map);let A=N.get($),M=A.get(X);if(M){let F=new Uint8Array(M.length+K.length);F.set(M),F.set(K,M.length),A.set(X,F)}else A.set(X,K);let B=A.get(X).length,I=B>=V;if(I)b.add(Z),k.delete(Z),await u($,X,B);self.postMessage({type:"chunk-written",transferId:$,fileIndex:j,filePath:X,bytesWritten:K.length,complete:I})}catch(K){console.error(`[Worker] ERROR decompress-and-write: idx=${j}, path=${X}`,K),self.postMessage({type:"chunk-error",transferId:$,fileIndex:j,filePath:X,error:K instanceof Error?K.message:String(K)})}});k.set(Z,Y);break}case"get-file":{let{transferId:$,filePath:j}=J,U=N.get($)?.get(j);if(U){let V=U.buffer.slice(U.byteOffset,U.byteOffset+U.byteLength);self.postMessage({type:"file-data",transferId:$,filePath:j,data:V},[V])}else console.error(`[Worker] get-file: not found: ${j}`);break}case"cleanup":{if(N.delete(J.transferId),E)await l(J.transferId);self.postMessage({type:"cleanup-done",transferId:J.transferId});break}case"write-temp-file":{if(!N.has(J.transferId))N.set(J.transferId,new Map);let $=new Uint8Array(J.data);N.get(J.transferId).set(J.path,$),await u(J.transferId,J.path,$.length);break}case"create-zip-from-temp":{let $=N.get(J.transferId);if(!$||$.size===0){console.error(`[Worker] create-zip-from-temp: No files for transfer ${J.transferId}`);break}console.log(`[Worker] Creating zip from ${$.size} in-memory files`);let j=S($),U=`${J.folderName||"download"}.zip`;console.log(`[Worker] Zip created: ${j.length} bytes, filename: ${U}`);let V=j.buffer;self.postMessage({type:"zip-created",transferId:J.transferId,zipData:V,filename:U},[V]);break}case"cleanup-temp":{if(N.delete(J.transferId),E)await o(J.transferId);break}case"cache-put":{if(q(J))break;let{id:$,serverPath:j,filePath:X,data:U,metadata:V}=J;await r(j,X,U,V),self.postMessage({type:"cache-put-done",id:$,serverPath:j,filePath:X});break}case"cache-get":{if(q(J))break;let{id:$,serverPath:j,filePath:X}=J,U=await T(j,X);self.postMessage({type:"cache-file",id:$,serverPath:j,filePath:X,data:U},[U]);break}case"cache-list":{if(q(J))break;let{id:$,serverPath:j}=J,X=await C(j);self.postMessage({type:"cache-list-result",id:$,serverPath:j,files:X});break}case"cache-remove":{if(q(J))break;let{id:$,serverPath:j,filePath:X}=J;await s(j,X),self.postMessage({type:"cache-remove-done",id:$,serverPath:j,filePath:X});break}case"cache-clear-all":{if(q(J))break;let{id:$}=J;await a(),self.postMessage({type:"cache-cleared",id:$});break}case"cache-clear-path":{if(q(J))break;let{serverPath:$}=J;await t($),self.postMessage({type:"cache-path-cleared",serverPath:$});break}case"cache-usage":{if(q(J))break;let{id:$}=J,j=await e();self.postMessage({type:"cache-usage-result",id:$,...j});break}case"compute-checksums":{if(q(J))break;let{id:$,serverPath:j,filePath:X,blockSize:U}=J;try{let{rolling:V,strong:Z}=await $J(j,X,U),W=V.buffer,Y=Z.buffer;self.postMessage({type:"checksums-computed",id:$,rolling:W,strong:Y},[W,Y])}catch(V){let Z=V instanceof Error?V.message:"Checksum computation failed";self.postMessage({type:"checksums-error",id:$,message:Z})}break}case"apply-delta":{if(q(J))break;let{id:$,serverPath:j,filePath:X,deltaPayload:U}=J;try{let V=new Uint8Array(await T(j,X)),W=UJ(V,new Uint8Array(U)).buffer;self.postMessage({type:"delta-applied",id:$,data:W},[W])}catch(V){let Z=V instanceof Error?V.message:"Delta application failed";self.postMessage({type:"delta-error",id:$,message:Z})}break}case"save-transfer-metadata":{if(q(J))break;await m(J.metadata),self.postMessage({type:"metadata-saved",transferId:J.metadata.transferId});break}case"load-transfer-metadata":{if(q(J))break;let $=await D(J.transferId);self.postMessage({type:"metadata-loaded",transferId:J.transferId,metadata:$});break}case"delete-transfer-metadata":{if(q(J))break;x.add(J.transferId),await P(J.transferId),setTimeout(()=>P(J.transferId),2000),self.postMessage({type:"metadata-deleted",transferId:J.transferId});break}case"get-interrupted-transfers":{if(q(J))break;let $=await jJ();self.postMessage({type:"interrupted-transfers",transfers:$});break}}}catch($){let j=$ instanceof Error?$.message:"Unknown error";self.postMessage({type:"error",message:j,originalType:J.type,...J})}};
