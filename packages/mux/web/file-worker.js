var K=null,V=null,$=new Map,A=16777216;async function X(){let B=await(await fetch("/zstd.wasm")).arrayBuffer(),j=null,q={args_sizes_get:(J,Q)=>{let U=new DataView(j.buffer);return U.setUint32(J,0,!0),U.setUint32(Q,0,!0),0},args_get:()=>0,environ_sizes_get:(J,Q)=>{let U=new DataView(j.buffer);return U.setUint32(J,0,!0),U.setUint32(Q,0,!0),0},environ_get:()=>0,clock_time_get:()=>0,fd_close:()=>0,fd_fdstat_get:()=>0,fd_prestat_get:()=>8,fd_prestat_dir_name:()=>8,fd_read:()=>0,fd_seek:()=>0,fd_write:()=>0,proc_exit:()=>{},random_get:()=>0},{instance:G}=await WebAssembly.instantiate(B,{wasi_snapshot_preview1:q});j=G.exports.memory,K=G.exports;try{V=await navigator.storage.getDirectory()}catch{}}function N(L){if(!K)throw new Error("WASM not initialized");let B=L.length,j=K.zstd_alloc(B);if(j===0)throw new Error("zstd alloc failed");new Uint8Array(K.memory.buffer,j,B).set(L);let q=K.zstd_frame_content_size(j,B);if(q===0||q>A)q=Math.min(B*8,A);let G=K.zstd_alloc(q);if(G===0)throw K.zstd_free(j,B),new Error("zstd alloc failed");try{let J=K.zstd_decompress(G,q,j,B);if(J===0)throw new Error("zstd decompression failed");return new Uint8Array(K.memory.buffer.slice(G,G+J))}finally{K.zstd_free(j,B),K.zstd_free(G,q)}}function Z(L,B){if(!K)throw new Error("WASM not initialized");let j=L.length,q=K.zstd_compress_bound(j),G=K.zstd_alloc(j),J=K.zstd_alloc(q);if(G===0||J===0){if(G)K.zstd_free(G,j);if(J)K.zstd_free(J,q);throw new Error("zstd alloc failed")}try{new Uint8Array(K.memory.buffer,G,j).set(L);let Q=K.zstd_compress(J,q,G,j,B);if(Q===0)throw new Error("zstd compression failed");return new Uint8Array(K.memory.buffer.slice(J,J+Q))}finally{K.zstd_free(G,j),K.zstd_free(J,q)}}async function W(L,B){return L.getDirectoryHandle(B,{create:!0})}async function M(L,B){let j=`${L}/${B}`,q=$.get(j);if(q)return q;if(!V)throw new Error("OPFS not available");let G=await W(V,"termweb-transfers");G=await W(G,String(L));let J=B.split("/");for(let T=0;T<J.length-1;T++)G=await W(G,J[T]);let Q=J[J.length-1],Y=await(await G.getFileHandle(Q,{create:!0})).createSyncAccessHandle();return $.set(j,Y),Y}function F(L,B){let j=`${L}/${B}`,q=$.get(j);if(q){try{q.flush()}catch{}try{q.close()}catch{}$.delete(j)}}async function O(L,B){if(!V)throw new Error("OPFS not available");let j=await V.getDirectoryHandle("termweb-transfers");j=await j.getDirectoryHandle(String(L));let q=B.split("/");for(let Q=0;Q<q.length-1;Q++)j=await j.getDirectoryHandle(q[Q]);return(await(await j.getFileHandle(q[q.length-1])).getFile()).arrayBuffer()}async function k(L){if(!V)return;for(let[B,j]of $)if(B.startsWith(`${L}/`)){try{j.flush()}catch{}try{j.close()}catch{}$.delete(B)}try{await(await V.getDirectoryHandle("termweb-transfers")).removeEntry(String(L),{recursive:!0})}catch{}}self.onmessage=async(L)=>{let B=L.data;try{switch(B.type){case"init":{await X(),self.postMessage({type:"init-done",opfsAvailable:V!==null});break}case"decompress":{let q=N(new Uint8Array(B.data)).buffer;self.postMessage({type:"decompressed",id:B.id,data:q},[q]);break}case"compress":{let q=Z(new Uint8Array(B.data),B.level||3).buffer;self.postMessage({type:"compressed",id:B.id,data:q},[q]);break}case"decompress-and-write":{let{transferId:j,filePath:q,offset:G,compressedData:J,fileSize:Q}=B,U=N(new Uint8Array(J));if(V){let Y=await M(j,q);Y.write(U,{at:G});let x=Y.getSize()>=Q;if(x)F(j,q);self.postMessage({type:"chunk-written",transferId:j,filePath:q,bytesWritten:U.length,complete:x})}else{let Y=U.buffer;self.postMessage({type:"chunk-decompressed",transferId:j,filePath:q,offset:G,data:Y,bytesWritten:U.length},[Y])}break}case"get-file":{let{transferId:j,filePath:q}=B,G=await O(j,q);self.postMessage({type:"file-data",transferId:j,filePath:q,data:G},[G]);break}case"cleanup":{await k(B.transferId),self.postMessage({type:"cleanup-done",transferId:B.transferId});break}}}catch(j){let q=j instanceof Error?j.message:"Unknown error";self.postMessage({type:"error",message:q,originalType:B.type,...B})}};
