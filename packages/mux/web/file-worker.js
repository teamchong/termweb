var L=null,Z=null,F=new Map,x=new Map,H=16777216;async function D(){let q=await(await fetch("/zstd.wasm")).arrayBuffer(),J=null,V={args_sizes_get:(Y,j)=>{let W=new DataView(J.buffer);return W.setUint32(Y,0,!0),W.setUint32(j,0,!0),0},args_get:()=>0,environ_sizes_get:(Y,j)=>{let W=new DataView(J.buffer);return W.setUint32(Y,0,!0),W.setUint32(j,0,!0),0},environ_get:()=>0,clock_time_get:()=>0,fd_close:()=>0,fd_fdstat_get:()=>0,fd_prestat_get:()=>8,fd_prestat_dir_name:()=>8,fd_read:()=>0,fd_seek:()=>0,fd_write:()=>0,proc_exit:()=>{},random_get:()=>0},{instance:$}=await WebAssembly.instantiate(q,{wasi_snapshot_preview1:V});J=$.exports.memory,L=$.exports;try{Z=await navigator.storage.getDirectory()}catch{}}function R(U){if(!L)throw new Error("WASM not initialized");let q=U.length,J=L.zstd_alloc(q);if(J===0)throw new Error("zstd alloc failed");new Uint8Array(L.memory.buffer,J,q).set(U);let V=L.zstd_frame_content_size(J,q);if(V===0||V>H)V=Math.min(q*8,H);let $=L.zstd_alloc(V);if($===0)throw L.zstd_free(J,q),new Error("zstd alloc failed");try{let Y=L.zstd_decompress($,V,J,q);if(Y===0)throw new Error("zstd decompression failed");return new Uint8Array(L.memory.buffer.slice($,$+Y))}finally{L.zstd_free(J,q),L.zstd_free($,V)}}function C(U,q){if(!L)throw new Error("WASM not initialized");let J=U.length,V=L.zstd_compress_bound(J),$=L.zstd_alloc(J),Y=L.zstd_alloc(V);if($===0||Y===0){if($)L.zstd_free($,J);if(Y)L.zstd_free(Y,V);throw new Error("zstd alloc failed")}try{new Uint8Array(L.memory.buffer,$,J).set(U);let j=L.zstd_compress(Y,V,$,J,q);if(j===0)throw new Error("zstd compression failed");return new Uint8Array(L.memory.buffer.slice(Y,Y+j))}finally{L.zstd_free($,J),L.zstd_free(Y,V)}}async function A(U,q){return U.getDirectoryHandle(q,{create:!0})}async function u(U,q){let J=`${U}/${q}`,V=F.get(J);if(V)return V;if(!Z)throw new Error("OPFS not available");let $=await A(Z,"termweb-transfers");$=await A($,String(U));let Y=q.split("/");for(let X=0;X<Y.length-1;X++)$=await A($,Y[X]);let j=Y[Y.length-1],G=await(await $.getFileHandle(j,{create:!0})).createSyncAccessHandle();return F.set(J,G),G}function z(U,q){let J=`${U}/${q}`,V=F.get(J);if(V){try{V.flush()}catch{}try{V.close()}catch{}F.delete(J)}}async function g(U,q){if(!Z)throw new Error("OPFS not available");let J=await Z.getDirectoryHandle("termweb-transfers");J=await J.getDirectoryHandle(String(U));let V=q.split("/");for(let j=0;j<V.length-1;j++)J=await J.getDirectoryHandle(V[j]);return(await(await J.getFileHandle(V[V.length-1])).getFile()).arrayBuffer()}async function w(U){if(!Z)return;for(let[q,J]of F)if(q.startsWith(`${U}/`)){try{J.flush()}catch{}try{J.close()}catch{}F.delete(q)}try{await(await Z.getDirectoryHandle("termweb-transfers")).removeEntry(String(U),{recursive:!0})}catch{}}var O="termweb-temp";async function v(U,q,J){if(!Z)return;let V;for(let $=0;$<3;$++)try{let j=await(await Z.getDirectoryHandle(O,{create:!0})).getDirectoryHandle(String(U),{create:!0}),W=q.split("/").filter((N)=>N),G=j;for(let N=0;N<W.length-1;N++)G=await G.getDirectoryHandle(W[N],{create:!0});let X=W[W.length-1],Q=await G.getFileHandle(X,{create:!0}),K=null;try{K=await Q.createSyncAccessHandle(),K.truncate(0),K.write(new Uint8Array(J),{at:0}),K.flush();return}finally{if(K)try{K.close()}catch(N){console.warn("Failed to close access handle:",N)}}}catch(Y){V=Y;let j=Y instanceof Error?Y.message:String(Y);if(j.includes("Access Handle")||j.includes("access handle")){console.warn(`Write temp file attempt ${$+1}/3 failed for ${q}, retrying...`,j),await new Promise((W)=>setTimeout(W,10*Math.pow(5,$)));continue}console.error("Failed to write temp file:",q,Y);return}console.error("Failed to write temp file after 3 attempts:",q,V)}async function m(U,q){if(!Z)throw new Error("OPFS not available");console.log(`[Worker] createZipFromTemp: Getting temp dir for transfer ${U}`);let V=await(await Z.getDirectoryHandle(O)).getDirectoryHandle(String(U)),$=new Map;async function Y(G,X){for await(let[Q,K]of G){let N=X?`${X}/${Q}`:Q;if(K.kind==="file"){let M=await K.getFile(),y=new Uint8Array(await M.arrayBuffer());$.set(N,y)}else if(K.kind==="directory")await Y(K,N)}}await Y(V,""),console.log(`[Worker] Collected ${$.size} files from OPFS temp`);let j=n($);console.log(`[Worker] Created zip: ${j.length} bytes`);let W=q?`${q}.zip`:`${Array.from($.keys())[0]?.split("/")[0]||"download"}.zip`;return console.log(`[Worker] Zip filename: ${W}`),{zipData:j.buffer,filename:W}}async function P(U){if(!Z)return;try{await(await Z.getDirectoryHandle(O)).removeEntry(String(U),{recursive:!0})}catch{}}var S=new Uint32Array(256);for(let U=0;U<256;U++){let q=U;for(let J=0;J<8;J++)q=q&1?3988292384^q>>>1:q>>>1;S[U]=q}function h(U){let q=-1;for(let J=0;J<U.length;J++)q=S[(q^U[J])&255]^q>>>8;return~q>>>0}function n(U){let q=new TextEncoder,J=[],V=22;for(let[X,Q]of U){let K=q.encode(X);V+=30+K.length+Q.length,V+=46+K.length}let $=new Uint8Array(V),Y=new DataView($.buffer),j=0;for(let[X,Q]of U){let K=q.encode(X),N=h(Q),B=j;Y.setUint32(j,67324752,!0),j+=4,Y.setUint16(j,20,!0),j+=2,Y.setUint16(j,0,!0),j+=2,Y.setUint16(j,0,!0),j+=2,Y.setUint16(j,0,!0),j+=2,Y.setUint16(j,0,!0),j+=2,Y.setUint32(j,N,!0),j+=4,Y.setUint32(j,Q.length,!0),j+=4,Y.setUint32(j,Q.length,!0),j+=4,Y.setUint16(j,K.length,!0),j+=2,Y.setUint16(j,0,!0),j+=2,$.set(K,j),j+=K.length,$.set(Q,j),j+=Q.length,J.push({name:K,data:Q,crc:N,offset:B})}let W=j;for(let X of J)Y.setUint32(j,33639248,!0),j+=4,Y.setUint16(j,20,!0),j+=2,Y.setUint16(j,20,!0),j+=2,Y.setUint16(j,0,!0),j+=2,Y.setUint16(j,0,!0),j+=2,Y.setUint16(j,0,!0),j+=2,Y.setUint16(j,0,!0),j+=2,Y.setUint32(j,X.crc,!0),j+=4,Y.setUint32(j,X.data.length,!0),j+=4,Y.setUint32(j,X.data.length,!0),j+=4,Y.setUint16(j,X.name.length,!0),j+=2,Y.setUint16(j,0,!0),j+=2,Y.setUint16(j,0,!0),j+=2,Y.setUint16(j,0,!0),j+=2,Y.setUint16(j,0,!0),j+=2,Y.setUint32(j,0,!0),j+=4,Y.setUint32(j,X.offset,!0),j+=4,$.set(X.name,j),j+=X.name.length;let G=j-W;return Y.setUint32(j,101010256,!0),j+=4,Y.setUint16(j,0,!0),j+=2,Y.setUint16(j,0,!0),j+=2,Y.setUint16(j,J.length,!0),j+=2,Y.setUint16(j,J.length,!0),j+=2,Y.setUint32(j,G,!0),j+=4,Y.setUint32(j,W,!0),j+=4,Y.setUint16(j,0,!0),$}var T="termweb-cache";async function _(U){if(!Z)throw new Error("OPFS not available");let q=await A(Z,T),J=U.replace(/^\/+/,"");if(J){for(let V of J.split("/"))if(V)q=await A(q,V)}return q}async function b(U){let q=await _(U);return A(q,"files")}async function k(U){try{let $=await(await(await(await _(U)).getFileHandle(".termweb-meta")).getFile()).text();return JSON.parse($)}catch{return{}}}async function I(U,q){let $=await(await(await _(U)).getFileHandle(".termweb-meta",{create:!0})).createSyncAccessHandle();try{let Y=new TextEncoder().encode(JSON.stringify(q));$.truncate(0),$.write(Y,{at:0}),$.flush()}finally{$.close()}}async function c(U,q,J,V){let $=await b(U),Y=q.split("/"),j=$;for(let Q=0;Q<Y.length-1;Q++)j=await A(j,Y[Q]);let G=await(await j.getFileHandle(Y[Y.length-1],{create:!0})).createSyncAccessHandle();try{G.truncate(0),G.write(new Uint8Array(J),{at:0}),G.flush()}finally{G.close()}let X=await k(U);X[q]=V,await I(U,X)}async function E(U,q){let J=await b(U),V=q.split("/"),$=J;for(let W=0;W<V.length-1;W++)$=await $.getDirectoryHandle(V[W]);return(await(await $.getFileHandle(V[V.length-1])).getFile()).arrayBuffer()}async function f(U,q){let J=await k(U);delete J[q],await I(U,J);try{let V=await b(U),$=q.split("/"),Y=V;for(let j=0;j<$.length-1;j++)Y=await Y.getDirectoryHandle($[j]);await Y.removeEntry($[$.length-1])}catch{}}async function p(){if(!Z)return;try{await Z.removeEntry(T,{recursive:!0})}catch{}}async function l(U){if(!Z)return;try{let q=await Z.getDirectoryHandle(T),J=U.replace(/^\/+/,"");if(J){let V=J.split("/").filter((Y)=>Y);if(V.length===0)return;let $=q;for(let Y=0;Y<V.length-1;Y++)$=await $.getDirectoryHandle(V[Y]);await $.removeEntry(V[V.length-1],{recursive:!0})}}catch{}}async function d(){if(!Z)return{totalBytes:0,fileCount:0};let U=0,q=0;async function J(V){for await(let[,$]of V)if($.kind==="file"){let Y=await $.getFile();U+=Y.size,q++}else await J($)}try{let V=await Z.getDirectoryHandle(T);await J(V)}catch{}return{totalBytes:U,fileCount:q}}function o(U){let q=0,J=0;for(let V=0;V<U.length;V++)q=q+U[V]&65535,J=J+q&65535;return(J<<16|q)>>>0}function i(U){let q=0xcbf29ce484222325n,J=0x100000001b3n;for(let V=0;V<U.length;V++)q^=BigInt(U[V]),q=q*J&0xFFFFFFFFFFFFFFFFn;return q}async function r(U,q,J){let V=new Uint8Array(await E(U,q)),$=Math.ceil(V.length/J),Y=new Uint32Array($),j=new BigUint64Array($);for(let W=0;W<$;W++){let G=W*J,X=Math.min(G+J,V.length),Q=V.subarray(G,X);Y[W]=o(Q),j[W]=i(Q)}return{rolling:Y,strong:j}}function t(U,q){let J=new DataView(q.buffer,q.byteOffset,q.byteLength),V=[],$=0,Y=0;while(Y<q.length){let G=q[Y];if(Y+=1,G===0){let X=Number(J.getBigUint64(Y,!0));Y+=8;let Q=J.getUint32(Y,!0);Y+=4;let K=U.slice(X,X+Q);V.push(K),$+=K.length}else if(G===1){let X=J.getUint32(Y,!0);Y+=4;let Q=q.slice(Y,Y+X);V.push(Q),$+=X,Y+=X}else break}let j=new Uint8Array($),W=0;for(let G of V)j.set(G,W),W+=G.length;return j}self.onmessage=async(U)=>{let q=U.data;try{switch(q.type){case"init":{await D(),self.postMessage({type:"init-done",opfsAvailable:Z!==null});break}case"decompress":{let V=R(new Uint8Array(q.data)).buffer;self.postMessage({type:"decompressed",id:q.id,data:V},[V]);break}case"compress":{let V=C(new Uint8Array(q.data),q.level||3).buffer;self.postMessage({type:"compressed",id:q.id,data:V},[V]);break}case"decompress-and-write":{let{transferId:J,fileIndex:V,filePath:$,offset:Y,compressedData:j,fileSize:W}=q;console.log(`[Worker] decompress-and-write: idx=${V}, path=${$}, offset=${Y}, size=${W}`);let G=`${J}/${$}`,Q=(x.get(G)||Promise.resolve()).then(async()=>{try{let K=R(new Uint8Array(j));if(console.log(`[Worker] decompressed: idx=${V}, decompressed=${K.length} bytes`),Z){let N=await u(J,$);console.log(`[Worker] got handle: idx=${V}, current size=${N.getSize()}`),N.write(K,{at:Y}),console.log(`[Worker] wrote chunk: idx=${V}, at offset=${Y}`);let B=N.getSize(),M=B>=W;if(console.log(`[Worker] after write: idx=${V}, size=${B}/${W}, complete=${M}`),M)z(J,$),x.delete(G),console.log(`[Worker] closed handle: idx=${V}`);self.postMessage({type:"chunk-written",transferId:J,fileIndex:V,filePath:$,bytesWritten:K.length,complete:M}),console.log(`[Worker] sent chunk-written: idx=${V}`)}else{let N=K.buffer;self.postMessage({type:"chunk-decompressed",transferId:J,fileIndex:V,filePath:$,offset:Y,data:N,bytesWritten:K.length},[N])}}catch(K){console.error(`[Worker] ERROR decompress-and-write: idx=${V}, path=${$}`,K),self.postMessage({type:"chunk-error",transferId:J,fileIndex:V,filePath:$,error:K instanceof Error?K.message:String(K)})}});x.set(G,Q);break}case"get-file":{let{transferId:J,filePath:V}=q,$=await g(J,V);self.postMessage({type:"file-data",transferId:J,filePath:V,data:$},[$]);break}case"cleanup":{await w(q.transferId),self.postMessage({type:"cleanup-done",transferId:q.transferId});break}case"write-temp-file":{await v(q.transferId,q.path,q.data);break}case"create-zip-from-temp":{console.log(`[Worker] create-zip-from-temp: transferId=${q.transferId}, folderName=${q.folderName}`);let{zipData:J,filename:V}=await m(q.transferId,q.folderName);console.log(`[Worker] Zip created: size=${J.byteLength} bytes, filename=${V}`),self.postMessage({type:"zip-created",transferId:q.transferId,zipData:J,filename:V},[J]),console.log("[Worker] Sent zip-created message to main thread");break}case"cleanup-temp":{console.log(`[Worker] cleanup-temp: transferId=${q.transferId}`),await P(q.transferId),console.log("[Worker] Temp files cleaned up");break}case"cache-put":{let{id:J,serverPath:V,filePath:$,data:Y,metadata:j}=q;await c(V,$,Y,j),self.postMessage({type:"cache-put-done",id:J,serverPath:V,filePath:$});break}case"cache-get":{let{id:J,serverPath:V,filePath:$}=q,Y=await E(V,$);self.postMessage({type:"cache-file",id:J,serverPath:V,filePath:$,data:Y},[Y]);break}case"cache-list":{let{id:J,serverPath:V}=q,$=await k(V);self.postMessage({type:"cache-list-result",id:J,serverPath:V,files:$});break}case"cache-remove":{let{id:J,serverPath:V,filePath:$}=q;await f(V,$),self.postMessage({type:"cache-remove-done",id:J,serverPath:V,filePath:$});break}case"cache-clear-all":{let{id:J}=q;await p(),self.postMessage({type:"cache-cleared",id:J});break}case"cache-clear-path":{let{serverPath:J}=q;await l(J),self.postMessage({type:"cache-path-cleared",serverPath:J});break}case"cache-usage":{let{id:J}=q,V=await d();self.postMessage({type:"cache-usage-result",id:J,...V});break}case"compute-checksums":{let{id:J,serverPath:V,filePath:$,blockSize:Y}=q;try{let{rolling:j,strong:W}=await r(V,$,Y),G=j.buffer,X=W.buffer;self.postMessage({type:"checksums-computed",id:J,rolling:G,strong:X},[G,X])}catch(j){let W=j instanceof Error?j.message:"Checksum computation failed";self.postMessage({type:"checksums-error",id:J,message:W})}break}case"apply-delta":{let{id:J,serverPath:V,filePath:$,deltaPayload:Y}=q;try{let j=new Uint8Array(await E(V,$)),G=t(j,new Uint8Array(Y)).buffer;self.postMessage({type:"delta-applied",id:J,data:G},[G])}catch(j){let W=j instanceof Error?j.message:"Delta application failed";self.postMessage({type:"delta-error",id:J,message:W})}break}}}catch(J){let V=J instanceof Error?J.message:"Unknown error";self.postMessage({type:"error",message:V,originalType:q.type,...q})}};
