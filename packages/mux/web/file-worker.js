var L=null,Z=null,F=new Map,M=new Map,S=new Set,R=134217728;async function I(){let j=await(await fetch("/zstd.wasm")).arrayBuffer(),q=null,V={args_sizes_get:(Y,J)=>{let X=new DataView(q.buffer);return X.setUint32(Y,0,!0),X.setUint32(J,0,!0),0},args_get:()=>0,environ_sizes_get:(Y,J)=>{let X=new DataView(q.buffer);return X.setUint32(Y,0,!0),X.setUint32(J,0,!0),0},environ_get:()=>0,clock_time_get:()=>0,fd_close:()=>0,fd_fdstat_get:()=>0,fd_prestat_get:()=>8,fd_prestat_dir_name:()=>8,fd_read:()=>0,fd_seek:()=>0,fd_write:()=>0,proc_exit:()=>{},random_get:()=>0},{instance:$}=await WebAssembly.instantiate(j,{wasi_snapshot_preview1:V});q=$.exports.memory,L=$.exports;try{Z=await navigator.storage.getDirectory()}catch{}}function D(U){if(!L)throw new Error("WASM not initialized");let j=U.length,q=L.zstd_alloc(j);if(q===0)throw new Error("zstd alloc failed");new Uint8Array(L.memory.buffer,q,j).set(U);let V=L.zstd_frame_content_size(q,j);if(V===0||V>R)V=Math.min(j*8,R);let $=L.zstd_alloc(V);if($===0)throw L.zstd_free(q,j),new Error("zstd alloc failed");try{let Y=L.zstd_decompress($,V,q,j);if(Y===0)throw new Error("zstd decompression failed");return new Uint8Array(L.memory.buffer.slice($,$+Y))}finally{L.zstd_free(q,j),L.zstd_free($,V)}}function g(U,j){if(!L)throw new Error("WASM not initialized");let q=U.length,V=L.zstd_compress_bound(q),$=L.zstd_alloc(q),Y=L.zstd_alloc(V);if($===0||Y===0){if($)L.zstd_free($,q);if(Y)L.zstd_free(Y,V);throw new Error("zstd alloc failed")}try{new Uint8Array(L.memory.buffer,$,q).set(U);let J=L.zstd_compress(Y,V,$,q,j);if(J===0)throw new Error("zstd compression failed");return new Uint8Array(L.memory.buffer.slice(Y,Y+J))}finally{L.zstd_free($,q),L.zstd_free(Y,V)}}async function A(U,j){return U.getDirectoryHandle(j,{create:!0})}async function w(U,j){let q=`${U}/${j}`,V=F.get(q);if(V)return V;if(!Z)throw new Error("OPFS not available");let $=await A(Z,"termweb-transfers");$=await A($,String(U));let Y=j.split("/");for(let Q=0;Q<Y.length-1;Q++)$=await A($,Y[Q]);let J=Y[Y.length-1],G=await(await $.getFileHandle(J,{create:!0})).createSyncAccessHandle();return F.set(q,G),G}function v(U,j){let q=`${U}/${j}`,V=F.get(q);if(V){try{V.flush()}catch{}try{V.close()}catch{}F.delete(q)}}async function P(U,j){if(!Z)throw new Error("OPFS not available");let q=await Z.getDirectoryHandle("termweb-transfers");q=await q.getDirectoryHandle(String(U));let V=j.split("/");for(let J=0;J<V.length-1;J++)q=await q.getDirectoryHandle(V[J]);return(await(await q.getFileHandle(V[V.length-1])).getFile()).arrayBuffer()}async function h(U){if(!Z)return;for(let[j,q]of F)if(j.startsWith(`${U}/`)){try{q.flush()}catch{}try{q.close()}catch{}F.delete(j)}try{await(await Z.getDirectoryHandle("termweb-transfers")).removeEntry(String(U),{recursive:!0})}catch{}}var O="termweb-temp";async function m(U,j,q){if(!Z)return;let V;for(let $=0;$<3;$++)try{let J=await(await Z.getDirectoryHandle(O,{create:!0})).getDirectoryHandle(String(U),{create:!0}),X=j.split("/").filter((N)=>N),G=J;for(let N=0;N<X.length-1;N++)G=await G.getDirectoryHandle(X[N],{create:!0});let Q=X[X.length-1],K=await G.getFileHandle(Q,{create:!0}),W=null;try{W=await K.createSyncAccessHandle(),W.truncate(0),W.write(new Uint8Array(q),{at:0}),W.flush();return}finally{if(W)try{W.close()}catch(N){console.warn("Failed to close access handle:",N)}}}catch(Y){V=Y;let J=Y instanceof Error?Y.message:String(Y);if(J.includes("Access Handle")||J.includes("access handle")){console.warn(`Write temp file attempt ${$+1}/3 failed for ${j}, retrying...`,J),await new Promise((X)=>setTimeout(X,10*Math.pow(5,$)));continue}console.error("Failed to write temp file:",j,Y);return}console.error("Failed to write temp file after 3 attempts:",j,V)}async function c(U,j){if(!Z)throw new Error("OPFS not available");console.log(`[Worker] createZipFromTemp: Getting temp dir for transfer ${U}`);let V=await(await Z.getDirectoryHandle(O)).getDirectoryHandle(String(U)),$=new Map;async function Y(G,Q){for await(let[K,W]of G){let N=Q?`${Q}/${K}`:K;if(W.kind==="file"){let x=await W.getFile(),u=new Uint8Array(await x.arrayBuffer());$.set(N,u)}else if(W.kind==="directory")await Y(W,N)}}await Y(V,""),console.log(`[Worker] Collected ${$.size} files from OPFS temp`);let J=f($);console.log(`[Worker] Created zip: ${J.length} bytes`);let X=j?`${j}.zip`:`${Array.from($.keys())[0]?.split("/")[0]||"download"}.zip`;return console.log(`[Worker] Zip filename: ${X}`),{zipData:J.buffer,filename:X}}async function n(U){if(!Z)return;try{await(await Z.getDirectoryHandle(O)).removeEntry(String(U),{recursive:!0})}catch{}}var C=new Uint32Array(256);for(let U=0;U<256;U++){let j=U;for(let q=0;q<8;q++)j=j&1?3988292384^j>>>1:j>>>1;C[U]=j}function p(U){let j=-1;for(let q=0;q<U.length;q++)j=C[(j^U[q])&255]^j>>>8;return~j>>>0}function f(U){let j=new TextEncoder,q=[],V=22;for(let[Q,K]of U){let W=j.encode(Q);V+=30+W.length+K.length,V+=46+W.length}let $=new Uint8Array(V),Y=new DataView($.buffer),J=0;for(let[Q,K]of U){let W=j.encode(Q),N=p(K),B=J;Y.setUint32(J,67324752,!0),J+=4,Y.setUint16(J,20,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint32(J,N,!0),J+=4,Y.setUint32(J,K.length,!0),J+=4,Y.setUint32(J,K.length,!0),J+=4,Y.setUint16(J,W.length,!0),J+=2,Y.setUint16(J,0,!0),J+=2,$.set(W,J),J+=W.length,$.set(K,J),J+=K.length,q.push({name:W,data:K,crc:N,offset:B})}let X=J;for(let Q of q)Y.setUint32(J,33639248,!0),J+=4,Y.setUint16(J,20,!0),J+=2,Y.setUint16(J,20,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint32(J,Q.crc,!0),J+=4,Y.setUint32(J,Q.data.length,!0),J+=4,Y.setUint32(J,Q.data.length,!0),J+=4,Y.setUint16(J,Q.name.length,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint32(J,0,!0),J+=4,Y.setUint32(J,Q.offset,!0),J+=4,$.set(Q.name,J),J+=Q.name.length;let G=J-X;return Y.setUint32(J,101010256,!0),J+=4,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,q.length,!0),J+=2,Y.setUint16(J,q.length,!0),J+=2,Y.setUint32(J,G,!0),J+=4,Y.setUint32(J,X,!0),J+=4,Y.setUint16(J,0,!0),$}var E="termweb-cache";async function _(U){if(!Z)throw new Error("OPFS not available");let j=await A(Z,E),q=U.replace(/^\/+/,"");if(q){for(let V of q.split("/"))if(V)j=await A(j,V)}return j}async function k(U){let j=await _(U);return A(j,"files")}async function H(U){try{let $=await(await(await(await _(U)).getFileHandle(".termweb-meta")).getFile()).text();return JSON.parse($)}catch{return{}}}async function y(U,j){let $=await(await(await _(U)).getFileHandle(".termweb-meta",{create:!0})).createSyncAccessHandle();try{let Y=new TextEncoder().encode(JSON.stringify(j));$.truncate(0),$.write(Y,{at:0}),$.flush()}finally{$.close()}}async function l(U,j,q,V){let $=await k(U),Y=j.split("/"),J=$;for(let K=0;K<Y.length-1;K++)J=await A(J,Y[K]);let G=await(await J.getFileHandle(Y[Y.length-1],{create:!0})).createSyncAccessHandle();try{G.truncate(0),G.write(new Uint8Array(q),{at:0}),G.flush()}finally{G.close()}let Q=await H(U);Q[j]=V,await y(U,Q)}async function T(U,j){let q=await k(U),V=j.split("/"),$=q;for(let X=0;X<V.length-1;X++)$=await $.getDirectoryHandle(V[X]);return(await(await $.getFileHandle(V[V.length-1])).getFile()).arrayBuffer()}async function d(U,j){let q=await H(U);delete q[j],await y(U,q);try{let V=await k(U),$=j.split("/"),Y=V;for(let J=0;J<$.length-1;J++)Y=await Y.getDirectoryHandle($[J]);await Y.removeEntry($[$.length-1])}catch{}}async function o(){if(!Z)return;try{await Z.removeEntry(E,{recursive:!0})}catch{}}async function i(U){if(!Z)return;try{let j=await Z.getDirectoryHandle(E),q=U.replace(/^\/+/,"");if(q){let V=q.split("/").filter((Y)=>Y);if(V.length===0)return;let $=j;for(let Y=0;Y<V.length-1;Y++)$=await $.getDirectoryHandle(V[Y]);await $.removeEntry(V[V.length-1],{recursive:!0})}}catch{}}async function r(){if(!Z)return{totalBytes:0,fileCount:0};let U=0,j=0;async function q(V){for await(let[,$]of V)if($.kind==="file"){let Y=await $.getFile();U+=Y.size,j++}else await q($)}try{let V=await Z.getDirectoryHandle(E);await q(V)}catch{}return{totalBytes:U,fileCount:j}}function s(U){let j=0,q=0;for(let V=0;V<U.length;V++)j=j+U[V]&65535,q=q+j&65535;return(q<<16|j)>>>0}function t(U){let j=0xcbf29ce484222325n,q=0x100000001b3n;for(let V=0;V<U.length;V++)j^=BigInt(U[V]),j=j*q&0xFFFFFFFFFFFFFFFFn;return j}async function a(U,j,q){let V=new Uint8Array(await T(U,j)),$=Math.ceil(V.length/q),Y=new Uint32Array($),J=new BigUint64Array($);for(let X=0;X<$;X++){let G=X*q,Q=Math.min(G+q,V.length),K=V.subarray(G,Q);Y[X]=s(K),J[X]=t(K)}return{rolling:Y,strong:J}}function e(U,j){let q=new DataView(j.buffer,j.byteOffset,j.byteLength),V=[],$=0,Y=0;while(Y<j.length){let G=j[Y];if(Y+=1,G===0){let Q=Number(q.getBigUint64(Y,!0));Y+=8;let K=q.getUint32(Y,!0);Y+=4;let W=U.slice(Q,Q+K);V.push(W),$+=W.length}else if(G===1){let Q=q.getUint32(Y,!0);Y+=4;let K=j.slice(Y,Y+Q);V.push(K),$+=Q,Y+=Q}else break}let J=new Uint8Array($),X=0;for(let G of V)J.set(G,X),X+=G.length;return J}async function z(U){if(!Z)return;try{let $=await(await(await(await Z.getDirectoryHandle("transfers",{create:!0})).getDirectoryHandle(`${U.transferId}`,{create:!0})).getFileHandle("metadata.json",{create:!0})).createWritable();await $.write(JSON.stringify(U)),await $.close(),console.log(`[Worker] Saved metadata for transfer ${U.transferId}`)}catch(j){console.error("[Worker] Failed to save transfer metadata:",j)}}async function b(U){if(!Z)return null;try{let Y=await(await(await(await(await Z.getDirectoryHandle("transfers",{create:!1})).getDirectoryHandle(`${U}`,{create:!1})).getFileHandle("metadata.json",{create:!1})).getFile()).text();return JSON.parse(Y)}catch{return null}}async function jj(U,j,q){let V=await b(U);if(!V)return;if(!V.completedFiles.includes(j))V.completedFiles.push(j);V.bytesTransferred+=q,V.lastUpdateTime=Date.now(),await z(V)}async function qj(U){if(!Z)return;try{await(await Z.getDirectoryHandle("transfers",{create:!1})).removeEntry(`${U}`,{recursive:!0}),console.log(`[Worker] Deleted metadata for transfer ${U}`)}catch(j){console.error("[Worker] Failed to delete transfer metadata:",j)}}async function Jj(){if(!Z)return[];try{let U=await Z.getDirectoryHandle("transfers",{create:!1}),j=[];for await(let q of U.values())if(q.kind==="directory"){let V=parseInt(q.name),$=await b(V);if($)j.push($)}return j}catch{return[]}}self.onmessage=async(U)=>{let j=U.data;try{switch(j.type){case"init":{await I(),self.postMessage({type:"init-done",opfsAvailable:Z!==null});break}case"decompress":{let V=D(new Uint8Array(j.data)).buffer;self.postMessage({type:"decompressed",id:j.id,data:V},[V]);break}case"compress":{let V=g(new Uint8Array(j.data),j.level||3).buffer;self.postMessage({type:"compressed",id:j.id,data:V},[V]);break}case"decompress-and-write":{let{transferId:q,fileIndex:V,filePath:$,offset:Y,compressedData:J,fileSize:X}=j;console.log(`[Worker] decompress-and-write: idx=${V}, path=${$}, offset=${Y}, size=${X}`);let G=`${q}/${$}`,K=(M.get(G)||Promise.resolve()).then(async()=>{try{if(S.has(G)){console.log(`[Worker] skipping already-completed file: idx=${V}, path=${$}`);return}let W=D(new Uint8Array(J));if(console.log(`[Worker] decompressed: idx=${V}, decompressed=${W.length} bytes`),Z){let N=await w(q,$);console.log(`[Worker] got handle: idx=${V}, current size=${N.getSize()}`),N.write(W,{at:Y}),console.log(`[Worker] wrote chunk: idx=${V}, at offset=${Y}`);let B=N.getSize(),x=B>=X;if(console.log(`[Worker] after write: idx=${V}, size=${B}/${X}, complete=${x}`),x)S.add(G),v(q,$),M.delete(G),console.log(`[Worker] closed handle: idx=${V}`),await jj(q,$,W.length);self.postMessage({type:"chunk-written",transferId:q,fileIndex:V,filePath:$,bytesWritten:W.length,complete:x}),console.log(`[Worker] sent chunk-written: idx=${V}`)}else{let N=W.buffer;self.postMessage({type:"chunk-decompressed",transferId:q,fileIndex:V,filePath:$,offset:Y,data:N,bytesWritten:W.length},[N])}}catch(W){console.error(`[Worker] ERROR decompress-and-write: idx=${V}, path=${$}`,W),self.postMessage({type:"chunk-error",transferId:q,fileIndex:V,filePath:$,error:W instanceof Error?W.message:String(W)})}});M.set(G,K);break}case"get-file":{let{transferId:q,filePath:V}=j,$=await P(q,V);self.postMessage({type:"file-data",transferId:q,filePath:V,data:$},[$]);break}case"cleanup":{await h(j.transferId),self.postMessage({type:"cleanup-done",transferId:j.transferId});break}case"write-temp-file":{await m(j.transferId,j.path,j.data);break}case"create-zip-from-temp":{console.log(`[Worker] create-zip-from-temp: transferId=${j.transferId}, folderName=${j.folderName}`);let{zipData:q,filename:V}=await c(j.transferId,j.folderName);console.log(`[Worker] Zip created: size=${q.byteLength} bytes, filename=${V}`),self.postMessage({type:"zip-created",transferId:j.transferId,zipData:q,filename:V},[q]),console.log("[Worker] Sent zip-created message to main thread");break}case"cleanup-temp":{console.log(`[Worker] cleanup-temp: transferId=${j.transferId}`),await n(j.transferId),console.log("[Worker] Temp files cleaned up");break}case"cache-put":{let{id:q,serverPath:V,filePath:$,data:Y,metadata:J}=j;await l(V,$,Y,J),self.postMessage({type:"cache-put-done",id:q,serverPath:V,filePath:$});break}case"cache-get":{let{id:q,serverPath:V,filePath:$}=j,Y=await T(V,$);self.postMessage({type:"cache-file",id:q,serverPath:V,filePath:$,data:Y},[Y]);break}case"cache-list":{let{id:q,serverPath:V}=j,$=await H(V);self.postMessage({type:"cache-list-result",id:q,serverPath:V,files:$});break}case"cache-remove":{let{id:q,serverPath:V,filePath:$}=j;await d(V,$),self.postMessage({type:"cache-remove-done",id:q,serverPath:V,filePath:$});break}case"cache-clear-all":{let{id:q}=j;await o(),self.postMessage({type:"cache-cleared",id:q});break}case"cache-clear-path":{let{serverPath:q}=j;await i(q),self.postMessage({type:"cache-path-cleared",serverPath:q});break}case"cache-usage":{let{id:q}=j,V=await r();self.postMessage({type:"cache-usage-result",id:q,...V});break}case"compute-checksums":{let{id:q,serverPath:V,filePath:$,blockSize:Y}=j;try{let{rolling:J,strong:X}=await a(V,$,Y),G=J.buffer,Q=X.buffer;self.postMessage({type:"checksums-computed",id:q,rolling:G,strong:Q},[G,Q])}catch(J){let X=J instanceof Error?J.message:"Checksum computation failed";self.postMessage({type:"checksums-error",id:q,message:X})}break}case"apply-delta":{let{id:q,serverPath:V,filePath:$,deltaPayload:Y}=j;try{let J=new Uint8Array(await T(V,$)),G=e(J,new Uint8Array(Y)).buffer;self.postMessage({type:"delta-applied",id:q,data:G},[G])}catch(J){let X=J instanceof Error?J.message:"Delta application failed";self.postMessage({type:"delta-error",id:q,message:X})}break}case"save-transfer-metadata":{await z(j.metadata),self.postMessage({type:"metadata-saved",transferId:j.metadata.transferId});break}case"load-transfer-metadata":{let q=await b(j.transferId);self.postMessage({type:"metadata-loaded",transferId:j.transferId,metadata:q});break}case"delete-transfer-metadata":{await qj(j.transferId),self.postMessage({type:"metadata-deleted",transferId:j.transferId});break}case"get-interrupted-transfers":{let q=await Jj();self.postMessage({type:"interrupted-transfers",transfers:q});break}}}catch(q){let V=q instanceof Error?q.message:"Unknown error";self.postMessage({type:"error",message:V,originalType:j.type,...j})}};
