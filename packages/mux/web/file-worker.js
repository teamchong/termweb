var L=null,W=null,E=!1,u=[],R=new Map,T=new Map,S=new Set,k=new Set,B=new Map,I=134217728;async function m(){let X=performance.now(),j=await fetch("/zstd.wasm").then((V)=>V.arrayBuffer());console.log(`[Worker] fetch zstd.wasm: ${(performance.now()-X).toFixed(0)}ms (${j.byteLength} bytes)`);let J=null,$={args_sizes_get:(V,G)=>{let K=new DataView(J.buffer);return K.setUint32(V,0,!0),K.setUint32(G,0,!0),0},args_get:()=>0,environ_sizes_get:(V,G)=>{let K=new DataView(J.buffer);return K.setUint32(V,0,!0),K.setUint32(G,0,!0),0},environ_get:()=>0,clock_time_get:()=>0,fd_close:()=>0,fd_fdstat_get:()=>0,fd_prestat_get:()=>8,fd_prestat_dir_name:()=>8,fd_read:()=>0,fd_seek:()=>0,fd_write:()=>0,proc_exit:()=>{},random_get:()=>0},U=performance.now(),{instance:Y}=await WebAssembly.instantiate(j,{wasi_snapshot_preview1:$});J=Y.exports.memory,L=Y.exports,console.log(`[Worker] WASM compile: ${(performance.now()-U).toFixed(0)}ms`),console.log(`[Worker] initWasm total: ${(performance.now()-X).toFixed(0)}ms`)}async function c(X){W=X,console.log("[Worker] OPFS root received from main thread"),E=!0,console.log("[Worker] OPFS ready");let j=u.splice(0);if(j.length>0){console.log(`[Worker] Flushing ${j.length} queued OPFS operations`);for(let J of j)self.dispatchEvent(new MessageEvent("message",{data:J.msg}))}self.postMessage({type:"opfs-ready"})}function x(X){if(E)return!1;return console.log(`[Worker] OPFS not ready, queuing: ${X.type}`),u.push({msg:X}),!0}function y(X){if(!L)throw new Error("WASM not initialized");let j=X.length,J=L.zstd_alloc(j);if(J===0)throw new Error("zstd alloc failed");new Uint8Array(L.memory.buffer,J,j).set(X);let $=L.zstd_frame_content_size(J,j);if($===0||$>I)$=Math.min(j*8,I);let U=L.zstd_alloc($);if(U===0)throw L.zstd_free(J,j),new Error("zstd alloc failed");try{let Y=L.zstd_decompress(U,$,J,j);if(Y===0)throw new Error("zstd decompression failed");return new Uint8Array(L.memory.buffer.slice(U,U+Y))}finally{L.zstd_free(J,j),L.zstd_free(U,$)}}function n(X,j){if(!L)throw new Error("WASM not initialized");let J=X.length,$=L.zstd_compress_bound(J),U=L.zstd_alloc(J),Y=L.zstd_alloc($);if(U===0||Y===0){if(U)L.zstd_free(U,J);if(Y)L.zstd_free(Y,$);throw new Error("zstd alloc failed")}try{new Uint8Array(L.memory.buffer,U,J).set(X);let V=L.zstd_compress(Y,$,U,J,j);if(V===0)throw new Error("zstd compression failed");return new Uint8Array(L.memory.buffer.slice(Y,Y+V))}finally{L.zstd_free(U,J),L.zstd_free(Y,$)}}async function M(X,j){return X.getDirectoryHandle(j,{create:!0})}async function p(X){if(!W)return;for(let[j,J]of R)if(j.startsWith(`${X}/`)){try{J.flush()}catch{}try{J.close()}catch{}R.delete(j)}try{await(await W.getDirectoryHandle("termweb-transfers")).removeEntry(String(X),{recursive:!0})}catch{}}var l="termweb-temp";async function f(X){if(!W)return;try{await(await W.getDirectoryHandle(l)).removeEntry(String(X),{recursive:!0})}catch{}}var g=new Uint32Array(256);for(let X=0;X<256;X++){let j=X;for(let J=0;J<8;J++)j=j&1?3988292384^j>>>1:j>>>1;g[X]=j}function d(X){let j=-1;for(let J=0;J<X.length;J++)j=g[(j^X[J])&255]^j>>>8;return~j>>>0}function o(X){let j=new TextEncoder,J=[],$=22;for(let[Q,Z]of X){let A=j.encode(Q);$+=30+A.length+Z.length,$+=46+A.length}let U=new Uint8Array($),Y=new DataView(U.buffer),V=0;for(let[Q,Z]of X){let A=j.encode(Q),q=d(Z),N=V;Y.setUint32(V,67324752,!0),V+=4,Y.setUint16(V,20,!0),V+=2,Y.setUint16(V,0,!0),V+=2,Y.setUint16(V,0,!0),V+=2,Y.setUint16(V,0,!0),V+=2,Y.setUint16(V,0,!0),V+=2,Y.setUint32(V,q,!0),V+=4,Y.setUint32(V,Z.length,!0),V+=4,Y.setUint32(V,Z.length,!0),V+=4,Y.setUint16(V,A.length,!0),V+=2,Y.setUint16(V,0,!0),V+=2,U.set(A,V),V+=A.length,U.set(Z,V),V+=Z.length,J.push({name:A,data:Z,crc:q,offset:N})}let G=V;for(let Q of J)Y.setUint32(V,33639248,!0),V+=4,Y.setUint16(V,20,!0),V+=2,Y.setUint16(V,20,!0),V+=2,Y.setUint16(V,0,!0),V+=2,Y.setUint16(V,0,!0),V+=2,Y.setUint16(V,0,!0),V+=2,Y.setUint16(V,0,!0),V+=2,Y.setUint32(V,Q.crc,!0),V+=4,Y.setUint32(V,Q.data.length,!0),V+=4,Y.setUint32(V,Q.data.length,!0),V+=4,Y.setUint16(V,Q.name.length,!0),V+=2,Y.setUint16(V,0,!0),V+=2,Y.setUint16(V,0,!0),V+=2,Y.setUint16(V,0,!0),V+=2,Y.setUint16(V,0,!0),V+=2,Y.setUint32(V,0,!0),V+=4,Y.setUint32(V,Q.offset,!0),V+=4,U.set(Q.name,V),V+=Q.name.length;let K=V-G;return Y.setUint32(V,101010256,!0),V+=4,Y.setUint16(V,0,!0),V+=2,Y.setUint16(V,0,!0),V+=2,Y.setUint16(V,J.length,!0),V+=2,Y.setUint16(V,J.length,!0),V+=2,Y.setUint32(V,K,!0),V+=4,Y.setUint32(V,G,!0),V+=4,Y.setUint16(V,0,!0),U}var _="termweb-cache";async function b(X){if(!W)throw new Error("OPFS not available");let j=await M(W,_),J=X.replace(/^\/+/,"");if(J){for(let $ of J.split("/"))if($)j=await M(j,$)}return j}async function O(X){let j=await b(X);return M(j,"files")}async function z(X){try{let U=await(await(await(await b(X)).getFileHandle(".termweb-meta")).getFile()).text();return JSON.parse(U)}catch{return{}}}async function h(X,j){let U=await(await(await b(X)).getFileHandle(".termweb-meta",{create:!0})).createSyncAccessHandle();try{let Y=new TextEncoder().encode(JSON.stringify(j));U.truncate(0),U.write(Y,{at:0}),U.flush()}finally{U.close()}}async function i(X,j,J,$){let U=await O(X),Y=j.split("/"),V=U;for(let Z=0;Z<Y.length-1;Z++)V=await M(V,Y[Z]);let K=await(await V.getFileHandle(Y[Y.length-1],{create:!0})).createSyncAccessHandle();try{K.truncate(0),K.write(new Uint8Array(J),{at:0}),K.flush()}finally{K.close()}let Q=await z(X);Q[j]=$,await h(X,Q)}async function F(X,j){let J=await O(X),$=j.split("/"),U=J;for(let G=0;G<$.length-1;G++)U=await U.getDirectoryHandle($[G]);return(await(await U.getFileHandle($[$.length-1])).getFile()).arrayBuffer()}async function r(X,j){let J=await z(X);delete J[j],await h(X,J);try{let $=await O(X),U=j.split("/"),Y=$;for(let V=0;V<U.length-1;V++)Y=await Y.getDirectoryHandle(U[V]);await Y.removeEntry(U[U.length-1])}catch{}}async function s(){if(!W)return;try{await W.removeEntry(_,{recursive:!0})}catch{}}async function t(X){if(!W)return;try{let j=await W.getDirectoryHandle(_),J=X.replace(/^\/+/,"");if(J){let $=J.split("/").filter((Y)=>Y);if($.length===0)return;let U=j;for(let Y=0;Y<$.length-1;Y++)U=await U.getDirectoryHandle($[Y]);await U.removeEntry($[$.length-1],{recursive:!0})}}catch{}}async function a(){if(!W)return{totalBytes:0,fileCount:0};let X=0,j=0;async function J($){for await(let[,U]of $)if(U.kind==="file"){let Y=await U.getFile();X+=Y.size,j++}else await J(U)}try{let $=await W.getDirectoryHandle(_);await J($)}catch{}return{totalBytes:X,fileCount:j}}function e(X){let j=0,J=0;for(let $=0;$<X.length;$++)j=j+X[$]&65535,J=J+j&65535;return(J<<16|j)>>>0}function jj(X){let j=0xcbf29ce484222325n,J=0x100000001b3n;for(let $=0;$<X.length;$++)j^=BigInt(X[$]),j=j*J&0xFFFFFFFFFFFFFFFFn;return j}async function Jj(X,j,J){let $=new Uint8Array(await F(X,j)),U=Math.ceil($.length/J),Y=new Uint32Array(U),V=new BigUint64Array(U);for(let G=0;G<U;G++){let K=G*J,Q=Math.min(K+J,$.length),Z=$.subarray(K,Q);Y[G]=e(Z),V[G]=jj(Z)}return{rolling:Y,strong:V}}function Vj(X,j){let J=new DataView(j.buffer,j.byteOffset,j.byteLength),$=[],U=0,Y=0;while(Y<j.length){let K=j[Y];if(Y+=1,K===0){let Q=Number(J.getBigUint64(Y,!0));Y+=8;let Z=J.getUint32(Y,!0);Y+=4;let A=X.slice(Q,Q+Z);$.push(A),U+=A.length}else if(K===1){let Q=J.getUint32(Y,!0);Y+=4;let Z=j.slice(Y,Y+Q);$.push(Z),U+=Q,Y+=Q}else break}let V=new Uint8Array(U),G=0;for(let K of $)V.set(K,G),G+=K.length;return V}async function P(X){if(!W)return;try{let U=await(await(await(await W.getDirectoryHandle("transfers",{create:!0})).getDirectoryHandle(`${X.transferId}`,{create:!0})).getFileHandle("metadata.json",{create:!0})).createWritable();await U.write(JSON.stringify(X)),await U.close(),console.log(`[Worker] Saved metadata for transfer ${X.transferId}`)}catch(j){console.error("[Worker] Failed to save transfer metadata:",j)}}async function C(X){if(!W)return null;try{let Y=await(await(await(await(await W.getDirectoryHandle("transfers",{create:!1})).getDirectoryHandle(`${X}`,{create:!1})).getFileHandle("metadata.json",{create:!1})).getFile()).text();return JSON.parse(Y)}catch{return null}}async function w(X,j,J){if(k.has(X))return;let $=await C(X);if(!$)return;if(!$.completedFiles.includes(j))$.completedFiles.push(j);$.bytesTransferred+=J,$.lastUpdateTime=Date.now(),await P($)}async function v(X){if(!W)return;try{await(await W.getDirectoryHandle("transfers",{create:!1})).removeEntry(`${X}`,{recursive:!0}),console.log(`[Worker] Deleted metadata for transfer ${X}`)}catch(j){console.error("[Worker] Failed to delete transfer metadata:",j)}}async function Yj(){if(!W)return[];try{let X=await W.getDirectoryHandle("transfers",{create:!1}),j=[];for await(let J of X.values())if(J.kind==="directory"){let $=parseInt(J.name),U=await C($);if(U)j.push(U)}return j}catch{return[]}}self.onmessage=async(X)=>{let j=X.data;try{switch(j.type){case"init":{await m(),self.postMessage({type:"init-done"});break}case"set-opfs-root":{if(j.opfsRoot)c(j.opfsRoot).catch((J)=>{console.error("[Worker] OPFS activation failed:",J)});break}case"decompress":{let $=y(new Uint8Array(j.data)).buffer;self.postMessage({type:"decompressed",id:j.id,data:$},[$]);break}case"compress":{let $=n(new Uint8Array(j.data),j.level||3).buffer;self.postMessage({type:"compressed",id:j.id,data:$},[$]);break}case"decompress-and-write":{let{transferId:J,fileIndex:$,filePath:U,compressedData:Y,fileSize:V}=j,G=`${J}/${U}`,Q=(T.get(G)||Promise.resolve()).then(async()=>{try{if(k.has(J))return;if(S.has(G))return;let Z=y(new Uint8Array(Y));if(!B.has(J))B.set(J,new Map);let A=B.get(J),q=A.get(U);if(q){let H=new Uint8Array(q.length+Z.length);H.set(q),H.set(Z,q.length),A.set(U,H)}else A.set(U,Z);let N=A.get(U).length,D=N>=V;if(D)S.add(G),T.delete(G),await w(J,U,N);self.postMessage({type:"chunk-written",transferId:J,fileIndex:$,filePath:U,bytesWritten:Z.length,complete:D})}catch(Z){console.error(`[Worker] ERROR decompress-and-write: idx=${$}, path=${U}`,Z),self.postMessage({type:"chunk-error",transferId:J,fileIndex:$,filePath:U,error:Z instanceof Error?Z.message:String(Z)})}});T.set(G,Q);break}case"get-file":{let{transferId:J,filePath:$}=j,Y=B.get(J)?.get($);if(Y){let V=Y.buffer.slice(Y.byteOffset,Y.byteOffset+Y.byteLength);self.postMessage({type:"file-data",transferId:J,filePath:$,data:V},[V])}else console.error(`[Worker] get-file: not found: ${$}`);break}case"cleanup":{if(B.delete(j.transferId),E)await p(j.transferId);self.postMessage({type:"cleanup-done",transferId:j.transferId});break}case"write-temp-file":{if(!B.has(j.transferId))B.set(j.transferId,new Map);let J=new Uint8Array(j.data);B.get(j.transferId).set(j.path,J),await w(j.transferId,j.path,J.length);break}case"create-zip-from-temp":{let J=B.get(j.transferId);if(!J||J.size===0){console.error(`[Worker] create-zip-from-temp: No files for transfer ${j.transferId}`);break}console.log(`[Worker] Creating zip from ${J.size} in-memory files`);let $=o(J),Y=`${j.folderName||"download"}.zip`;console.log(`[Worker] Zip created: ${$.length} bytes, filename: ${Y}`);let V=$.buffer;self.postMessage({type:"zip-created",transferId:j.transferId,zipData:V,filename:Y},[V]);break}case"cleanup-temp":{if(B.delete(j.transferId),E)await f(j.transferId);break}case"cache-put":{if(x(j))break;let{id:J,serverPath:$,filePath:U,data:Y,metadata:V}=j;await i($,U,Y,V),self.postMessage({type:"cache-put-done",id:J,serverPath:$,filePath:U});break}case"cache-get":{if(x(j))break;let{id:J,serverPath:$,filePath:U}=j,Y=await F($,U);self.postMessage({type:"cache-file",id:J,serverPath:$,filePath:U,data:Y},[Y]);break}case"cache-list":{if(x(j))break;let{id:J,serverPath:$}=j,U=await z($);self.postMessage({type:"cache-list-result",id:J,serverPath:$,files:U});break}case"cache-remove":{if(x(j))break;let{id:J,serverPath:$,filePath:U}=j;await r($,U),self.postMessage({type:"cache-remove-done",id:J,serverPath:$,filePath:U});break}case"cache-clear-all":{if(x(j))break;let{id:J}=j;await s(),self.postMessage({type:"cache-cleared",id:J});break}case"cache-clear-path":{if(x(j))break;let{serverPath:J}=j;await t(J),self.postMessage({type:"cache-path-cleared",serverPath:J});break}case"cache-usage":{if(x(j))break;let{id:J}=j,$=await a();self.postMessage({type:"cache-usage-result",id:J,...$});break}case"compute-checksums":{if(x(j))break;let{id:J,serverPath:$,filePath:U,blockSize:Y}=j;try{let{rolling:V,strong:G}=await Jj($,U,Y),K=V.buffer,Q=G.buffer;self.postMessage({type:"checksums-computed",id:J,rolling:K,strong:Q},[K,Q])}catch(V){let G=V instanceof Error?V.message:"Checksum computation failed";self.postMessage({type:"checksums-error",id:J,message:G})}break}case"apply-delta":{if(x(j))break;let{id:J,serverPath:$,filePath:U,deltaPayload:Y}=j;try{let V=new Uint8Array(await F($,U)),K=Vj(V,new Uint8Array(Y)).buffer;self.postMessage({type:"delta-applied",id:J,data:K},[K])}catch(V){let G=V instanceof Error?V.message:"Delta application failed";self.postMessage({type:"delta-error",id:J,message:G})}break}case"save-transfer-metadata":{if(x(j))break;await P(j.metadata),self.postMessage({type:"metadata-saved",transferId:j.metadata.transferId});break}case"load-transfer-metadata":{if(x(j))break;let J=await C(j.transferId);self.postMessage({type:"metadata-loaded",transferId:j.transferId,metadata:J});break}case"delete-transfer-metadata":{if(x(j))break;k.add(j.transferId),await v(j.transferId),setTimeout(()=>v(j.transferId),2000),self.postMessage({type:"metadata-deleted",transferId:j.transferId});break}case"get-interrupted-transfers":{if(x(j))break;let J=await Yj();self.postMessage({type:"interrupted-transfers",transfers:J});break}}}catch(J){let $=J instanceof Error?J.message:"Unknown error";self.postMessage({type:"error",message:$,originalType:j.type,...j})}};
