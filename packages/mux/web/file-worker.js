var QJ=typeof navigator!=="undefined"&&(navigator.userAgentData?.platform==="macOS"||/Mac|iPhone|iPad|iPod/.test(navigator.userAgent));var R=new Uint32Array(256);for(let Z=0;Z<256;Z++){let J=Z;for(let $=0;$<8;$++)J=J>>>1^(J&1?3988292384:0);R[Z]=J}function c(Z){let J=-1;for(let $=0;$<Z.length;$++)J=R[(J^Z[$])&255]^J>>>8;return~J>>>0}function I(Z){let J=new TextEncoder,$=[],j=22;for(let[G,W]of Z){let A=J.encode(G);j+=30+A.length+W.length,j+=46+A.length}let X=new Uint8Array(j),U=new DataView(X.buffer),V=0;for(let[G,W]of Z){let A=J.encode(G),B=c(W),N=V;U.setUint32(V,67324752,!0),V+=4,U.setUint16(V,20,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint32(V,B,!0),V+=4,U.setUint32(V,W.length,!0),V+=4,U.setUint32(V,W.length,!0),V+=4,U.setUint16(V,A.length,!0),V+=2,U.setUint16(V,0,!0),V+=2,X.set(A,V),V+=A.length,X.set(W,V),V+=W.length,$.push({name:A,data:W,crc:B,offset:N})}let K=V;for(let G of $)U.setUint32(V,33639248,!0),V+=4,U.setUint16(V,20,!0),V+=2,U.setUint16(V,20,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint32(V,G.crc,!0),V+=4,U.setUint32(V,G.data.length,!0),V+=4,U.setUint32(V,G.data.length,!0),V+=4,U.setUint16(V,G.name.length,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint32(V,0,!0),V+=4,U.setUint32(V,G.offset,!0),V+=4,X.set(G.name,V),V+=G.name.length;let Y=V-K;return U.setUint32(V,101010256,!0),V+=4,U.setUint16(V,0,!0),V+=2,U.setUint16(V,0,!0),V+=2,U.setUint16(V,$.length,!0),V+=2,U.setUint16(V,$.length,!0),V+=2,U.setUint32(V,Y,!0),V+=4,U.setUint32(V,K,!0),V+=4,U.setUint16(V,0,!0),V+=2,X.slice(0,V)}var Q=null,L=null,F=!1,g=[],w=new Map,k=new Map,b=new Set,x=new Set,M=new Map,y=134217728;function n(){let J=new URLSearchParams(self.location.search).get("token");return J?`?token=${encodeURIComponent(J)}`:""}async function p(){let Z=performance.now(),J=await fetch(`/zstd.wasm${n()}`).then((V)=>V.arrayBuffer());console.log(`[Worker] fetch zstd.wasm: ${(performance.now()-Z).toFixed(0)}ms (${J.byteLength} bytes)`);let $=null,j={args_sizes_get:(V,K)=>{let Y=new DataView($.buffer);return Y.setUint32(V,0,!0),Y.setUint32(K,0,!0),0},args_get:()=>0,environ_sizes_get:(V,K)=>{let Y=new DataView($.buffer);return Y.setUint32(V,0,!0),Y.setUint32(K,0,!0),0},environ_get:()=>0,clock_time_get:()=>0,fd_close:()=>0,fd_fdstat_get:()=>0,fd_prestat_get:()=>8,fd_prestat_dir_name:()=>8,fd_read:()=>0,fd_seek:()=>0,fd_write:()=>0,proc_exit:()=>{},random_get:()=>0},X=performance.now(),{instance:U}=await WebAssembly.instantiate(J,{wasi_snapshot_preview1:j});$=U.exports.memory,Q=U.exports,console.log(`[Worker] WASM compile: ${(performance.now()-X).toFixed(0)}ms`),console.log(`[Worker] initWasm total: ${(performance.now()-Z).toFixed(0)}ms`)}async function d(Z){L=Z,console.log("[Worker] OPFS root received from main thread"),F=!0,console.log("[Worker] OPFS ready");let J=g.splice(0);if(J.length>0){console.log(`[Worker] Flushing ${J.length} queued OPFS operations`);for(let $ of J)self.dispatchEvent(new MessageEvent("message",{data:$.msg}))}self.postMessage({type:"opfs-ready"})}function q(Z){if(F)return!1;return console.log(`[Worker] OPFS not ready, queuing: ${Z.type}`),g.push({msg:Z}),!0}function u(Z){if(!Q)throw new Error("WASM not initialized");let J=Z.length,$=Q.zstd_alloc(J);if($===0)throw new Error("zstd alloc failed");new Uint8Array(Q.memory.buffer,$,J).set(Z);let j=Q.zstd_frame_content_size($,J);if(j===0||j>y)j=Math.min(J*8,y);let X=Q.zstd_alloc(j);if(X===0)throw Q.zstd_free($,J),new Error("zstd alloc failed");try{let U=Q.zstd_decompress(X,j,$,J);if(U===0)throw new Error("zstd decompression failed");return new Uint8Array(Q.memory.buffer.slice(X,X+U))}finally{Q.zstd_free($,J),Q.zstd_free(X,j)}}function f(Z,J){if(!Q)throw new Error("WASM not initialized");let $=Z.length,j=Q.zstd_compress_bound($),X=Q.zstd_alloc($),U=Q.zstd_alloc(j);if(X===0||U===0){if(X)Q.zstd_free(X,$);if(U)Q.zstd_free(U,j);throw new Error("zstd alloc failed")}try{new Uint8Array(Q.memory.buffer,X,$).set(Z);let V=Q.zstd_compress(U,j,X,$,J);if(V===0)throw new Error("zstd compression failed");return new Uint8Array(Q.memory.buffer.slice(U,U+V))}finally{Q.zstd_free(X,$),Q.zstd_free(U,j)}}async function H(Z,J){return Z.getDirectoryHandle(J,{create:!0})}async function l(Z){if(!L)return;for(let[J,$]of w)if(J.startsWith(`${Z}/`)){try{$.flush()}catch{}try{$.close()}catch{}w.delete(J)}try{await(await L.getDirectoryHandle("termweb-transfers")).removeEntry(String(Z),{recursive:!0})}catch{}}var i="termweb-temp";async function o(Z){if(!L)return;try{await(await L.getDirectoryHandle(i)).removeEntry(String(Z),{recursive:!0})}catch{}}var _="termweb-cache";async function z(Z){if(!L)throw new Error("OPFS not available");let J=await H(L,_),$=Z.replace(/^\/+/,"");if($){for(let j of $.split("/"))if(j)J=await H(J,j)}return J}async function O(Z){let J=await z(Z);return H(J,"files")}async function C(Z){try{let X=await(await(await(await z(Z)).getFileHandle(".termweb-meta")).getFile()).text();return JSON.parse(X)}catch{return{}}}async function h(Z,J){let X=await(await(await z(Z)).getFileHandle(".termweb-meta",{create:!0})).createSyncAccessHandle();try{let U=new TextEncoder().encode(JSON.stringify(J));X.truncate(0),X.write(U,{at:0}),X.flush()}finally{X.close()}}async function r(Z,J,$,j){let X=await O(Z),U=J.split("/"),V=X;for(let W=0;W<U.length-1;W++)V=await H(V,U[W]);let Y=await(await V.getFileHandle(U[U.length-1],{create:!0})).createSyncAccessHandle();try{Y.truncate(0),Y.write(new Uint8Array($),{at:0}),Y.flush()}finally{Y.close()}let G=await C(Z);G[J]=j,await h(Z,G)}async function T(Z,J){let $=await O(Z),j=J.split("/"),X=$;for(let K=0;K<j.length-1;K++)X=await X.getDirectoryHandle(j[K]);return(await(await X.getFileHandle(j[j.length-1])).getFile()).arrayBuffer()}async function s(Z,J){let $=await C(Z);delete $[J],await h(Z,$);try{let j=await O(Z),X=J.split("/"),U=j;for(let V=0;V<X.length-1;V++)U=await U.getDirectoryHandle(X[V]);await U.removeEntry(X[X.length-1])}catch{}}async function a(){if(!L)return;try{await L.removeEntry(_,{recursive:!0})}catch{}}async function t(Z){if(!L)return;try{let J=await L.getDirectoryHandle(_),$=Z.replace(/^\/+/,"");if($){let j=$.split("/").filter((U)=>U);if(j.length===0)return;let X=J;for(let U=0;U<j.length-1;U++)X=await X.getDirectoryHandle(j[U]);await X.removeEntry(j[j.length-1],{recursive:!0})}}catch{}}async function e(){if(!L)return{totalBytes:0,fileCount:0};let Z=0,J=0;async function $(j){for await(let[,X]of j)if(X.kind==="file"){let U=await X.getFile();Z+=U.size,J++}else await $(X)}try{let j=await L.getDirectoryHandle(_);await $(j)}catch{}return{totalBytes:Z,fileCount:J}}function JJ(Z){let J=0,$=0;for(let j=0;j<Z.length;j++)J=J+Z[j]&65535,$=$+J&65535;return($<<16|J)>>>0}function VJ(Z){let J=0xcbf29ce484222325n,$=0x100000001b3n;for(let j=0;j<Z.length;j++)J^=BigInt(Z[j]),J=J*$&0xFFFFFFFFFFFFFFFFn;return J}async function $J(Z,J,$){let j=new Uint8Array(await T(Z,J)),X=Math.ceil(j.length/$),U=new Uint32Array(X),V=new BigUint64Array(X);for(let K=0;K<X;K++){let Y=K*$,G=Math.min(Y+$,j.length),W=j.subarray(Y,G);U[K]=JJ(W),V[K]=VJ(W)}return{rolling:U,strong:V}}function UJ(Z,J){let $=new DataView(J.buffer,J.byteOffset,J.byteLength),j=[],X=0,U=0;while(U<J.length){let Y=J[U];if(U+=1,Y===0){let G=Number($.getBigUint64(U,!0));U+=8;let W=$.getUint32(U,!0);U+=4;let A=Z.slice(G,G+W);j.push(A),X+=A.length}else if(Y===1){let G=$.getUint32(U,!0);U+=4;let W=J.slice(U,U+G);j.push(W),X+=G,U+=G}else break}let V=new Uint8Array(X),K=0;for(let Y of j)V.set(Y,K),K+=Y.length;return V}async function m(Z){if(!L)return;try{let X=await(await(await(await L.getDirectoryHandle("transfers",{create:!0})).getDirectoryHandle(`${Z.transferId}`,{create:!0})).getFileHandle("metadata.json",{create:!0})).createWritable();await X.write(JSON.stringify(Z)),await X.close(),console.log(`[Worker] Saved metadata for transfer ${Z.transferId}`)}catch(J){console.error("[Worker] Failed to save transfer metadata:",J)}}async function D(Z){if(!L)return null;try{let U=await(await(await(await(await L.getDirectoryHandle("transfers",{create:!1})).getDirectoryHandle(`${Z}`,{create:!1})).getFileHandle("metadata.json",{create:!1})).getFile()).text();return JSON.parse(U)}catch{return null}}async function v(Z,J,$){if(x.has(Z))return;let j=await D(Z);if(!j)return;if(!j.completedFiles.includes(J))j.completedFiles.push(J);j.bytesTransferred+=$,j.lastUpdateTime=Date.now(),await m(j)}async function P(Z){if(!L)return;try{await(await L.getDirectoryHandle("transfers",{create:!1})).removeEntry(`${Z}`,{recursive:!0}),console.log(`[Worker] Deleted metadata for transfer ${Z}`)}catch(J){console.error("[Worker] Failed to delete transfer metadata:",J)}}async function jJ(){if(!L)return[];try{let Z=await L.getDirectoryHandle("transfers",{create:!1}),J=[];for await(let $ of Z.values())if($.kind==="directory"){let j=parseInt($.name),X=await D(j);if(X)J.push(X)}return J}catch{return[]}}self.onmessage=async(Z)=>{let J=Z.data;try{switch(J.type){case"init":{await p(),self.postMessage({type:"init-done"});break}case"set-opfs-root":{if(J.opfsRoot)d(J.opfsRoot).catch(($)=>{console.error("[Worker] OPFS activation failed:",$)});break}case"decompress":{let j=u(new Uint8Array(J.data)).buffer;self.postMessage({type:"decompressed",id:J.id,data:j},[j]);break}case"compress":{let j=f(new Uint8Array(J.data),J.level||3).buffer;self.postMessage({type:"compressed",id:J.id,data:j},[j]);break}case"decompress-and-write":{let{transferId:$,fileIndex:j,filePath:X,compressedData:U,fileSize:V}=J,K=`${$}/${X}`,G=(k.get(K)||Promise.resolve()).then(async()=>{try{if(x.has($))return;if(b.has(K))return;let W=u(new Uint8Array(U));if(!M.has($))M.set($,new Map);let A=M.get($),B=A.get(X);if(B){let E=new Uint8Array(B.length+W.length);E.set(B),E.set(W,B.length),A.set(X,E)}else A.set(X,W);let N=A.get(X).length,S=N>=V;if(S)b.add(K),k.delete(K),await v($,X,N);self.postMessage({type:"chunk-written",transferId:$,fileIndex:j,filePath:X,bytesWritten:W.length,complete:S})}catch(W){console.error(`[Worker] ERROR decompress-and-write: idx=${j}, path=${X}`,W),self.postMessage({type:"chunk-error",transferId:$,fileIndex:j,filePath:X,error:W instanceof Error?W.message:String(W)})}});k.set(K,G);break}case"get-file":{let{transferId:$,filePath:j}=J,U=M.get($)?.get(j);if(U){let V=U.buffer.slice(U.byteOffset,U.byteOffset+U.byteLength);self.postMessage({type:"file-data",transferId:$,filePath:j,data:V},[V])}else console.error(`[Worker] get-file: not found: ${j}`);break}case"cleanup":{if(M.delete(J.transferId),F)await l(J.transferId);self.postMessage({type:"cleanup-done",transferId:J.transferId});break}case"write-temp-file":{if(!M.has(J.transferId))M.set(J.transferId,new Map);let $=new Uint8Array(J.data);M.get(J.transferId).set(J.path,$),await v(J.transferId,J.path,$.length);break}case"create-zip-from-temp":{let $=M.get(J.transferId);if(!$||$.size===0){console.error(`[Worker] create-zip-from-temp: No files for transfer ${J.transferId}`);break}console.log(`[Worker] Creating zip from ${$.size} in-memory files`);let j=I($),U=`${J.folderName||"download"}.zip`;console.log(`[Worker] Zip created: ${j.length} bytes, filename: ${U}`);let V=j.buffer;self.postMessage({type:"zip-created",transferId:J.transferId,zipData:V,filename:U},[V]);break}case"cleanup-temp":{if(M.delete(J.transferId),F)await o(J.transferId);break}case"cache-put":{if(q(J))break;let{id:$,serverPath:j,filePath:X,data:U,metadata:V}=J;await r(j,X,U,V),self.postMessage({type:"cache-put-done",id:$,serverPath:j,filePath:X});break}case"cache-get":{if(q(J))break;let{id:$,serverPath:j,filePath:X}=J,U=await T(j,X);self.postMessage({type:"cache-file",id:$,serverPath:j,filePath:X,data:U},[U]);break}case"cache-list":{if(q(J))break;let{id:$,serverPath:j}=J,X=await C(j);self.postMessage({type:"cache-list-result",id:$,serverPath:j,files:X});break}case"cache-remove":{if(q(J))break;let{id:$,serverPath:j,filePath:X}=J;await s(j,X),self.postMessage({type:"cache-remove-done",id:$,serverPath:j,filePath:X});break}case"cache-clear-all":{if(q(J))break;let{id:$}=J;await a(),self.postMessage({type:"cache-cleared",id:$});break}case"cache-clear-path":{if(q(J))break;let{serverPath:$}=J;await t($),self.postMessage({type:"cache-path-cleared",serverPath:$});break}case"cache-usage":{if(q(J))break;let{id:$}=J,j=await e();self.postMessage({type:"cache-usage-result",id:$,...j});break}case"compute-checksums":{if(q(J))break;let{id:$,serverPath:j,filePath:X,blockSize:U}=J;try{let{rolling:V,strong:K}=await $J(j,X,U),Y=V.buffer,G=K.buffer;self.postMessage({type:"checksums-computed",id:$,rolling:Y,strong:G},[Y,G])}catch(V){let K=V instanceof Error?V.message:"Checksum computation failed";self.postMessage({type:"checksums-error",id:$,message:K})}break}case"apply-delta":{if(q(J))break;let{id:$,serverPath:j,filePath:X,deltaPayload:U}=J;try{let V=new Uint8Array(await T(j,X)),Y=UJ(V,new Uint8Array(U)).buffer;self.postMessage({type:"delta-applied",id:$,data:Y},[Y])}catch(V){let K=V instanceof Error?V.message:"Delta application failed";self.postMessage({type:"delta-error",id:$,message:K})}break}case"save-transfer-metadata":{if(q(J))break;await m(J.metadata),self.postMessage({type:"metadata-saved",transferId:J.metadata.transferId});break}case"load-transfer-metadata":{if(q(J))break;let $=await D(J.transferId);self.postMessage({type:"metadata-loaded",transferId:J.transferId,metadata:$});break}case"delete-transfer-metadata":{if(q(J))break;x.add(J.transferId),await P(J.transferId),setTimeout(()=>P(J.transferId),2000),self.postMessage({type:"metadata-deleted",transferId:J.transferId});break}case"get-interrupted-transfers":{if(q(J))break;let $=await jJ();self.postMessage({type:"interrupted-transfers",transfers:$});break}}}catch($){let j=$ instanceof Error?$.message:"Unknown error";self.postMessage({type:"error",message:j,originalType:J.type,...J})}};
