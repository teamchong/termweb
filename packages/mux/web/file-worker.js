var W=null,L=null,H=!1,w=[],C=new Map,T=new Map,D=new Set,R=new Set,B=new Map,S=134217728;async function P(){let X=performance.now(),j=await fetch("/zstd.wasm").then((J)=>J.arrayBuffer());console.log(`[Worker] fetch zstd.wasm: ${(performance.now()-X).toFixed(0)}ms (${j.byteLength} bytes)`);let V=null,$={args_sizes_get:(J,G)=>{let K=new DataView(V.buffer);return K.setUint32(J,0,!0),K.setUint32(G,0,!0),0},args_get:()=>0,environ_sizes_get:(J,G)=>{let K=new DataView(V.buffer);return K.setUint32(J,0,!0),K.setUint32(G,0,!0),0},environ_get:()=>0,clock_time_get:()=>0,fd_close:()=>0,fd_fdstat_get:()=>0,fd_prestat_get:()=>8,fd_prestat_dir_name:()=>8,fd_read:()=>0,fd_seek:()=>0,fd_write:()=>0,proc_exit:()=>{},random_get:()=>0},U=performance.now(),{instance:Y}=await WebAssembly.instantiate(j,{wasi_snapshot_preview1:$});V=Y.exports.memory,W=Y.exports,console.log(`[Worker] WASM compile: ${(performance.now()-U).toFixed(0)}ms`),console.log(`[Worker] initWasm total: ${(performance.now()-X).toFixed(0)}ms`)}async function h(X){let j=performance.now();L=X,console.log("[Worker] OPFS root received from main thread"),await jj(),console.log(`[Worker] clearAllTransferMetadata: ${(performance.now()-j).toFixed(0)}ms`),H=!0,console.log("[Worker] OPFS ready");let V=w.splice(0);if(V.length>0){console.log(`[Worker] Flushing ${V.length} queued OPFS operations`);for(let $ of V)self.dispatchEvent(new MessageEvent("message",{data:$.msg}))}self.postMessage({type:"opfs-ready"})}function x(X){if(H)return!1;return console.log(`[Worker] OPFS not ready, queuing: ${X.type}`),w.push({msg:X}),!0}function I(X){if(!W)throw new Error("WASM not initialized");let j=X.length,V=W.zstd_alloc(j);if(V===0)throw new Error("zstd alloc failed");new Uint8Array(W.memory.buffer,V,j).set(X);let $=W.zstd_frame_content_size(V,j);if($===0||$>S)$=Math.min(j*8,S);let U=W.zstd_alloc($);if(U===0)throw W.zstd_free(V,j),new Error("zstd alloc failed");try{let Y=W.zstd_decompress(U,$,V,j);if(Y===0)throw new Error("zstd decompression failed");return new Uint8Array(W.memory.buffer.slice(U,U+Y))}finally{W.zstd_free(V,j),W.zstd_free(U,$)}}function m(X,j){if(!W)throw new Error("WASM not initialized");let V=X.length,$=W.zstd_compress_bound(V),U=W.zstd_alloc(V),Y=W.zstd_alloc($);if(U===0||Y===0){if(U)W.zstd_free(U,V);if(Y)W.zstd_free(Y,$);throw new Error("zstd alloc failed")}try{new Uint8Array(W.memory.buffer,U,V).set(X);let J=W.zstd_compress(Y,$,U,V,j);if(J===0)throw new Error("zstd compression failed");return new Uint8Array(W.memory.buffer.slice(Y,Y+J))}finally{W.zstd_free(U,V),W.zstd_free(Y,$)}}async function N(X,j){return X.getDirectoryHandle(j,{create:!0})}async function c(X){if(!L)return;for(let[j,V]of C)if(j.startsWith(`${X}/`)){try{V.flush()}catch{}try{V.close()}catch{}C.delete(j)}try{await(await L.getDirectoryHandle("termweb-transfers")).removeEntry(String(X),{recursive:!0})}catch{}}var u=new Uint32Array(256);for(let X=0;X<256;X++){let j=X;for(let V=0;V<8;V++)j=j&1?3988292384^j>>>1:j>>>1;u[X]=j}function n(X){let j=-1;for(let V=0;V<X.length;V++)j=u[(j^X[V])&255]^j>>>8;return~j>>>0}function p(X){let j=new TextEncoder,V=[],$=22;for(let[Q,Z]of X){let A=j.encode(Q);$+=30+A.length+Z.length,$+=46+A.length}let U=new Uint8Array($),Y=new DataView(U.buffer),J=0;for(let[Q,Z]of X){let A=j.encode(Q),q=n(Z),O=J;Y.setUint32(J,67324752,!0),J+=4,Y.setUint16(J,20,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint32(J,q,!0),J+=4,Y.setUint32(J,Z.length,!0),J+=4,Y.setUint32(J,Z.length,!0),J+=4,Y.setUint16(J,A.length,!0),J+=2,Y.setUint16(J,0,!0),J+=2,U.set(A,J),J+=A.length,U.set(Z,J),J+=Z.length,V.push({name:A,data:Z,crc:q,offset:O})}let G=J;for(let Q of V)Y.setUint32(J,33639248,!0),J+=4,Y.setUint16(J,20,!0),J+=2,Y.setUint16(J,20,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint32(J,Q.crc,!0),J+=4,Y.setUint32(J,Q.data.length,!0),J+=4,Y.setUint32(J,Q.data.length,!0),J+=4,Y.setUint16(J,Q.name.length,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint32(J,0,!0),J+=4,Y.setUint32(J,Q.offset,!0),J+=4,U.set(Q.name,J),J+=Q.name.length;let K=J-G;return Y.setUint32(J,101010256,!0),J+=4,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,V.length,!0),J+=2,Y.setUint16(J,V.length,!0),J+=2,Y.setUint32(J,K,!0),J+=4,Y.setUint32(J,G,!0),J+=4,Y.setUint16(J,0,!0),U}var E="termweb-cache";async function F(X){if(!L)throw new Error("OPFS not available");let j=await N(L,E),V=X.replace(/^\/+/,"");if(V){for(let $ of V.split("/"))if($)j=await N(j,$)}return j}async function k(X){let j=await F(X);return N(j,"files")}async function b(X){try{let U=await(await(await(await F(X)).getFileHandle(".termweb-meta")).getFile()).text();return JSON.parse(U)}catch{return{}}}async function v(X,j){let U=await(await(await F(X)).getFileHandle(".termweb-meta",{create:!0})).createSyncAccessHandle();try{let Y=new TextEncoder().encode(JSON.stringify(j));U.truncate(0),U.write(Y,{at:0}),U.flush()}finally{U.close()}}async function l(X,j,V,$){let U=await k(X),Y=j.split("/"),J=U;for(let Z=0;Z<Y.length-1;Z++)J=await N(J,Y[Z]);let K=await(await J.getFileHandle(Y[Y.length-1],{create:!0})).createSyncAccessHandle();try{K.truncate(0),K.write(new Uint8Array(V),{at:0}),K.flush()}finally{K.close()}let Q=await b(X);Q[j]=$,await v(X,Q)}async function _(X,j){let V=await k(X),$=j.split("/"),U=V;for(let G=0;G<$.length-1;G++)U=await U.getDirectoryHandle($[G]);return(await(await U.getFileHandle($[$.length-1])).getFile()).arrayBuffer()}async function f(X,j){let V=await b(X);delete V[j],await v(X,V);try{let $=await k(X),U=j.split("/"),Y=$;for(let J=0;J<U.length-1;J++)Y=await Y.getDirectoryHandle(U[J]);await Y.removeEntry(U[U.length-1])}catch{}}async function d(){if(!L)return;try{await L.removeEntry(E,{recursive:!0})}catch{}}async function o(X){if(!L)return;try{let j=await L.getDirectoryHandle(E),V=X.replace(/^\/+/,"");if(V){let $=V.split("/").filter((Y)=>Y);if($.length===0)return;let U=j;for(let Y=0;Y<$.length-1;Y++)U=await U.getDirectoryHandle($[Y]);await U.removeEntry($[$.length-1],{recursive:!0})}}catch{}}async function i(){if(!L)return{totalBytes:0,fileCount:0};let X=0,j=0;async function V($){for await(let[,U]of $)if(U.kind==="file"){let Y=await U.getFile();X+=Y.size,j++}else await V(U)}try{let $=await L.getDirectoryHandle(E);await V($)}catch{}return{totalBytes:X,fileCount:j}}function r(X){let j=0,V=0;for(let $=0;$<X.length;$++)j=j+X[$]&65535,V=V+j&65535;return(V<<16|j)>>>0}function s(X){let j=0xcbf29ce484222325n,V=0x100000001b3n;for(let $=0;$<X.length;$++)j^=BigInt(X[$]),j=j*V&0xFFFFFFFFFFFFFFFFn;return j}async function t(X,j,V){let $=new Uint8Array(await _(X,j)),U=Math.ceil($.length/V),Y=new Uint32Array(U),J=new BigUint64Array(U);for(let G=0;G<U;G++){let K=G*V,Q=Math.min(K+V,$.length),Z=$.subarray(K,Q);Y[G]=r(Z),J[G]=s(Z)}return{rolling:Y,strong:J}}function a(X,j){let V=new DataView(j.buffer,j.byteOffset,j.byteLength),$=[],U=0,Y=0;while(Y<j.length){let K=j[Y];if(Y+=1,K===0){let Q=Number(V.getBigUint64(Y,!0));Y+=8;let Z=V.getUint32(Y,!0);Y+=4;let A=X.slice(Q,Q+Z);$.push(A),U+=A.length}else if(K===1){let Q=V.getUint32(Y,!0);Y+=4;let Z=j.slice(Y,Y+Q);$.push(Z),U+=Q,Y+=Q}else break}let J=new Uint8Array(U),G=0;for(let K of $)J.set(K,G),G+=K.length;return J}async function e(X){if(!L)return;try{let U=await(await(await(await L.getDirectoryHandle("transfers",{create:!0})).getDirectoryHandle(`${X.transferId}`,{create:!0})).getFileHandle("metadata.json",{create:!0})).createWritable();await U.write(JSON.stringify(X)),await U.close(),console.log(`[Worker] Saved metadata for transfer ${X.transferId}`)}catch(j){console.error("[Worker] Failed to save transfer metadata:",j)}}async function g(X){if(!L)return null;try{let Y=await(await(await(await(await L.getDirectoryHandle("transfers",{create:!1})).getDirectoryHandle(`${X}`,{create:!1})).getFileHandle("metadata.json",{create:!1})).getFile()).text();return JSON.parse(Y)}catch{return null}}async function jj(){if(!L)return;try{await L.removeEntry("transfers",{recursive:!0})}catch{}}async function y(X){if(!L)return;try{await(await L.getDirectoryHandle("transfers",{create:!1})).removeEntry(`${X}`,{recursive:!0}),console.log(`[Worker] Deleted metadata for transfer ${X}`)}catch(j){console.error("[Worker] Failed to delete transfer metadata:",j)}}async function Jj(){if(!L)return[];try{let X=await L.getDirectoryHandle("transfers",{create:!1}),j=[];for await(let V of X.values())if(V.kind==="directory"){let $=parseInt(V.name),U=await g($);if(U)j.push(U)}return j}catch{return[]}}self.onmessage=async(X)=>{let j=X.data;try{switch(j.type){case"init":{await P(),self.postMessage({type:"init-done"});break}case"set-opfs-root":{if(j.opfsRoot)h(j.opfsRoot).catch((V)=>{console.error("[Worker] OPFS activation failed:",V)});break}case"decompress":{let $=I(new Uint8Array(j.data)).buffer;self.postMessage({type:"decompressed",id:j.id,data:$},[$]);break}case"compress":{let $=m(new Uint8Array(j.data),j.level||3).buffer;self.postMessage({type:"compressed",id:j.id,data:$},[$]);break}case"decompress-and-write":{let{transferId:V,fileIndex:$,filePath:U,compressedData:Y,fileSize:J}=j,G=`${V}/${U}`,Q=(T.get(G)||Promise.resolve()).then(async()=>{try{if(R.has(V))return;if(D.has(G))return;let Z=I(new Uint8Array(Y));if(!B.has(V))B.set(V,new Map);let A=B.get(V),q=A.get(U);if(q){let M=new Uint8Array(q.length+Z.length);M.set(q),M.set(Z,q.length),A.set(U,M)}else A.set(U,Z);let z=A.get(U).length>=J;if(z)D.add(G),T.delete(G);self.postMessage({type:"chunk-written",transferId:V,fileIndex:$,filePath:U,bytesWritten:Z.length,complete:z})}catch(Z){console.error(`[Worker] ERROR decompress-and-write: idx=${$}, path=${U}`,Z),self.postMessage({type:"chunk-error",transferId:V,fileIndex:$,filePath:U,error:Z instanceof Error?Z.message:String(Z)})}});T.set(G,Q);break}case"get-file":{let{transferId:V,filePath:$}=j,Y=B.get(V)?.get($);if(Y){let J=Y.buffer.slice(Y.byteOffset,Y.byteOffset+Y.byteLength);self.postMessage({type:"file-data",transferId:V,filePath:$,data:J},[J])}else console.error(`[Worker] get-file: not found: ${$}`);break}case"cleanup":{if(B.delete(j.transferId),H)await c(j.transferId);self.postMessage({type:"cleanup-done",transferId:j.transferId});break}case"write-temp-file":{if(!B.has(j.transferId))B.set(j.transferId,new Map);B.get(j.transferId).set(j.path,new Uint8Array(j.data));break}case"create-zip-from-temp":{let V=B.get(j.transferId);if(!V||V.size===0){console.error(`[Worker] create-zip-from-temp: No files for transfer ${j.transferId}`);break}console.log(`[Worker] Creating zip from ${V.size} in-memory files`);let $=p(V),Y=`${j.folderName||"download"}.zip`;console.log(`[Worker] Zip created: ${$.length} bytes, filename: ${Y}`);let J=$.buffer;self.postMessage({type:"zip-created",transferId:j.transferId,zipData:J,filename:Y},[J]);break}case"cleanup-temp":{B.delete(j.transferId);break}case"cache-put":{if(x(j))break;let{id:V,serverPath:$,filePath:U,data:Y,metadata:J}=j;await l($,U,Y,J),self.postMessage({type:"cache-put-done",id:V,serverPath:$,filePath:U});break}case"cache-get":{if(x(j))break;let{id:V,serverPath:$,filePath:U}=j,Y=await _($,U);self.postMessage({type:"cache-file",id:V,serverPath:$,filePath:U,data:Y},[Y]);break}case"cache-list":{if(x(j))break;let{id:V,serverPath:$}=j,U=await b($);self.postMessage({type:"cache-list-result",id:V,serverPath:$,files:U});break}case"cache-remove":{if(x(j))break;let{id:V,serverPath:$,filePath:U}=j;await f($,U),self.postMessage({type:"cache-remove-done",id:V,serverPath:$,filePath:U});break}case"cache-clear-all":{if(x(j))break;let{id:V}=j;await d(),self.postMessage({type:"cache-cleared",id:V});break}case"cache-clear-path":{if(x(j))break;let{serverPath:V}=j;await o(V),self.postMessage({type:"cache-path-cleared",serverPath:V});break}case"cache-usage":{if(x(j))break;let{id:V}=j,$=await i();self.postMessage({type:"cache-usage-result",id:V,...$});break}case"compute-checksums":{if(x(j))break;let{id:V,serverPath:$,filePath:U,blockSize:Y}=j;try{let{rolling:J,strong:G}=await t($,U,Y),K=J.buffer,Q=G.buffer;self.postMessage({type:"checksums-computed",id:V,rolling:K,strong:Q},[K,Q])}catch(J){let G=J instanceof Error?J.message:"Checksum computation failed";self.postMessage({type:"checksums-error",id:V,message:G})}break}case"apply-delta":{if(x(j))break;let{id:V,serverPath:$,filePath:U,deltaPayload:Y}=j;try{let J=new Uint8Array(await _($,U)),K=a(J,new Uint8Array(Y)).buffer;self.postMessage({type:"delta-applied",id:V,data:K},[K])}catch(J){let G=J instanceof Error?J.message:"Delta application failed";self.postMessage({type:"delta-error",id:V,message:G})}break}case"save-transfer-metadata":{if(x(j))break;await e(j.metadata),self.postMessage({type:"metadata-saved",transferId:j.metadata.transferId});break}case"load-transfer-metadata":{if(x(j))break;let V=await g(j.transferId);self.postMessage({type:"metadata-loaded",transferId:j.transferId,metadata:V});break}case"delete-transfer-metadata":{if(x(j))break;R.add(j.transferId),await y(j.transferId),setTimeout(()=>y(j.transferId),2000),self.postMessage({type:"metadata-deleted",transferId:j.transferId});break}case"get-interrupted-transfers":{if(x(j))break;let V=await Jj();self.postMessage({type:"interrupted-transfers",transfers:V});break}}}catch(V){let $=V instanceof Error?V.message:"Unknown error";self.postMessage({type:"error",message:$,originalType:j.type,...j})}};
