var U=null,X=null,G=new Map,E=16777216;async function _(){let J=await(await fetch("/zstd.wasm")).arrayBuffer(),q=null,j={args_sizes_get:(Q,Y)=>{let $=new DataView(q.buffer);return $.setUint32(Q,0,!0),$.setUint32(Y,0,!0),0},args_get:()=>0,environ_sizes_get:(Q,Y)=>{let $=new DataView(q.buffer);return $.setUint32(Q,0,!0),$.setUint32(Y,0,!0),0},environ_get:()=>0,clock_time_get:()=>0,fd_close:()=>0,fd_fdstat_get:()=>0,fd_prestat_get:()=>8,fd_prestat_dir_name:()=>8,fd_read:()=>0,fd_seek:()=>0,fd_write:()=>0,proc_exit:()=>{},random_get:()=>0},{instance:K}=await WebAssembly.instantiate(J,{wasi_snapshot_preview1:j});q=K.exports.memory,U=K.exports;try{X=await navigator.storage.getDirectory()}catch{}}function O(V){if(!U)throw new Error("WASM not initialized");let J=V.length,q=U.zstd_alloc(J);if(q===0)throw new Error("zstd alloc failed");new Uint8Array(U.memory.buffer,q,J).set(V);let j=U.zstd_frame_content_size(q,J);if(j===0||j>E)j=Math.min(J*8,E);let K=U.zstd_alloc(j);if(K===0)throw U.zstd_free(q,J),new Error("zstd alloc failed");try{let Q=U.zstd_decompress(K,j,q,J);if(Q===0)throw new Error("zstd decompression failed");return new Uint8Array(U.memory.buffer.slice(K,K+Q))}finally{U.zstd_free(q,J),U.zstd_free(K,j)}}function H(V,J){if(!U)throw new Error("WASM not initialized");let q=V.length,j=U.zstd_compress_bound(q),K=U.zstd_alloc(q),Q=U.zstd_alloc(j);if(K===0||Q===0){if(K)U.zstd_free(K,q);if(Q)U.zstd_free(Q,j);throw new Error("zstd alloc failed")}try{new Uint8Array(U.memory.buffer,K,q).set(V);let Y=U.zstd_compress(Q,j,K,q,J);if(Y===0)throw new Error("zstd compression failed");return new Uint8Array(U.memory.buffer.slice(Q,Q+Y))}finally{U.zstd_free(K,q),U.zstd_free(Q,j)}}async function x(V,J){return V.getDirectoryHandle(J,{create:!0})}async function R(V,J){let q=`${V}/${J}`,j=G.get(q);if(j)return j;if(!X)throw new Error("OPFS not available");let K=await x(X,"termweb-transfers");K=await x(K,String(V));let Q=J.split("/");for(let W=0;W<Q.length-1;W++)K=await x(K,Q[W]);let Y=Q[Q.length-1],N=await(await K.getFileHandle(Y,{create:!0})).createSyncAccessHandle();return G.set(q,N),N}function k(V,J){let q=`${V}/${J}`,j=G.get(q);if(j){try{j.flush()}catch{}try{j.close()}catch{}G.delete(q)}}async function y(V,J){if(!X)throw new Error("OPFS not available");let q=await X.getDirectoryHandle("termweb-transfers");q=await q.getDirectoryHandle(String(V));let j=J.split("/");for(let Y=0;Y<j.length-1;Y++)q=await q.getDirectoryHandle(j[Y]);return(await(await q.getFileHandle(j[j.length-1])).getFile()).arrayBuffer()}async function b(V){if(!X)return;for(let[J,q]of G)if(J.startsWith(`${V}/`)){try{q.flush()}catch{}try{q.close()}catch{}G.delete(J)}try{await(await X.getDirectoryHandle("termweb-transfers")).removeEntry(String(V),{recursive:!0})}catch{}}var T="termweb-cache";async function A(V){if(!X)throw new Error("OPFS not available");let J=await x(X,T),q=V.replace(/^\/+/,"");if(q){for(let j of q.split("/"))if(j)J=await x(J,j)}return J}async function B(V){let J=await A(V);return x(J,"files")}async function F(V){try{let K=await(await(await(await A(V)).getFileHandle(".termweb-meta")).getFile()).text();return JSON.parse(K)}catch{return{}}}async function I(V,J){let K=await(await(await A(V)).getFileHandle(".termweb-meta",{create:!0})).createSyncAccessHandle();try{let Q=new TextEncoder().encode(JSON.stringify(J));K.truncate(0),K.write(Q,{at:0}),K.flush()}finally{K.close()}}async function w(V,J,q,j){let K=await B(V),Q=J.split("/"),Y=K;for(let Z=0;Z<Q.length-1;Z++)Y=await x(Y,Q[Z]);let N=await(await Y.getFileHandle(Q[Q.length-1],{create:!0})).createSyncAccessHandle();try{N.truncate(0),N.write(new Uint8Array(q),{at:0}),N.flush()}finally{N.close()}let W=await F(V);W[J]=j,await I(V,W)}async function L(V,J){let q=await B(V),j=J.split("/"),K=q;for(let $=0;$<j.length-1;$++)K=await K.getDirectoryHandle(j[$]);return(await(await K.getFileHandle(j[j.length-1])).getFile()).arrayBuffer()}async function z(V,J){let q=await F(V);delete q[J],await I(V,q);try{let j=await B(V),K=J.split("/"),Q=j;for(let Y=0;Y<K.length-1;Y++)Q=await Q.getDirectoryHandle(K[Y]);await Q.removeEntry(K[K.length-1])}catch{}}async function D(){if(!X)return;try{await X.removeEntry(T,{recursive:!0})}catch{}}async function S(){if(!X)return{totalBytes:0,fileCount:0};let V=0,J=0;async function q(j){for await(let[,K]of j)if(K.kind==="file"){let Q=await K.getFile();V+=Q.size,J++}else await q(K)}try{let j=await X.getDirectoryHandle(T);await q(j)}catch{}return{totalBytes:V,fileCount:J}}function C(V){let J=0,q=0;for(let j=0;j<V.length;j++)J=J+V[j]&65535,q=q+J&65535;return(q<<16|J)>>>0}function u(V){let J=0xcbf29ce484222325n,q=0x100000001b3n;for(let j=0;j<V.length;j++)J^=BigInt(V[j]),J=J*q&0xFFFFFFFFFFFFFFFFn;return J}async function v(V,J,q){let j=new Uint8Array(await L(V,J)),K=Math.ceil(j.length/q),Q=new Uint32Array(K),Y=new BigUint64Array(K);for(let $=0;$<K;$++){let N=$*q,W=Math.min(N+q,j.length),Z=j.subarray(N,W);Q[$]=C(Z),Y[$]=u(Z)}return{rolling:Q,strong:Y}}function g(V,J){let q=new DataView(J.buffer,J.byteOffset,J.byteLength),j=[],K=0,Q=0;while(Q<J.length){let N=J[Q];if(Q+=1,N===0){let W=Number(q.getBigUint64(Q,!0));Q+=8;let Z=q.getUint32(Q,!0);Q+=4;let M=V.slice(W,W+Z);j.push(M),K+=M.length}else if(N===1){let W=q.getUint32(Q,!0);Q+=4;let Z=J.slice(Q,Q+W);j.push(Z),K+=W,Q+=W}else break}let Y=new Uint8Array(K),$=0;for(let N of j)Y.set(N,$),$+=N.length;return Y}self.onmessage=async(V)=>{let J=V.data;try{switch(J.type){case"init":{await _(),self.postMessage({type:"init-done",opfsAvailable:X!==null});break}case"decompress":{let j=O(new Uint8Array(J.data)).buffer;self.postMessage({type:"decompressed",id:J.id,data:j},[j]);break}case"compress":{let j=H(new Uint8Array(J.data),J.level||3).buffer;self.postMessage({type:"compressed",id:J.id,data:j},[j]);break}case"decompress-and-write":{let{transferId:q,filePath:j,offset:K,compressedData:Q,fileSize:Y}=J,$=O(new Uint8Array(Q));if(X){let N=await R(q,j);N.write($,{at:K});let Z=N.getSize()>=Y;if(Z)k(q,j);self.postMessage({type:"chunk-written",transferId:q,filePath:j,bytesWritten:$.length,complete:Z})}else{let N=$.buffer;self.postMessage({type:"chunk-decompressed",transferId:q,filePath:j,offset:K,data:N,bytesWritten:$.length},[N])}break}case"get-file":{let{transferId:q,filePath:j}=J,K=await y(q,j);self.postMessage({type:"file-data",transferId:q,filePath:j,data:K},[K]);break}case"cleanup":{await b(J.transferId),self.postMessage({type:"cleanup-done",transferId:J.transferId});break}case"cache-put":{let{id:q,serverPath:j,filePath:K,data:Q,metadata:Y}=J;await w(j,K,Q,Y),self.postMessage({type:"cache-put-done",id:q,serverPath:j,filePath:K});break}case"cache-get":{let{id:q,serverPath:j,filePath:K}=J,Q=await L(j,K);self.postMessage({type:"cache-file",id:q,serverPath:j,filePath:K,data:Q},[Q]);break}case"cache-list":{let{id:q,serverPath:j}=J,K=await F(j);self.postMessage({type:"cache-list-result",id:q,serverPath:j,files:K});break}case"cache-remove":{let{id:q,serverPath:j,filePath:K}=J;await z(j,K),self.postMessage({type:"cache-remove-done",id:q,serverPath:j,filePath:K});break}case"cache-clear-all":{let{id:q}=J;await D(),self.postMessage({type:"cache-cleared",id:q});break}case"cache-usage":{let{id:q}=J,j=await S();self.postMessage({type:"cache-usage-result",id:q,...j});break}case"compute-checksums":{let{id:q,serverPath:j,filePath:K,blockSize:Q}=J;try{let{rolling:Y,strong:$}=await v(j,K,Q),N=Y.buffer,W=$.buffer;self.postMessage({type:"checksums-computed",id:q,rolling:N,strong:W},[N,W])}catch(Y){let $=Y instanceof Error?Y.message:"Checksum computation failed";self.postMessage({type:"checksums-error",id:q,message:$})}break}case"apply-delta":{let{id:q,serverPath:j,filePath:K,deltaPayload:Q}=J;try{let Y=new Uint8Array(await L(j,K)),N=g(Y,new Uint8Array(Q)).buffer;self.postMessage({type:"delta-applied",id:q,data:N},[N])}catch(Y){let $=Y instanceof Error?Y.message:"Delta application failed";self.postMessage({type:"delta-error",id:q,message:$})}break}}}catch(q){let j=q instanceof Error?q.message:"Unknown error";self.postMessage({type:"error",message:j,originalType:J.type,...J})}};
