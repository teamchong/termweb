var N=null,X=null,x=new Map,E=16777216;async function R(){let J=await(await fetch("/zstd.wasm")).arrayBuffer(),q=null,j={args_sizes_get:(Q,V)=>{let Y=new DataView(q.buffer);return Y.setUint32(Q,0,!0),Y.setUint32(V,0,!0),0},args_get:()=>0,environ_sizes_get:(Q,V)=>{let Y=new DataView(q.buffer);return Y.setUint32(Q,0,!0),Y.setUint32(V,0,!0),0},environ_get:()=>0,clock_time_get:()=>0,fd_close:()=>0,fd_fdstat_get:()=>0,fd_prestat_get:()=>8,fd_prestat_dir_name:()=>8,fd_read:()=>0,fd_seek:()=>0,fd_write:()=>0,proc_exit:()=>{},random_get:()=>0},{instance:K}=await WebAssembly.instantiate(J,{wasi_snapshot_preview1:j});q=K.exports.memory,N=K.exports;try{X=await navigator.storage.getDirectory()}catch{}}function M(U){if(!N)throw new Error("WASM not initialized");let J=U.length,q=N.zstd_alloc(J);if(q===0)throw new Error("zstd alloc failed");new Uint8Array(N.memory.buffer,q,J).set(U);let j=N.zstd_frame_content_size(q,J);if(j===0||j>E)j=Math.min(J*8,E);let K=N.zstd_alloc(j);if(K===0)throw N.zstd_free(q,J),new Error("zstd alloc failed");try{let Q=N.zstd_decompress(K,j,q,J);if(Q===0)throw new Error("zstd decompression failed");return new Uint8Array(N.memory.buffer.slice(K,K+Q))}finally{N.zstd_free(q,J),N.zstd_free(K,j)}}function _(U,J){if(!N)throw new Error("WASM not initialized");let q=U.length,j=N.zstd_compress_bound(q),K=N.zstd_alloc(q),Q=N.zstd_alloc(j);if(K===0||Q===0){if(K)N.zstd_free(K,q);if(Q)N.zstd_free(Q,j);throw new Error("zstd alloc failed")}try{new Uint8Array(N.memory.buffer,K,q).set(U);let V=N.zstd_compress(Q,j,K,q,J);if(V===0)throw new Error("zstd compression failed");return new Uint8Array(N.memory.buffer.slice(Q,Q+V))}finally{N.zstd_free(K,q),N.zstd_free(Q,j)}}async function Z(U,J){return U.getDirectoryHandle(J,{create:!0})}async function H(U,J){let q=`${U}/${J}`,j=x.get(q);if(j)return j;if(!X)throw new Error("OPFS not available");let K=await Z(X,"termweb-transfers");K=await Z(K,String(U));let Q=J.split("/");for(let W=0;W<Q.length-1;W++)K=await Z(K,Q[W]);let V=Q[Q.length-1],$=await(await K.getFileHandle(V,{create:!0})).createSyncAccessHandle();return x.set(q,$),$}function I(U,J){let q=`${U}/${J}`,j=x.get(q);if(j){try{j.flush()}catch{}try{j.close()}catch{}x.delete(q)}}async function k(U,J){if(!X)throw new Error("OPFS not available");let q=await X.getDirectoryHandle("termweb-transfers");q=await q.getDirectoryHandle(String(U));let j=J.split("/");for(let V=0;V<j.length-1;V++)q=await q.getDirectoryHandle(j[V]);return(await(await q.getFileHandle(j[j.length-1])).getFile()).arrayBuffer()}async function y(U){if(!X)return;for(let[J,q]of x)if(J.startsWith(`${U}/`)){try{q.flush()}catch{}try{q.close()}catch{}x.delete(J)}try{await(await X.getDirectoryHandle("termweb-transfers")).removeEntry(String(U),{recursive:!0})}catch{}}var b="termweb-cache";async function G(U){if(!X)throw new Error("OPFS not available");let J=await Z(X,b),q=U.replace(/^\/+/,"");if(q){for(let j of q.split("/"))if(j)J=await Z(J,j)}return J}async function L(U){let J=await G(U);return Z(J,"files")}async function B(U){try{let K=await(await(await(await G(U)).getFileHandle(".termweb-meta")).getFile()).text();return JSON.parse(K)}catch{return{}}}async function O(U,J){let K=await(await(await G(U)).getFileHandle(".termweb-meta",{create:!0})).createSyncAccessHandle();try{let Q=new TextEncoder().encode(JSON.stringify(J));K.truncate(0),K.write(Q,{at:0}),K.flush()}finally{K.close()}}async function D(U,J,q,j){let K=await L(U),Q=J.split("/"),V=K;for(let T=0;T<Q.length-1;T++)V=await Z(V,Q[T]);let $=await(await V.getFileHandle(Q[Q.length-1],{create:!0})).createSyncAccessHandle();try{$.truncate(0),$.write(new Uint8Array(q),{at:0}),$.flush()}finally{$.close()}let W=await B(U);W[J]=j,await O(U,W)}async function A(U,J){let q=await L(U),j=J.split("/"),K=q;for(let Y=0;Y<j.length-1;Y++)K=await K.getDirectoryHandle(j[Y]);return(await(await K.getFileHandle(j[j.length-1])).getFile()).arrayBuffer()}async function w(U,J){let q=await B(U);delete q[J],await O(U,q);try{let j=await L(U),K=J.split("/"),Q=j;for(let V=0;V<K.length-1;V++)Q=await Q.getDirectoryHandle(K[V]);await Q.removeEntry(K[K.length-1])}catch{}}function C(U){let J=0,q=0;for(let j=0;j<U.length;j++)J=J+U[j]&65535,q=q+J&65535;return(q<<16|J)>>>0}function z(U){let J=0xcbf29ce484222325n,q=0x100000001b3n;for(let j=0;j<U.length;j++)J^=BigInt(U[j]),J=J*q&0xFFFFFFFFFFFFFFFFn;return J}async function S(U,J,q){let j=new Uint8Array(await A(U,J)),K=Math.ceil(j.length/q),Q=new Uint32Array(K),V=new BigUint64Array(K);for(let Y=0;Y<K;Y++){let $=Y*q,W=Math.min($+q,j.length),T=j.subarray($,W);Q[Y]=C(T),V[Y]=z(T)}return{rolling:Q,strong:V}}function u(U,J){let q=new DataView(J.buffer,J.byteOffset,J.byteLength),j=[],K=0,Q=0;while(Q<J.length){let $=J[Q];if(Q+=1,$===0){let W=Number(q.getBigUint64(Q,!0));Q+=8;let T=q.getUint32(Q,!0);Q+=4;let F=U.slice(W,W+T);j.push(F),K+=F.length}else if($===1){let W=q.getUint32(Q,!0);Q+=4;let T=J.slice(Q,Q+W);j.push(T),K+=W,Q+=W}else break}let V=new Uint8Array(K),Y=0;for(let $ of j)V.set($,Y),Y+=$.length;return V}self.onmessage=async(U)=>{let J=U.data;try{switch(J.type){case"init":{await R(),self.postMessage({type:"init-done",opfsAvailable:X!==null});break}case"decompress":{let j=M(new Uint8Array(J.data)).buffer;self.postMessage({type:"decompressed",id:J.id,data:j},[j]);break}case"compress":{let j=_(new Uint8Array(J.data),J.level||3).buffer;self.postMessage({type:"compressed",id:J.id,data:j},[j]);break}case"decompress-and-write":{let{transferId:q,filePath:j,offset:K,compressedData:Q,fileSize:V}=J,Y=M(new Uint8Array(Q));if(X){let $=await H(q,j);$.write(Y,{at:K});let T=$.getSize()>=V;if(T)I(q,j);self.postMessage({type:"chunk-written",transferId:q,filePath:j,bytesWritten:Y.length,complete:T})}else{let $=Y.buffer;self.postMessage({type:"chunk-decompressed",transferId:q,filePath:j,offset:K,data:$,bytesWritten:Y.length},[$])}break}case"get-file":{let{transferId:q,filePath:j}=J,K=await k(q,j);self.postMessage({type:"file-data",transferId:q,filePath:j,data:K},[K]);break}case"cleanup":{await y(J.transferId),self.postMessage({type:"cleanup-done",transferId:J.transferId});break}case"cache-put":{let{id:q,serverPath:j,filePath:K,data:Q,metadata:V}=J;await D(j,K,Q,V),self.postMessage({type:"cache-put-done",id:q,serverPath:j,filePath:K});break}case"cache-get":{let{id:q,serverPath:j,filePath:K}=J,Q=await A(j,K);self.postMessage({type:"cache-file",id:q,serverPath:j,filePath:K,data:Q},[Q]);break}case"cache-list":{let{id:q,serverPath:j}=J,K=await B(j);self.postMessage({type:"cache-list-result",id:q,serverPath:j,files:K});break}case"cache-remove":{let{id:q,serverPath:j,filePath:K}=J;await w(j,K),self.postMessage({type:"cache-remove-done",id:q,serverPath:j,filePath:K});break}case"compute-checksums":{let{id:q,serverPath:j,filePath:K,blockSize:Q}=J;try{let{rolling:V,strong:Y}=await S(j,K,Q),$=V.buffer,W=Y.buffer;self.postMessage({type:"checksums-computed",id:q,rolling:$,strong:W},[$,W])}catch(V){let Y=V instanceof Error?V.message:"Checksum computation failed";self.postMessage({type:"checksums-error",id:q,message:Y})}break}case"apply-delta":{let{id:q,serverPath:j,filePath:K,deltaPayload:Q}=J;try{let V=new Uint8Array(await A(j,K)),$=u(V,new Uint8Array(Q)).buffer;self.postMessage({type:"delta-applied",id:q,data:$},[$])}catch(V){let Y=V instanceof Error?V.message:"Delta application failed";self.postMessage({type:"delta-error",id:q,message:Y})}break}}}catch(q){let j=q instanceof Error?q.message:"Unknown error";self.postMessage({type:"error",message:j,originalType:J.type,...J})}};
