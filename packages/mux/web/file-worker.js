var L=null,W=null,F=new Map,M=new Map,S=134217728;async function I(){let j=await(await fetch("/zstd.wasm")).arrayBuffer(),q=null,V={args_sizes_get:(Y,J)=>{let X=new DataView(q.buffer);return X.setUint32(Y,0,!0),X.setUint32(J,0,!0),0},args_get:()=>0,environ_sizes_get:(Y,J)=>{let X=new DataView(q.buffer);return X.setUint32(Y,0,!0),X.setUint32(J,0,!0),0},environ_get:()=>0,clock_time_get:()=>0,fd_close:()=>0,fd_fdstat_get:()=>0,fd_prestat_get:()=>8,fd_prestat_dir_name:()=>8,fd_read:()=>0,fd_seek:()=>0,fd_write:()=>0,proc_exit:()=>{},random_get:()=>0},{instance:$}=await WebAssembly.instantiate(j,{wasi_snapshot_preview1:V});q=$.exports.memory,L=$.exports;try{W=await navigator.storage.getDirectory()}catch{}}function R(U){if(!L)throw new Error("WASM not initialized");let j=U.length,q=L.zstd_alloc(j);if(q===0)throw new Error("zstd alloc failed");new Uint8Array(L.memory.buffer,q,j).set(U);let V=L.zstd_frame_content_size(q,j);if(V===0||V>S)V=Math.min(j*8,S);let $=L.zstd_alloc(V);if($===0)throw L.zstd_free(q,j),new Error("zstd alloc failed");try{let Y=L.zstd_decompress($,V,q,j);if(Y===0)throw new Error("zstd decompression failed");return new Uint8Array(L.memory.buffer.slice($,$+Y))}finally{L.zstd_free(q,j),L.zstd_free($,V)}}function u(U,j){if(!L)throw new Error("WASM not initialized");let q=U.length,V=L.zstd_compress_bound(q),$=L.zstd_alloc(q),Y=L.zstd_alloc(V);if($===0||Y===0){if($)L.zstd_free($,q);if(Y)L.zstd_free(Y,V);throw new Error("zstd alloc failed")}try{new Uint8Array(L.memory.buffer,$,q).set(U);let J=L.zstd_compress(Y,V,$,q,j);if(J===0)throw new Error("zstd compression failed");return new Uint8Array(L.memory.buffer.slice(Y,Y+J))}finally{L.zstd_free($,q),L.zstd_free(Y,V)}}async function A(U,j){return U.getDirectoryHandle(j,{create:!0})}async function g(U,j){let q=`${U}/${j}`,V=F.get(q);if(V)return V;if(!W)throw new Error("OPFS not available");let $=await A(W,"termweb-transfers");$=await A($,String(U));let Y=j.split("/");for(let G=0;G<Y.length-1;G++)$=await A($,Y[G]);let J=Y[Y.length-1],K=await(await $.getFileHandle(J,{create:!0})).createSyncAccessHandle();return F.set(q,K),K}function w(U,j){let q=`${U}/${j}`,V=F.get(q);if(V){try{V.flush()}catch{}try{V.close()}catch{}F.delete(q)}}async function v(U,j){if(!W)throw new Error("OPFS not available");let q=await W.getDirectoryHandle("termweb-transfers");q=await q.getDirectoryHandle(String(U));let V=j.split("/");for(let J=0;J<V.length-1;J++)q=await q.getDirectoryHandle(V[J]);return(await(await q.getFileHandle(V[V.length-1])).getFile()).arrayBuffer()}async function P(U){if(!W)return;for(let[j,q]of F)if(j.startsWith(`${U}/`)){try{q.flush()}catch{}try{q.close()}catch{}F.delete(j)}try{await(await W.getDirectoryHandle("termweb-transfers")).removeEntry(String(U),{recursive:!0})}catch{}}var O="termweb-temp";async function h(U,j,q){if(!W)return;let V;for(let $=0;$<3;$++)try{let J=await(await W.getDirectoryHandle(O,{create:!0})).getDirectoryHandle(String(U),{create:!0}),X=j.split("/").filter((N)=>N),K=J;for(let N=0;N<X.length-1;N++)K=await K.getDirectoryHandle(X[N],{create:!0});let G=X[X.length-1],Z=await K.getFileHandle(G,{create:!0}),Q=null;try{Q=await Z.createSyncAccessHandle(),Q.truncate(0),Q.write(new Uint8Array(q),{at:0}),Q.flush();return}finally{if(Q)try{Q.close()}catch(N){console.warn("Failed to close access handle:",N)}}}catch(Y){V=Y;let J=Y instanceof Error?Y.message:String(Y);if(J.includes("Access Handle")||J.includes("access handle")){console.warn(`Write temp file attempt ${$+1}/3 failed for ${j}, retrying...`,J),await new Promise((X)=>setTimeout(X,10*Math.pow(5,$)));continue}console.error("Failed to write temp file:",j,Y);return}console.error("Failed to write temp file after 3 attempts:",j,V)}async function m(U,j){if(!W)throw new Error("OPFS not available");console.log(`[Worker] createZipFromTemp: Getting temp dir for transfer ${U}`);let V=await(await W.getDirectoryHandle(O)).getDirectoryHandle(String(U)),$=new Map;async function Y(K,G){for await(let[Z,Q]of K){let N=G?`${G}/${Z}`:Z;if(Q.kind==="file"){let x=await Q.getFile(),z=new Uint8Array(await x.arrayBuffer());$.set(N,z)}else if(Q.kind==="directory")await Y(Q,N)}}await Y(V,""),console.log(`[Worker] Collected ${$.size} files from OPFS temp`);let J=p($);console.log(`[Worker] Created zip: ${J.length} bytes`);let X=j?`${j}.zip`:`${Array.from($.keys())[0]?.split("/")[0]||"download"}.zip`;return console.log(`[Worker] Zip filename: ${X}`),{zipData:J.buffer,filename:X}}async function c(U){if(!W)return;try{await(await W.getDirectoryHandle(O)).removeEntry(String(U),{recursive:!0})}catch{}}var y=new Uint32Array(256);for(let U=0;U<256;U++){let j=U;for(let q=0;q<8;q++)j=j&1?3988292384^j>>>1:j>>>1;y[U]=j}function n(U){let j=-1;for(let q=0;q<U.length;q++)j=y[(j^U[q])&255]^j>>>8;return~j>>>0}function p(U){let j=new TextEncoder,q=[],V=22;for(let[G,Z]of U){let Q=j.encode(G);V+=30+Q.length+Z.length,V+=46+Q.length}let $=new Uint8Array(V),Y=new DataView($.buffer),J=0;for(let[G,Z]of U){let Q=j.encode(G),N=n(Z),B=J;Y.setUint32(J,67324752,!0),J+=4,Y.setUint16(J,20,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint32(J,N,!0),J+=4,Y.setUint32(J,Z.length,!0),J+=4,Y.setUint32(J,Z.length,!0),J+=4,Y.setUint16(J,Q.length,!0),J+=2,Y.setUint16(J,0,!0),J+=2,$.set(Q,J),J+=Q.length,$.set(Z,J),J+=Z.length,q.push({name:Q,data:Z,crc:N,offset:B})}let X=J;for(let G of q)Y.setUint32(J,33639248,!0),J+=4,Y.setUint16(J,20,!0),J+=2,Y.setUint16(J,20,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint32(J,G.crc,!0),J+=4,Y.setUint32(J,G.data.length,!0),J+=4,Y.setUint32(J,G.data.length,!0),J+=4,Y.setUint16(J,G.name.length,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint32(J,0,!0),J+=4,Y.setUint32(J,G.offset,!0),J+=4,$.set(G.name,J),J+=G.name.length;let K=J-X;return Y.setUint32(J,101010256,!0),J+=4,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,0,!0),J+=2,Y.setUint16(J,q.length,!0),J+=2,Y.setUint16(J,q.length,!0),J+=2,Y.setUint32(J,K,!0),J+=4,Y.setUint32(J,X,!0),J+=4,Y.setUint16(J,0,!0),$}var E="termweb-cache";async function _(U){if(!W)throw new Error("OPFS not available");let j=await A(W,E),q=U.replace(/^\/+/,"");if(q){for(let V of q.split("/"))if(V)j=await A(j,V)}return j}async function k(U){let j=await _(U);return A(j,"files")}async function H(U){try{let $=await(await(await(await _(U)).getFileHandle(".termweb-meta")).getFile()).text();return JSON.parse($)}catch{return{}}}async function D(U,j){let $=await(await(await _(U)).getFileHandle(".termweb-meta",{create:!0})).createSyncAccessHandle();try{let Y=new TextEncoder().encode(JSON.stringify(j));$.truncate(0),$.write(Y,{at:0}),$.flush()}finally{$.close()}}async function l(U,j,q,V){let $=await k(U),Y=j.split("/"),J=$;for(let Z=0;Z<Y.length-1;Z++)J=await A(J,Y[Z]);let K=await(await J.getFileHandle(Y[Y.length-1],{create:!0})).createSyncAccessHandle();try{K.truncate(0),K.write(new Uint8Array(q),{at:0}),K.flush()}finally{K.close()}let G=await H(U);G[j]=V,await D(U,G)}async function T(U,j){let q=await k(U),V=j.split("/"),$=q;for(let X=0;X<V.length-1;X++)$=await $.getDirectoryHandle(V[X]);return(await(await $.getFileHandle(V[V.length-1])).getFile()).arrayBuffer()}async function f(U,j){let q=await H(U);delete q[j],await D(U,q);try{let V=await k(U),$=j.split("/"),Y=V;for(let J=0;J<$.length-1;J++)Y=await Y.getDirectoryHandle($[J]);await Y.removeEntry($[$.length-1])}catch{}}async function d(){if(!W)return;try{await W.removeEntry(E,{recursive:!0})}catch{}}async function o(U){if(!W)return;try{let j=await W.getDirectoryHandle(E),q=U.replace(/^\/+/,"");if(q){let V=q.split("/").filter((Y)=>Y);if(V.length===0)return;let $=j;for(let Y=0;Y<V.length-1;Y++)$=await $.getDirectoryHandle(V[Y]);await $.removeEntry(V[V.length-1],{recursive:!0})}}catch{}}async function i(){if(!W)return{totalBytes:0,fileCount:0};let U=0,j=0;async function q(V){for await(let[,$]of V)if($.kind==="file"){let Y=await $.getFile();U+=Y.size,j++}else await q($)}try{let V=await W.getDirectoryHandle(E);await q(V)}catch{}return{totalBytes:U,fileCount:j}}function r(U){let j=0,q=0;for(let V=0;V<U.length;V++)j=j+U[V]&65535,q=q+j&65535;return(q<<16|j)>>>0}function s(U){let j=0xcbf29ce484222325n,q=0x100000001b3n;for(let V=0;V<U.length;V++)j^=BigInt(U[V]),j=j*q&0xFFFFFFFFFFFFFFFFn;return j}async function t(U,j,q){let V=new Uint8Array(await T(U,j)),$=Math.ceil(V.length/q),Y=new Uint32Array($),J=new BigUint64Array($);for(let X=0;X<$;X++){let K=X*q,G=Math.min(K+q,V.length),Z=V.subarray(K,G);Y[X]=r(Z),J[X]=s(Z)}return{rolling:Y,strong:J}}function a(U,j){let q=new DataView(j.buffer,j.byteOffset,j.byteLength),V=[],$=0,Y=0;while(Y<j.length){let K=j[Y];if(Y+=1,K===0){let G=Number(q.getBigUint64(Y,!0));Y+=8;let Z=q.getUint32(Y,!0);Y+=4;let Q=U.slice(G,G+Z);V.push(Q),$+=Q.length}else if(K===1){let G=q.getUint32(Y,!0);Y+=4;let Z=j.slice(Y,Y+G);V.push(Z),$+=G,Y+=G}else break}let J=new Uint8Array($),X=0;for(let K of V)J.set(K,X),X+=K.length;return J}async function C(U){if(!W)return;try{let $=await(await(await(await W.getDirectoryHandle("transfers",{create:!0})).getDirectoryHandle(`${U.transferId}`,{create:!0})).getFileHandle("metadata.json",{create:!0})).createWritable();await $.write(JSON.stringify(U)),await $.close(),console.log(`[Worker] Saved metadata for transfer ${U.transferId}`)}catch(j){console.error("[Worker] Failed to save transfer metadata:",j)}}async function b(U){if(!W)return null;try{let Y=await(await(await(await(await W.getDirectoryHandle("transfers",{create:!1})).getDirectoryHandle(`${U}`,{create:!1})).getFileHandle("metadata.json",{create:!1})).getFile()).text();return JSON.parse(Y)}catch{return null}}async function e(U,j,q){let V=await b(U);if(!V)return;if(!V.completedFiles.includes(j))V.completedFiles.push(j);V.bytesTransferred+=q,V.lastUpdateTime=Date.now(),await C(V)}async function jj(U){if(!W)return;try{await(await W.getDirectoryHandle("transfers",{create:!1})).removeEntry(`${U}`,{recursive:!0}),console.log(`[Worker] Deleted metadata for transfer ${U}`)}catch(j){console.error("[Worker] Failed to delete transfer metadata:",j)}}async function qj(){if(!W)return[];try{let U=await W.getDirectoryHandle("transfers",{create:!1}),j=[];for await(let q of U.values())if(q.kind==="directory"){let V=parseInt(q.name),$=await b(V);if($)j.push($)}return j}catch{return[]}}self.onmessage=async(U)=>{let j=U.data;try{switch(j.type){case"init":{await I(),self.postMessage({type:"init-done",opfsAvailable:W!==null});break}case"decompress":{let V=R(new Uint8Array(j.data)).buffer;self.postMessage({type:"decompressed",id:j.id,data:V},[V]);break}case"compress":{let V=u(new Uint8Array(j.data),j.level||3).buffer;self.postMessage({type:"compressed",id:j.id,data:V},[V]);break}case"decompress-and-write":{let{transferId:q,fileIndex:V,filePath:$,offset:Y,compressedData:J,fileSize:X}=j;console.log(`[Worker] decompress-and-write: idx=${V}, path=${$}, offset=${Y}, size=${X}`);let K=`${q}/${$}`,Z=(M.get(K)||Promise.resolve()).then(async()=>{try{let Q=R(new Uint8Array(J));if(console.log(`[Worker] decompressed: idx=${V}, decompressed=${Q.length} bytes`),W){let N=await g(q,$);console.log(`[Worker] got handle: idx=${V}, current size=${N.getSize()}`),N.write(Q,{at:Y}),console.log(`[Worker] wrote chunk: idx=${V}, at offset=${Y}`);let B=N.getSize(),x=B>=X;if(console.log(`[Worker] after write: idx=${V}, size=${B}/${X}, complete=${x}`),x)w(q,$),M.delete(K),console.log(`[Worker] closed handle: idx=${V}`),await e(q,$,Q.length);self.postMessage({type:"chunk-written",transferId:q,fileIndex:V,filePath:$,bytesWritten:Q.length,complete:x}),console.log(`[Worker] sent chunk-written: idx=${V}`)}else{let N=Q.buffer;self.postMessage({type:"chunk-decompressed",transferId:q,fileIndex:V,filePath:$,offset:Y,data:N,bytesWritten:Q.length},[N])}}catch(Q){console.error(`[Worker] ERROR decompress-and-write: idx=${V}, path=${$}`,Q),self.postMessage({type:"chunk-error",transferId:q,fileIndex:V,filePath:$,error:Q instanceof Error?Q.message:String(Q)})}});M.set(K,Z);break}case"get-file":{let{transferId:q,filePath:V}=j,$=await v(q,V);self.postMessage({type:"file-data",transferId:q,filePath:V,data:$},[$]);break}case"cleanup":{await P(j.transferId),self.postMessage({type:"cleanup-done",transferId:j.transferId});break}case"write-temp-file":{await h(j.transferId,j.path,j.data);break}case"create-zip-from-temp":{console.log(`[Worker] create-zip-from-temp: transferId=${j.transferId}, folderName=${j.folderName}`);let{zipData:q,filename:V}=await m(j.transferId,j.folderName);console.log(`[Worker] Zip created: size=${q.byteLength} bytes, filename=${V}`),self.postMessage({type:"zip-created",transferId:j.transferId,zipData:q,filename:V},[q]),console.log("[Worker] Sent zip-created message to main thread");break}case"cleanup-temp":{console.log(`[Worker] cleanup-temp: transferId=${j.transferId}`),await c(j.transferId),console.log("[Worker] Temp files cleaned up");break}case"cache-put":{let{id:q,serverPath:V,filePath:$,data:Y,metadata:J}=j;await l(V,$,Y,J),self.postMessage({type:"cache-put-done",id:q,serverPath:V,filePath:$});break}case"cache-get":{let{id:q,serverPath:V,filePath:$}=j,Y=await T(V,$);self.postMessage({type:"cache-file",id:q,serverPath:V,filePath:$,data:Y},[Y]);break}case"cache-list":{let{id:q,serverPath:V}=j,$=await H(V);self.postMessage({type:"cache-list-result",id:q,serverPath:V,files:$});break}case"cache-remove":{let{id:q,serverPath:V,filePath:$}=j;await f(V,$),self.postMessage({type:"cache-remove-done",id:q,serverPath:V,filePath:$});break}case"cache-clear-all":{let{id:q}=j;await d(),self.postMessage({type:"cache-cleared",id:q});break}case"cache-clear-path":{let{serverPath:q}=j;await o(q),self.postMessage({type:"cache-path-cleared",serverPath:q});break}case"cache-usage":{let{id:q}=j,V=await i();self.postMessage({type:"cache-usage-result",id:q,...V});break}case"compute-checksums":{let{id:q,serverPath:V,filePath:$,blockSize:Y}=j;try{let{rolling:J,strong:X}=await t(V,$,Y),K=J.buffer,G=X.buffer;self.postMessage({type:"checksums-computed",id:q,rolling:K,strong:G},[K,G])}catch(J){let X=J instanceof Error?J.message:"Checksum computation failed";self.postMessage({type:"checksums-error",id:q,message:X})}break}case"apply-delta":{let{id:q,serverPath:V,filePath:$,deltaPayload:Y}=j;try{let J=new Uint8Array(await T(V,$)),K=a(J,new Uint8Array(Y)).buffer;self.postMessage({type:"delta-applied",id:q,data:K},[K])}catch(J){let X=J instanceof Error?J.message:"Delta application failed";self.postMessage({type:"delta-error",id:q,message:X})}break}case"save-transfer-metadata":{await C(j.metadata),self.postMessage({type:"metadata-saved",transferId:j.metadata.transferId});break}case"load-transfer-metadata":{let q=await b(j.transferId);self.postMessage({type:"metadata-loaded",transferId:j.transferId,metadata:q});break}case"delete-transfer-metadata":{await jj(j.transferId),self.postMessage({type:"metadata-deleted",transferId:j.transferId});break}case"get-interrupted-transfers":{let q=await qj();self.postMessage({type:"interrupted-transfers",transfers:q});break}}}catch(q){let V=q instanceof Error?q.message:"Unknown error";self.postMessage({type:"error",message:V,originalType:j.type,...j})}};
