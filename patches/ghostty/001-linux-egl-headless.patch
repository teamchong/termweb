From 0dad46bae288cda76a0be80a7d99b76315182232 Mon Sep 17 00:00:00 2001
From: teamchong <steven@keplogic.com>
Date: Wed, 4 Feb 2026 09:55:17 -0500
Subject: [PATCH 1/2] feat(linux): add headless EGL rendering support for
 embedded platform

---
 include/ghostty.h          |  13 ++
 src/apprt/egl_headless.zig | 340 +++++++++++++++++++++++++++++++++++++
 src/apprt/embedded.zig     |  54 ++++++
 src/renderer/OpenGL.zig    |  49 ++++--
 4 files changed, 446 insertions(+), 10 deletions(-)
 create mode 100644 src/apprt/egl_headless.zig

diff --git a/include/ghostty.h b/include/ghostty.h
index 3d3973084..e04c2fabe 100644
--- a/include/ghostty.h
+++ b/include/ghostty.h
@@ -38,6 +38,7 @@ typedef enum {
   GHOSTTY_PLATFORM_INVALID,
   GHOSTTY_PLATFORM_MACOS,
   GHOSTTY_PLATFORM_IOS,
+  GHOSTTY_PLATFORM_LINUX,
 } ghostty_platform_e;
 
 typedef enum {
@@ -426,9 +427,16 @@ typedef struct {
   void* uiview;
 } ghostty_platform_ios_s;
 
+typedef struct {
+  int shm_fd;
+  void* shm_ptr;
+  size_t shm_size;
+} ghostty_platform_linux_s;
+
 typedef union {
   ghostty_platform_macos_s macos;
   ghostty_platform_ios_s ios;
+  ghostty_platform_linux_s linux_shm;
 } ghostty_platform_u;
 
 typedef enum {
@@ -1146,6 +1154,11 @@ void ghostty_inspector_metal_render(ghostty_inspector_t, void*, void*);
 bool ghostty_inspector_metal_shutdown(ghostty_inspector_t);
 #endif
 
+#ifdef __linux__
+// Read pixels from the OpenGL framebuffer (for video encoding)
+bool ghostty_surface_read_pixels(ghostty_surface_t, uint8_t*, size_t);
+#endif
+
 // APIs I'd like to get rid of eventually but are still needed for now.
 // Don't use these unless you know what you're doing.
 void ghostty_set_window_background_blur(ghostty_app_t, void*);
diff --git a/src/apprt/egl_headless.zig b/src/apprt/egl_headless.zig
new file mode 100644
index 000000000..7900d57b0
--- /dev/null
+++ b/src/apprt/egl_headless.zig
@@ -0,0 +1,340 @@
+const std = @import("std");
+const builtin = @import("builtin");
+const posix = std.posix;
+const gl = @import("opengl");
+
+// GBM types and functions
+const gbm = struct {
+    const Device = ?*anyopaque;
+    const CreateDeviceFn = *const fn (c_int) callconv(.c) Device;
+    const DestroyDeviceFn = *const fn (Device) callconv(.c) void;
+
+    var lib: ?std.DynLib = null;
+    var gbm_create_device: ?CreateDeviceFn = null;
+    var gbm_device_destroy: ?DestroyDeviceFn = null;
+
+    fn load() void {
+        if (lib != null) return;
+        lib = std.DynLib.open("libgbm.so.1") catch std.DynLib.open("libgbm.so") catch return;
+        gbm_create_device = lib.?.lookup(CreateDeviceFn, "gbm_create_device");
+        gbm_device_destroy = lib.?.lookup(DestroyDeviceFn, "gbm_device_destroy");
+    }
+
+    fn createDevice(fd: c_int) Device {
+        load();
+        if (gbm_create_device) |func| return func(fd);
+        return null;
+    }
+};
+
+const c = struct {
+    pub const EGL_DEFAULT_DISPLAY: ?*anyopaque = null;
+    pub const EGL_NO_DISPLAY: ?*anyopaque = null;
+    pub const EGL_NO_CONTEXT: ?*anyopaque = null;
+    pub const EGL_NO_SURFACE: ?*anyopaque = null;
+    pub const EGL_FALSE: c_int = 0;
+    pub const EGL_TRUE: c_int = 1;
+    pub const EGL_SURFACE_TYPE: c_int = 0x3033;
+    pub const EGL_PBUFFER_BIT: c_int = 0x0001;
+    pub const EGL_RENDERABLE_TYPE: c_int = 0x3040;
+    pub const EGL_OPENGL_BIT: c_int = 0x0008;
+    pub const EGL_OPENGL_ES2_BIT: c_int = 0x0004;
+    pub const EGL_OPENGL_ES3_BIT: c_int = 0x0040;
+    pub const EGL_RED_SIZE: c_int = 0x3024;
+    pub const EGL_GREEN_SIZE: c_int = 0x3025;
+    pub const EGL_BLUE_SIZE: c_int = 0x3026;
+    pub const EGL_ALPHA_SIZE: c_int = 0x3027;
+    pub const EGL_NONE: c_int = 0x3038;
+    pub const EGL_WIDTH: c_int = 0x3057;
+    pub const EGL_HEIGHT: c_int = 0x3058;
+    pub const EGL_CONTEXT_MAJOR_VERSION: c_int = 0x3098;
+    pub const EGL_CONTEXT_MINOR_VERSION: c_int = 0x30FB;
+    pub const EGL_CONTEXT_OPENGL_PROFILE_MASK: c_int = 0x30FD;
+    pub const EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT: c_int = 0x00000001;
+    pub const EGL_OPENGL_API: c_int = 0x30A2;
+    pub const EGL_OPENGL_ES_API: c_int = 0x30A0;
+    pub const EGL_PLATFORM_DEVICE_EXT: c_int = 0x313F;
+    pub const EGL_PLATFORM_SURFACELESS_MESA: c_int = 0x31DD;
+    pub const EGL_PLATFORM_GBM_MESA: c_int = 0x31D7;
+
+    pub const EGLDisplay = ?*anyopaque;
+    pub const EGLConfig = ?*anyopaque;
+    pub const EGLContext = ?*anyopaque;
+    pub const EGLSurface = ?*anyopaque;
+    pub const EGLint = c_int;
+
+    var lib: ?std.DynLib = null;
+
+    pub var eglGetDisplay: *const fn (?*anyopaque) callconv(.c) EGLDisplay = undefined;
+    pub var eglInitialize: *const fn (EGLDisplay, ?*EGLint, ?*EGLint) callconv(.c) c_int = undefined;
+    pub var eglChooseConfig: *const fn (EGLDisplay, [*]const EGLint, ?*EGLConfig, EGLint, *EGLint) callconv(.c) c_int = undefined;
+    pub var eglBindAPI: *const fn (c_int) callconv(.c) c_int = undefined;
+    pub var eglCreatePbufferSurface: *const fn (EGLDisplay, EGLConfig, [*]const EGLint) callconv(.c) EGLSurface = undefined;
+    pub var eglCreateContext: *const fn (EGLDisplay, EGLConfig, EGLContext, [*]const EGLint) callconv(.c) EGLContext = undefined;
+    pub var eglMakeCurrent: *const fn (EGLDisplay, EGLSurface, EGLSurface, EGLContext) callconv(.c) c_int = undefined;
+    pub var eglDestroyContext: *const fn (EGLDisplay, EGLContext) callconv(.c) c_int = undefined;
+    pub var eglDestroySurface: *const fn (EGLDisplay, EGLSurface) callconv(.c) c_int = undefined;
+    pub var eglTerminate: *const fn (EGLDisplay) callconv(.c) c_int = undefined;
+    pub var eglSwapBuffers: *const fn (EGLDisplay, EGLSurface) callconv(.c) c_int = undefined;
+    pub var eglGetError: *const fn () callconv(.c) EGLint = undefined;
+    pub var eglGetProcAddress: *const fn ([*:0]const u8) callconv(.c) ?*const fn () callconv(.c) void = undefined;
+    pub var eglQueryDevicesEXT: ?*const fn (c_int, [*]?*anyopaque, *c_int) callconv(.c) c_int = null;
+    pub var eglGetPlatformDisplayEXT: ?*const fn (c_int, ?*anyopaque, [*]const c_int) callconv(.c) EGLDisplay = null;
+
+    pub fn loadEgl() !void {
+        if (lib != null) return;
+        lib = std.DynLib.open("libEGL.so.1") catch
+            std.DynLib.open("libEGL.so") catch
+            return error.EglLibraryNotFound;
+        eglGetDisplay = lib.?.lookup(@TypeOf(eglGetDisplay), "eglGetDisplay") orelse return error.EglSymbolNotFound;
+        eglInitialize = lib.?.lookup(@TypeOf(eglInitialize), "eglInitialize") orelse return error.EglSymbolNotFound;
+        eglChooseConfig = lib.?.lookup(@TypeOf(eglChooseConfig), "eglChooseConfig") orelse return error.EglSymbolNotFound;
+        eglBindAPI = lib.?.lookup(@TypeOf(eglBindAPI), "eglBindAPI") orelse return error.EglSymbolNotFound;
+        eglCreatePbufferSurface = lib.?.lookup(@TypeOf(eglCreatePbufferSurface), "eglCreatePbufferSurface") orelse return error.EglSymbolNotFound;
+        eglCreateContext = lib.?.lookup(@TypeOf(eglCreateContext), "eglCreateContext") orelse return error.EglSymbolNotFound;
+        eglMakeCurrent = lib.?.lookup(@TypeOf(eglMakeCurrent), "eglMakeCurrent") orelse return error.EglSymbolNotFound;
+        eglDestroyContext = lib.?.lookup(@TypeOf(eglDestroyContext), "eglDestroyContext") orelse return error.EglSymbolNotFound;
+        eglDestroySurface = lib.?.lookup(@TypeOf(eglDestroySurface), "eglDestroySurface") orelse return error.EglSymbolNotFound;
+        eglTerminate = lib.?.lookup(@TypeOf(eglTerminate), "eglTerminate") orelse return error.EglSymbolNotFound;
+        eglSwapBuffers = lib.?.lookup(@TypeOf(eglSwapBuffers), "eglSwapBuffers") orelse return error.EglSymbolNotFound;
+        eglGetError = lib.?.lookup(@TypeOf(eglGetError), "eglGetError") orelse return error.EglSymbolNotFound;
+        eglGetProcAddress = lib.?.lookup(@TypeOf(eglGetProcAddress), "eglGetProcAddress") orelse return error.EglSymbolNotFound;
+        if (eglGetProcAddress("eglQueryDevicesEXT")) |ptr| {
+            eglQueryDevicesEXT = @ptrCast(ptr);
+        }
+        if (eglGetProcAddress("eglGetPlatformDisplayEXT")) |ptr| {
+            eglGetPlatformDisplayEXT = @ptrCast(ptr);
+        }
+    }
+};
+
+const log = std.log.scoped(.egl_headless);
+
+pub const EglHeadless = struct {
+    display: c.EGLDisplay,
+    context: c.EGLContext,
+    surface: c.EGLSurface,
+    use_gles: bool,
+
+    var drm_fd: ?posix.fd_t = null;
+    var gbm_device: gbm.Device = null;
+
+    pub fn init() !EglHeadless {
+        try c.loadEgl();
+
+        var try_gbm = false;
+        if (c.eglGetPlatformDisplayEXT != null) {
+            if (drm_fd == null) {
+                drm_fd = posix.open("/dev/dri/renderD128", .{ .ACCMODE = .RDWR }, 0) catch null;
+                if (drm_fd != null) {
+                    gbm_device = gbm.createDevice(@intCast(drm_fd.?));
+                    if (gbm_device == null) {
+                        posix.close(drm_fd.?);
+                        drm_fd = null;
+                    } else {
+                        try_gbm = true;
+                    }
+                }
+            } else if (gbm_device != null) {
+                try_gbm = true;
+            }
+        }
+
+        const platforms = [_]struct { name: []const u8, platform: ?c_int, native: ?*anyopaque }{
+            .{ .name = "gbm", .platform = c.EGL_PLATFORM_GBM_MESA, .native = gbm_device },
+            .{ .name = "surfaceless", .platform = c.EGL_PLATFORM_SURFACELESS_MESA, .native = c.EGL_DEFAULT_DISPLAY },
+            .{ .name = "default", .platform = null, .native = c.EGL_DEFAULT_DISPLAY },
+        };
+
+        for (platforms) |plat| {
+            if (std.mem.eql(u8, plat.name, "gbm") and !try_gbm) continue;
+
+            var display: c.EGLDisplay = c.EGL_NO_DISPLAY;
+
+            if (plat.platform) |platform| {
+                if (c.eglGetPlatformDisplayEXT) |getPlatformDisplay| {
+                    const attribs = [_]c.EGLint{c.EGL_NONE};
+                    display = getPlatformDisplay(platform, plat.native, &attribs);
+                } else {
+                    continue;
+                }
+            } else {
+                display = c.eglGetDisplay(plat.native);
+            }
+
+            const is_surfaceless = std.mem.eql(u8, plat.name, "surfaceless");
+
+            if (display == c.EGL_NO_DISPLAY) continue;
+
+            var major: c.EGLint = 0;
+            var minor: c.EGLint = 0;
+            if (c.eglInitialize(display, &major, &minor) == c.EGL_FALSE) continue;
+
+            const api_configs = [_]struct { api: c_int, renderable: c_int, maj: c_int, min: c_int, name: []const u8, use_profile: bool }{
+                .{ .api = c.EGL_OPENGL_API, .renderable = c.EGL_OPENGL_BIT, .maj = 4, .min = 3, .name = "OpenGL 4.3", .use_profile = true },
+                .{ .api = c.EGL_OPENGL_API, .renderable = c.EGL_OPENGL_BIT, .maj = 3, .min = 3, .name = "OpenGL 3.3", .use_profile = true },
+                .{ .api = c.EGL_OPENGL_ES_API, .renderable = c.EGL_OPENGL_ES3_BIT, .maj = 3, .min = 2, .name = "OpenGL ES 3.2", .use_profile = false },
+                .{ .api = c.EGL_OPENGL_ES_API, .renderable = c.EGL_OPENGL_ES3_BIT, .maj = 3, .min = 1, .name = "OpenGL ES 3.1", .use_profile = false },
+                .{ .api = c.EGL_OPENGL_ES_API, .renderable = c.EGL_OPENGL_ES3_BIT, .maj = 3, .min = 0, .name = "OpenGL ES 3.0", .use_profile = false },
+            };
+
+            for (api_configs) |api_cfg| {
+                if (c.eglBindAPI(api_cfg.api) == c.EGL_FALSE) continue;
+
+                const config_variants = [_]struct { name: []const u8, attribs: []const c.EGLint }{
+                    .{ .name = "pbuffer", .attribs = &[_]c.EGLint{ c.EGL_SURFACE_TYPE, c.EGL_PBUFFER_BIT, c.EGL_RENDERABLE_TYPE, api_cfg.renderable, c.EGL_RED_SIZE, 8, c.EGL_GREEN_SIZE, 8, c.EGL_BLUE_SIZE, 8, c.EGL_ALPHA_SIZE, 8, c.EGL_NONE } },
+                    .{ .name = "surfaceless", .attribs = &[_]c.EGLint{ c.EGL_SURFACE_TYPE, 0, c.EGL_RENDERABLE_TYPE, api_cfg.renderable, c.EGL_RED_SIZE, 8, c.EGL_GREEN_SIZE, 8, c.EGL_BLUE_SIZE, 8, c.EGL_ALPHA_SIZE, 8, c.EGL_NONE } },
+                    .{ .name = "minimal", .attribs = &[_]c.EGLint{ c.EGL_RENDERABLE_TYPE, api_cfg.renderable, c.EGL_NONE } },
+                };
+
+                for (config_variants) |cfg_var| {
+                    var config: c.EGLConfig = null;
+                    var num_configs: c.EGLint = 0;
+                    const result = c.eglChooseConfig(display, cfg_var.attribs.ptr, &config, 1, &num_configs);
+                    if (result == c.EGL_FALSE or num_configs == 0) continue;
+
+                    var surface: c.EGLSurface = c.EGL_NO_SURFACE;
+                    if (!is_surfaceless) {
+                        const pbuffer_attribs = [_]c.EGLint{ c.EGL_WIDTH, 1, c.EGL_HEIGHT, 1, c.EGL_NONE };
+                        surface = c.eglCreatePbufferSurface(display, config, &pbuffer_attribs);
+                    }
+
+                    var context_attribs: [7]c.EGLint = undefined;
+                    if (api_cfg.use_profile) {
+                        context_attribs = [_]c.EGLint{ c.EGL_CONTEXT_MAJOR_VERSION, api_cfg.maj, c.EGL_CONTEXT_MINOR_VERSION, api_cfg.min, c.EGL_CONTEXT_OPENGL_PROFILE_MASK, c.EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT, c.EGL_NONE };
+                    } else {
+                        context_attribs = [_]c.EGLint{ c.EGL_CONTEXT_MAJOR_VERSION, api_cfg.maj, c.EGL_CONTEXT_MINOR_VERSION, api_cfg.min, c.EGL_NONE, 0, 0 };
+                    }
+
+                    const context = c.eglCreateContext(display, config, c.EGL_NO_CONTEXT, &context_attribs);
+                    if (context == c.EGL_NO_CONTEXT) {
+                        if (surface != c.EGL_NO_SURFACE) _ = c.eglDestroySurface(display, surface);
+                        continue;
+                    }
+
+                    std.debug.print("EGL context created: {s} via {s} platform\n", .{ api_cfg.name, plat.name });
+                    return .{ .display = display, .context = context, .surface = surface, .use_gles = api_cfg.api == c.EGL_OPENGL_ES_API };
+                }
+            }
+
+            _ = c.eglTerminate(display);
+        }
+
+        log.err("failed to create any valid EGL context", .{});
+        return error.EglContextFailed;
+    }
+
+    pub fn deinit(self: *EglHeadless) void {
+        _ = c.eglMakeCurrent(self.display, c.EGL_NO_SURFACE, c.EGL_NO_SURFACE, c.EGL_NO_CONTEXT);
+        _ = c.eglDestroyContext(self.display, self.context);
+        _ = c.eglDestroySurface(self.display, self.surface);
+        _ = c.eglTerminate(self.display);
+    }
+
+    pub fn makeCurrent(self: *EglHeadless) bool {
+        return c.eglMakeCurrent(self.display, self.surface, self.surface, self.context) == c.EGL_TRUE;
+    }
+
+    pub fn getProcAddress() *const fn ([*:0]const u8) callconv(.c) ?*const fn () callconv(.c) void {
+        return c.eglGetProcAddress;
+    }
+};
+
+var global_egl_context: ?EglHeadless = null;
+var gl_initialized: bool = false;
+var last_rendered_fbo: c_uint = 0;
+
+pub fn setLastRenderedFbo(fbo_id: c_uint) void {
+    last_rendered_fbo = fbo_id;
+}
+
+pub fn getLastRenderedFbo() c_uint {
+    return last_rendered_fbo;
+}
+
+pub fn initGlobalContext() !*EglHeadless {
+    if (global_egl_context) |*ctx| return ctx;
+    global_egl_context = try EglHeadless.init();
+    if (!global_egl_context.?.makeCurrent()) {
+        global_egl_context.?.deinit();
+        global_egl_context = null;
+        return error.EglMakeCurrentFailed;
+    }
+    return &global_egl_context.?;
+}
+
+pub fn isInitialized() bool {
+    return global_egl_context != null;
+}
+
+pub fn setGlInitialized() void {
+    gl_initialized = true;
+}
+
+pub fn isGlInitialized() bool {
+    return gl_initialized;
+}
+
+pub fn makeCurrentOnThread() bool {
+    if (global_egl_context) |*ctx| {
+        return ctx.makeCurrent();
+    }
+    return false;
+}
+
+pub fn releaseContext() void {
+    if (global_egl_context) |*ctx| {
+        _ = c.eglMakeCurrent(ctx.display, c.EGL_NO_SURFACE, c.EGL_NO_SURFACE, c.EGL_NO_CONTEXT);
+    }
+}
+
+/// Set the viewport size. This must be called when the surface size changes
+/// so that OpenGL.surfaceSize() returns the correct dimensions.
+pub fn setViewportSize(width: u32, height: u32) void {
+    std.debug.print("setViewportSize: {}x{}\n", .{ width, height });
+    if (!makeCurrentOnThread()) {
+        std.debug.print("setViewportSize: makeCurrent failed!\n", .{});
+        return;
+    }
+    if (gl.glad.context.Viewport) |viewport| {
+        viewport(0, 0, @intCast(width), @intCast(height));
+        std.debug.print("setViewportSize: viewport set to {}x{}\n", .{ width, height });
+    } else {
+        std.debug.print("setViewportSize: Viewport function is null!\n", .{});
+    }
+}
+
+pub fn readPixels(buffer: [*]u8, buffer_len: usize, width: u32, height: u32) bool {
+    if (!makeCurrentOnThread()) return false;
+
+    const readPixelsFn = gl.glad.context.ReadPixels orelse return false;
+
+    const expected_size = @as(usize, width) * @as(usize, height) * 4;
+    if (buffer_len < expected_size) return false;
+
+    if (gl.glad.context.Finish) |finish| {
+        finish();
+    }
+
+    const fbo_to_use = if (last_rendered_fbo > 0) last_rendered_fbo else 1;
+    if (gl.glad.context.BindFramebuffer) |bindFb| {
+        bindFb(gl.c.GL_READ_FRAMEBUFFER, fbo_to_use);
+    }
+
+    readPixelsFn(0, 0, @intCast(width), @intCast(height), gl.c.GL_RGBA, gl.c.GL_UNSIGNED_BYTE, buffer);
+
+    const row_size = width * 4;
+    var temp_row: [4096 * 4]u8 = undefined;
+    if (row_size <= temp_row.len) {
+        var y: u32 = 0;
+        while (y < height / 2) : (y += 1) {
+            const top_offset = y * row_size;
+            const bottom_offset = (height - 1 - y) * row_size;
+            @memcpy(temp_row[0..row_size], buffer[top_offset..][0..row_size]);
+            @memcpy(buffer[top_offset..][0..row_size], buffer[bottom_offset..][0..row_size]);
+            @memcpy(buffer[bottom_offset..][0..row_size], temp_row[0..row_size]);
+        }
+    }
+
+    return true;
+}
diff --git a/src/apprt/embedded.zig b/src/apprt/embedded.zig
index dcf8a6357..ac28b5b08 100644
--- a/src/apprt/embedded.zig
+++ b/src/apprt/embedded.zig
@@ -26,6 +26,10 @@ const log = std.log.scoped(.embedded_window);
 pub const resourcesDir = internal_os.resourcesDir;
 
 pub const App = struct {
+    /// For embedded Linux with OpenGL, drawing must be done from the app thread
+    /// because EGL contexts can only be current on one thread at a time.
+    pub const must_draw_from_app_thread = if (builtin.target.os.tag == .linux) true else false;
+
     /// Because we only expect the embedding API to be used in embedded
     /// environments, the options are extern so that we can expose it
     /// directly to a C callconv and not pay for any translation costs.
@@ -342,6 +346,7 @@ pub const App = struct {
 pub const Platform = union(PlatformTag) {
     macos: MacOS,
     ios: IOS,
+    linux: Linux,
 
     // If our build target for libghostty is not darwin then we do
     // not include macos support at all.
@@ -355,6 +360,12 @@ pub const Platform = union(PlatformTag) {
         uiview: objc.Object,
     } else void;
 
+    pub const Linux = if (builtin.target.os.tag == .linux) struct {
+        shm_fd: std.posix.fd_t,
+        shm_ptr: ?*anyopaque,
+        shm_size: usize,
+    } else void;
+
     // The C ABI compatible version of this union. The tag is expected
     // to be stored elsewhere.
     pub const C = extern union {
@@ -365,6 +376,12 @@ pub const Platform = union(PlatformTag) {
         ios: extern struct {
             uiview: ?*anyopaque,
         },
+
+        linux: extern struct {
+            shm_fd: c_int,
+            shm_ptr: ?*anyopaque,
+            shm_size: usize,
+        },
     };
 
     /// Initialize a Platform a tag and configuration from the C ABI.
@@ -384,6 +401,12 @@ pub const Platform = union(PlatformTag) {
                     break :ios error.UIViewMustBeSet);
                 break :ios .{ .ios = .{ .uiview = uiview } };
             } else error.UnsupportedPlatform,
+
+            .linux => if (Linux != void) .{ .linux = .{
+                .shm_fd = @intCast(c_platform.linux.shm_fd),
+                .shm_ptr = c_platform.linux.shm_ptr,
+                .shm_size = c_platform.linux.shm_size,
+            } } else error.UnsupportedPlatform,
         };
     }
 };
@@ -394,6 +417,7 @@ pub const PlatformTag = enum(c_int) {
 
     macos = 1,
     ios = 2,
+    linux = 3,
 };
 
 pub const EnvVar = extern struct {
@@ -792,6 +816,13 @@ pub const Surface = struct {
             .height = height,
         };
 
+        // For embedded Linux with headless EGL, set the OpenGL viewport
+        // so that surfaceSize() returns the correct dimensions.
+        if (comptime builtin.target.os.tag == .linux) {
+            const egl_headless = @import("egl_headless.zig");
+            egl_headless.setViewportSize(width, height);
+        }
+
         // Call the primary callback.
         self.core_surface.sizeCallback(self.size) catch |err| {
             log.err("error in size callback err={}", .{err});
@@ -2204,4 +2235,27 @@ pub const CAPI = struct {
             }
         }
     };
+
+    // Linux-only C APIs
+    const Linux = struct {
+        /// Read pixels from the OpenGL framebuffer for video encoding
+        export fn ghostty_surface_read_pixels(ptr: *Surface, buffer: [*]u8, buffer_len: usize) bool {
+            const surface = &ptr.core_surface;
+            const width = surface.size.screen.width;
+            const height = surface.size.screen.height;
+
+            if (width == 0 or height == 0) return false;
+
+            if (comptime builtin.target.os.tag == .linux) {
+                const egl_headless = @import("egl_headless.zig");
+                return egl_headless.readPixels(buffer, buffer_len, width, height);
+            }
+            return false;
+        }
+    };
+    comptime {
+        if (builtin.target.os.tag == .linux) {
+            _ = Linux;
+        }
+    }
 };
diff --git a/src/renderer/OpenGL.zig b/src/renderer/OpenGL.zig
index 4b01da0c5..502262293 100644
--- a/src/renderer/OpenGL.zig
+++ b/src/renderer/OpenGL.zig
@@ -170,9 +170,16 @@ pub fn surfaceInit(surface: *apprt.Surface) !void {
         => try prepareContext(null),
 
         apprt.embedded => {
-            // TODO(mitchellh): this does nothing today to allow libghostty
-            // to compile for OpenGL targets but libghostty is strictly
-            // broken for rendering on this platforms.
+            if (comptime builtin.target.os.tag == .linux) {
+                // Initialize headless EGL for Linux embedded rendering
+                const egl_headless = @import("../apprt/egl_headless.zig");
+                if (!egl_headless.isGlInitialized()) {
+                    _ = try egl_headless.initGlobalContext();
+                    try prepareContext(egl_headless.EglHeadless.getProcAddress());
+                    egl_headless.setGlInitialized();
+                    log.info("OpenGL initialized via headless EGL", .{});
+                }
+            }
         },
     }
 
@@ -191,6 +198,8 @@ pub fn surfaceInit(surface: *apprt.Surface) !void {
 pub fn finalizeSurfaceInit(self: *const OpenGL, surface: *apprt.Surface) !void {
     _ = self;
     _ = surface;
+    // For embedded Linux, we keep the EGL context on the main thread.
+    // Drawing is done from the app thread (must_draw_from_app_thread = true).
 }
 
 /// Callback called by renderer.Thread when it begins.
@@ -209,9 +218,9 @@ pub fn threadEnter(self: *const OpenGL, surface: *apprt.Surface) !void {
         },
 
         apprt.embedded => {
-            // TODO(mitchellh): this does nothing today to allow libghostty
-            // to compile for OpenGL targets but libghostty is strictly
-            // broken for rendering on this platforms.
+            // For embedded Linux with OpenGL, all drawing happens on the app
+            // thread (must_draw_from_app_thread = true), so the renderer thread
+            // doesn't need to set up an OpenGL context.
         },
     }
 }
@@ -229,7 +238,7 @@ pub fn threadExit(self: *const OpenGL) void {
         },
 
         apprt.embedded => {
-            // TODO: see threadEnter
+            // For embedded Linux, the EGL context is managed by the app thread.
         },
     }
 }
@@ -251,9 +260,20 @@ pub fn displayRealized(self: *const OpenGL) void {
 
 /// Actions taken before doing anything in `drawFrame`.
 ///
-/// Right now there's nothing we need to do for OpenGL.
+/// For embedded Linux with headless EGL, we need to ensure the EGL context
+/// is current on this thread before any GL calls (like surfaceSize()).
 pub fn drawFrameStart(self: *OpenGL) void {
     _ = self;
+    if (comptime builtin.target.os.tag == .linux) {
+        switch (apprt.runtime) {
+            apprt.embedded => {
+                const egl_headless = @import("../apprt/egl_headless.zig");
+                const result = egl_headless.makeCurrentOnThread();
+                std.debug.print("drawFrameStart: makeCurrent={}\n", .{result});
+            },
+            else => {},
+        }
+    }
 }
 
 /// Actions taken after `drawFrame` is done.
@@ -280,9 +300,12 @@ pub fn surfaceSize(self: *const OpenGL) !struct { width: u32, height: u32 } {
     _ = self;
     var viewport: [4]gl.c.GLint = undefined;
     gl.glad.context.GetIntegerv.?(gl.c.GL_VIEWPORT, &viewport);
+    const w: u32 = @intCast(viewport[2]);
+    const h: u32 = @intCast(viewport[3]);
+    std.debug.print("surfaceSize: viewport={}x{}\n", .{ w, h });
     return .{
-        .width = @intCast(viewport[2]),
-        .height = @intCast(viewport[3]),
+        .width = w,
+        .height = h,
     };
 }
 
@@ -312,6 +335,12 @@ pub fn present(self: *OpenGL, target: Target) !void {
     const fbobind = try target.framebuffer.bind(.read);
     defer fbobind.unbind();
 
+    // Store FBO ID for headless pixel capture (Linux only)
+    if (comptime builtin.target.os.tag == .linux) {
+        const egl_headless = @import("../apprt/egl_headless.zig");
+        egl_headless.setLastRenderedFbo(target.framebuffer.id);
+    }
+
     // Blit
     gl.glad.context.BlitFramebuffer.?(
         0,
-- 
2.43.0


From d65d8f7eb2ec08ec58554d77596d49a939ea68fd Mon Sep 17 00:00:00 2001
From: teamchong <steven@keplogic.com>
Date: Wed, 4 Feb 2026 09:57:34 -0500
Subject: [PATCH 2/2] feat(linux): add headless EGL rendering support for
 embedded platform

---
 src/apprt/embedded.zig | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/apprt/embedded.zig b/src/apprt/embedded.zig
index ac28b5b08..dd3231459 100644
--- a/src/apprt/embedded.zig
+++ b/src/apprt/embedded.zig
@@ -780,10 +780,13 @@ pub const Surface = struct {
     }
 
     pub fn draw(self: *Surface) void {
+        std.debug.print("Surface.draw() called\n", .{});
         self.core_surface.draw() catch |err| {
             log.err("error in draw err={}", .{err});
+            std.debug.print("Surface.draw() error: {}\n", .{err});
             return;
         };
+        std.debug.print("Surface.draw() completed\n", .{});
     }
 
     pub fn updateContentScale(self: *Surface, x: f64, y: f64) void {
@@ -1694,6 +1697,7 @@ pub const CAPI = struct {
     /// Tell the surface that it needs to schedule a render
     /// call as soon as possible (NOW if possible).
     export fn ghostty_surface_draw(surface: *Surface) void {
+        std.debug.print("ghostty_surface_draw() called\n", .{});
         surface.draw();
     }
 
-- 
2.43.0

