diff --git a/include/ghostty.h b/include/ghostty.h
index 3d3973084..1e073a122 100644
--- a/include/ghostty.h
+++ b/include/ghostty.h
@@ -38,6 +38,7 @@ typedef enum {
   GHOSTTY_PLATFORM_INVALID,
   GHOSTTY_PLATFORM_MACOS,
   GHOSTTY_PLATFORM_IOS,
+  GHOSTTY_PLATFORM_LINUX,
 } ghostty_platform_e;
 
 typedef enum {
@@ -426,9 +427,16 @@ typedef struct {
   void* uiview;
 } ghostty_platform_ios_s;
 
+typedef struct {
+  int shm_fd;
+  void* shm_ptr;
+  size_t shm_size;
+} ghostty_platform_linux_s;
+
 typedef union {
   ghostty_platform_macos_s macos;
   ghostty_platform_ios_s ios;
+  ghostty_platform_linux_s linux_shm;
 } ghostty_platform_u;
 
 typedef enum {
@@ -459,6 +467,10 @@ typedef struct {
   uint32_t height_px;
   uint32_t cell_width_px;
   uint32_t cell_height_px;
+  uint32_t padding_top_px;
+  uint32_t padding_bottom_px;
+  uint32_t padding_left_px;
+  uint32_t padding_right_px;
 } ghostty_surface_size_s;
 
 // Config types
@@ -1066,6 +1078,7 @@ void ghostty_surface_refresh(ghostty_surface_t);
 void ghostty_surface_draw(ghostty_surface_t);
 void ghostty_surface_set_content_scale(ghostty_surface_t, double, double);
 void ghostty_surface_set_focus(ghostty_surface_t, bool);
+void ghostty_surface_set_headless_focus(ghostty_surface_t, bool);
 void ghostty_surface_set_occlusion(ghostty_surface_t, bool);
 void ghostty_surface_set_size(ghostty_surface_t, uint32_t, uint32_t);
 ghostty_surface_size_s ghostty_surface_size(ghostty_surface_t);
@@ -1146,6 +1159,13 @@ void ghostty_inspector_metal_render(ghostty_inspector_t, void*, void*);
 bool ghostty_inspector_metal_shutdown(ghostty_inspector_t);
 #endif
 
+#ifdef __linux__
+// Read pixels from the OpenGL framebuffer (for video encoding)
+bool ghostty_surface_read_pixels(ghostty_surface_t, uint8_t*, size_t);
+// Get cursor position, style, visibility, and color for frontend rendering
+void ghostty_surface_cursor_info(ghostty_surface_t, uint16_t*, uint16_t*, uint8_t*, uint8_t*, uint8_t*, uint8_t*, uint8_t*);
+#endif
+
 // APIs I'd like to get rid of eventually but are still needed for now.
 // Don't use these unless you know what you're doing.
 void ghostty_set_window_background_blur(ghostty_app_t, void*);
diff --git a/src/apprt/egl_headless.zig b/src/apprt/egl_headless.zig
new file mode 100644
index 000000000..c68a974d3
--- /dev/null
+++ b/src/apprt/egl_headless.zig
@@ -0,0 +1,673 @@
+const std = @import("std");
+const builtin = @import("builtin");
+const posix = std.posix;
+const gl = @import("opengl");
+
+// GBM types and functions
+const gbm = struct {
+    const Device = ?*anyopaque;
+    const CreateDeviceFn = *const fn (c_int) callconv(.c) Device;
+    const DestroyDeviceFn = *const fn (Device) callconv(.c) void;
+
+    var lib: ?std.DynLib = null;
+    var gbm_create_device: ?CreateDeviceFn = null;
+    var gbm_device_destroy: ?DestroyDeviceFn = null;
+
+    fn load() void {
+        if (lib != null) return;
+        lib = std.DynLib.open("libgbm.so.1") catch std.DynLib.open("libgbm.so") catch return;
+        gbm_create_device = lib.?.lookup(CreateDeviceFn, "gbm_create_device");
+        gbm_device_destroy = lib.?.lookup(DestroyDeviceFn, "gbm_device_destroy");
+    }
+
+    fn createDevice(fd: c_int) Device {
+        load();
+        if (gbm_create_device) |func| return func(fd);
+        return null;
+    }
+};
+
+const c = struct {
+    pub const EGL_DEFAULT_DISPLAY: ?*anyopaque = null;
+    pub const EGL_NO_DISPLAY: ?*anyopaque = null;
+    pub const EGL_NO_CONTEXT: ?*anyopaque = null;
+    pub const EGL_NO_SURFACE: ?*anyopaque = null;
+    pub const EGL_FALSE: c_int = 0;
+    pub const EGL_TRUE: c_int = 1;
+    pub const EGL_SURFACE_TYPE: c_int = 0x3033;
+    pub const EGL_PBUFFER_BIT: c_int = 0x0001;
+    pub const EGL_RENDERABLE_TYPE: c_int = 0x3040;
+    pub const EGL_OPENGL_BIT: c_int = 0x0008;
+    pub const EGL_OPENGL_ES2_BIT: c_int = 0x0004;
+    pub const EGL_OPENGL_ES3_BIT: c_int = 0x0040;
+    pub const EGL_RED_SIZE: c_int = 0x3024;
+    pub const EGL_GREEN_SIZE: c_int = 0x3025;
+    pub const EGL_BLUE_SIZE: c_int = 0x3026;
+    pub const EGL_ALPHA_SIZE: c_int = 0x3027;
+    pub const EGL_NONE: c_int = 0x3038;
+    pub const EGL_WIDTH: c_int = 0x3057;
+    pub const EGL_HEIGHT: c_int = 0x3058;
+    pub const EGL_CONTEXT_MAJOR_VERSION: c_int = 0x3098;
+    pub const EGL_CONTEXT_MINOR_VERSION: c_int = 0x30FB;
+    pub const EGL_CONTEXT_OPENGL_PROFILE_MASK: c_int = 0x30FD;
+    pub const EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT: c_int = 0x00000001;
+    pub const EGL_OPENGL_API: c_int = 0x30A2;
+    pub const EGL_OPENGL_ES_API: c_int = 0x30A0;
+    // EGL_EXT_platform_device
+    pub const EGL_PLATFORM_DEVICE_EXT: c_int = 0x313F;
+    // EGL_MESA_platform_surfaceless
+    pub const EGL_PLATFORM_SURFACELESS_MESA: c_int = 0x31DD;
+    // EGL_MESA_platform_gbm
+    pub const EGL_PLATFORM_GBM_MESA: c_int = 0x31D7;
+
+    pub const EGLDisplay = ?*anyopaque;
+    pub const EGLConfig = ?*anyopaque;
+    pub const EGLContext = ?*anyopaque;
+    pub const EGLSurface = ?*anyopaque;
+    pub const EGLint = c_int;
+
+    var lib: ?std.DynLib = null;
+
+    pub var eglGetDisplay: *const fn (?*anyopaque) callconv(.c) EGLDisplay = undefined;
+    pub var eglInitialize: *const fn (EGLDisplay, ?*EGLint, ?*EGLint) callconv(.c) c_int = undefined;
+    pub var eglChooseConfig: *const fn (EGLDisplay, [*]const EGLint, ?*EGLConfig, EGLint, *EGLint) callconv(.c) c_int = undefined;
+    pub var eglBindAPI: *const fn (c_int) callconv(.c) c_int = undefined;
+    pub var eglCreatePbufferSurface: *const fn (EGLDisplay, EGLConfig, [*]const EGLint) callconv(.c) EGLSurface = undefined;
+    pub var eglCreateContext: *const fn (EGLDisplay, EGLConfig, EGLContext, [*]const EGLint) callconv(.c) EGLContext = undefined;
+    pub var eglMakeCurrent: *const fn (EGLDisplay, EGLSurface, EGLSurface, EGLContext) callconv(.c) c_int = undefined;
+    pub var eglDestroyContext: *const fn (EGLDisplay, EGLContext) callconv(.c) c_int = undefined;
+    pub var eglDestroySurface: *const fn (EGLDisplay, EGLSurface) callconv(.c) c_int = undefined;
+    pub var eglTerminate: *const fn (EGLDisplay) callconv(.c) c_int = undefined;
+    pub var eglSwapBuffers: *const fn (EGLDisplay, EGLSurface) callconv(.c) c_int = undefined;
+    pub var eglGetError: *const fn () callconv(.c) EGLint = undefined;
+    pub var eglGetProcAddress: *const fn ([*:0]const u8) callconv(.c) ?*const fn () callconv(.c) void = undefined;
+    // EGL_EXT_device_enumeration / EGL_EXT_platform_device
+    pub var eglQueryDevicesEXT: ?*const fn (c_int, [*]?*anyopaque, *c_int) callconv(.c) c_int = null;
+    pub var eglGetPlatformDisplayEXT: ?*const fn (c_int, ?*anyopaque, [*]const c_int) callconv(.c) EGLDisplay = null;
+
+    pub fn loadEgl() !void {
+        if (lib != null) return;
+        lib = std.DynLib.open("libEGL.so.1") catch
+            std.DynLib.open("libEGL.so") catch
+            return error.EglLibraryNotFound;
+        eglGetDisplay = lib.?.lookup(@TypeOf(eglGetDisplay), "eglGetDisplay") orelse return error.EglSymbolNotFound;
+        eglInitialize = lib.?.lookup(@TypeOf(eglInitialize), "eglInitialize") orelse return error.EglSymbolNotFound;
+        eglChooseConfig = lib.?.lookup(@TypeOf(eglChooseConfig), "eglChooseConfig") orelse return error.EglSymbolNotFound;
+        eglBindAPI = lib.?.lookup(@TypeOf(eglBindAPI), "eglBindAPI") orelse return error.EglSymbolNotFound;
+        eglCreatePbufferSurface = lib.?.lookup(@TypeOf(eglCreatePbufferSurface), "eglCreatePbufferSurface") orelse return error.EglSymbolNotFound;
+        eglCreateContext = lib.?.lookup(@TypeOf(eglCreateContext), "eglCreateContext") orelse return error.EglSymbolNotFound;
+        eglMakeCurrent = lib.?.lookup(@TypeOf(eglMakeCurrent), "eglMakeCurrent") orelse return error.EglSymbolNotFound;
+        eglDestroyContext = lib.?.lookup(@TypeOf(eglDestroyContext), "eglDestroyContext") orelse return error.EglSymbolNotFound;
+        eglDestroySurface = lib.?.lookup(@TypeOf(eglDestroySurface), "eglDestroySurface") orelse return error.EglSymbolNotFound;
+        eglTerminate = lib.?.lookup(@TypeOf(eglTerminate), "eglTerminate") orelse return error.EglSymbolNotFound;
+        eglSwapBuffers = lib.?.lookup(@TypeOf(eglSwapBuffers), "eglSwapBuffers") orelse return error.EglSymbolNotFound;
+        eglGetError = lib.?.lookup(@TypeOf(eglGetError), "eglGetError") orelse return error.EglSymbolNotFound;
+        eglGetProcAddress = lib.?.lookup(@TypeOf(eglGetProcAddress), "eglGetProcAddress") orelse return error.EglSymbolNotFound;
+        // Optional extensions for headless - must use eglGetProcAddress
+        if (eglGetProcAddress("eglQueryDevicesEXT")) |ptr| {
+            eglQueryDevicesEXT = @ptrCast(ptr);
+        }
+        if (eglGetProcAddress("eglGetPlatformDisplayEXT")) |ptr| {
+            eglGetPlatformDisplayEXT = @ptrCast(ptr);
+        }
+    }
+};
+
+const log = std.log.scoped(.egl_headless);
+
+/// Double-buffered PBO state for async pixel readback
+pub const PboState = struct {
+    /// Two PBOs for ping-pong buffering
+    pbos: [2]c_uint = .{ 0, 0 },
+    /// Write index - the PBO we're currently writing to via glReadPixels
+    write_index: u1 = 0,
+    /// Buffer size for validation
+    buffer_size: usize = 0,
+    /// Dimensions for validation
+    width: u32 = 0,
+    height: u32 = 0,
+    /// Pipeline primed flag - false until first write completes
+    /// When false, we cannot read (would get garbage/uninitialized memory)
+    is_primed: bool = false,
+
+    // OpenGL constants
+    const GL_PIXEL_PACK_BUFFER: c_uint = 0x88EB;
+    const GL_STREAM_READ: c_uint = 0x88E1;
+    const GL_MAP_READ_BIT: c_uint = 0x0001;
+    const GL_READ_ONLY: c_uint = 0x88B8;
+
+    pub fn init(self: *PboState, width: u32, height: u32) bool {
+        const genBuffers = gl.glad.context.GenBuffers orelse return false;
+        const bindBuffer = gl.glad.context.BindBuffer orelse return false;
+        const bufferData = gl.glad.context.BufferData orelse return false;
+
+        self.width = width;
+        self.height = height;
+        self.buffer_size = @as(usize, width) * @as(usize, height) * 4;
+        self.write_index = 0;
+        self.is_primed = false; // CRITICAL: Not primed until first write completes
+
+        // Generate 2 PBOs
+        genBuffers(2, &self.pbos);
+
+        // Allocate storage for both PBOs (tight packing)
+        for (self.pbos) |pbo| {
+            bindBuffer(GL_PIXEL_PACK_BUFFER, pbo);
+            bufferData(GL_PIXEL_PACK_BUFFER, @intCast(self.buffer_size), null, GL_STREAM_READ);
+        }
+
+        // Unbind
+        bindBuffer(GL_PIXEL_PACK_BUFFER, 0);
+
+        log.info("PBO initialized: 2x {}x{} ({} bytes each)", .{ width, height, self.buffer_size });
+        return true;
+    }
+
+    pub fn deinit(self: *PboState) void {
+        if (self.pbos[0] != 0) {
+            if (gl.glad.context.DeleteBuffers) |deleteBuffers| {
+                deleteBuffers(2, &self.pbos);
+            }
+            self.pbos = .{ 0, 0 };
+        }
+    }
+
+    pub fn resize(self: *PboState, width: u32, height: u32) bool {
+        if (self.width == width and self.height == height) return true;
+        self.deinit();
+        return self.init(width, height);
+    }
+
+    /// Async readPixels using double-buffered PBO
+    /// Returns false on first frame or after resize (no previous data available yet)
+    /// @param fbo_id The FBO to read from (already bound by caller)
+    pub fn readPixelsAsync(self: *PboState, dest_buffer: [*]u8, dest_len: usize, width: u32, height: u32, fbo_id: c_uint) bool {
+        _ = fbo_id; // FBO already bound by caller
+        // Validate dimensions
+        const expected_size = @as(usize, width) * @as(usize, height) * 4;
+        if (dest_len < expected_size) return false;
+
+        const genBuffers = gl.glad.context.GenBuffers orelse return false;
+        const deleteBuffers = gl.glad.context.DeleteBuffers orelse return false;
+        const bindBuffer = gl.glad.context.BindBuffer orelse return false;
+        const bufferData = gl.glad.context.BufferData orelse return false;
+        const glReadPixels = gl.glad.context.ReadPixels orelse return false;
+        const pixelStorei = gl.glad.context.PixelStorei orelse return false;
+
+        // HARD RESET: If dimensions changed, completely destroy and recreate PBOs
+        // This is CRITICAL - reusing wrong-sized PBOs causes stride corruption
+        if (self.width != width or self.height != height or self.pbos[0] == 0) {
+            log.info("PBO hard reset: {}x{} -> {}x{}", .{ self.width, self.height, width, height });
+
+            // 1. Delete old buffers (if any)
+            if (self.pbos[0] != 0) {
+                deleteBuffers(2, &self.pbos);
+                self.pbos = .{ 0, 0 };
+            }
+
+            // 2. Generate new buffers
+            genBuffers(2, &self.pbos);
+
+            // 3. Allocate storage for BOTH ping-pong buffers (tight packing)
+            const new_size: isize = @intCast(width * height * 4);
+            bindBuffer(GL_PIXEL_PACK_BUFFER, self.pbos[0]);
+            bufferData(GL_PIXEL_PACK_BUFFER, new_size, null, GL_STREAM_READ);
+            bindBuffer(GL_PIXEL_PACK_BUFFER, self.pbos[1]);
+            bufferData(GL_PIXEL_PACK_BUFFER, new_size, null, GL_STREAM_READ);
+            bindBuffer(GL_PIXEL_PACK_BUFFER, 0);
+
+            // 4. Update state
+            self.width = width;
+            self.height = height;
+            self.buffer_size = @intCast(new_size);
+            self.write_index = 0;
+            self.is_primed = false; // CRITICAL: Force sync read for this frame!
+
+            log.info("PBO allocated: 2x {}x{} ({} bytes each)", .{ width, height, new_size });
+
+            // 5. CRITICAL: Return false immediately after reset!
+            // We just allocated new buffers - both are empty/uninitialized.
+            // Force sync fallback for this frame. Next frame we'll write to buffer[0].
+            return false;
+        }
+
+        // For FBO reading, use GL_COLOR_ATTACHMENT0 (not GL_BACK)
+        if (gl.glad.context.ReadBuffer) |readBuf| {
+            readBuf(GL_COLOR_ATTACHMENT0);
+        }
+
+        // Ping-pong: write to current buffer
+        bindBuffer(GL_PIXEL_PACK_BUFFER, self.pbos[self.write_index]);
+
+        // STRICT STATE ISOLATION: Set ALL packing parameters before EVERY read
+        // This prevents state pollution from other panels sharing the GL context
+        pixelStorei(gl.c.GL_PACK_ALIGNMENT, 1); // Tight byte alignment
+        pixelStorei(gl.c.GL_PACK_ROW_LENGTH, 0); // Row length = width (no padding)
+        pixelStorei(gl.c.GL_PACK_SKIP_PIXELS, 0); // Start at column 0
+        pixelStorei(gl.c.GL_PACK_SKIP_ROWS, 0); // Start at row 0
+
+        // GL_BGRA (0x80E1) is Intel's native readback format — avoids GPU format
+        // conversion and eliminates R↔B swap in the video encoder.
+        glReadPixels(0, 0, @intCast(width), @intCast(height), 0x80E1, gl.c.GL_UNSIGNED_BYTE, null);
+
+        // No glFinish needed: PBO double-buffering means we read the OTHER buffer
+        // (written last frame, DMA long since complete). glMapBuffer below will
+        // block if the previous frame's DMA isn't done yet (but it always is).
+
+        // Unbind PBO after write completes to prevent state leak to other panels
+        bindBuffer(GL_PIXEL_PACK_BUFFER, 0);
+
+        // If not primed, we just started the first write - cannot read yet
+        // Return false to force sync fallback for this frame
+        if (!self.is_primed) {
+            self.write_index +%= 1; // Next frame will write to other buffer
+            self.is_primed = true; // Now primed - next frame can read
+            return false;
+        }
+
+        // Read from the OTHER buffer (the one we wrote to LAST frame)
+        const read_index: u1 = self.write_index +% 1;
+        bindBuffer(GL_PIXEL_PACK_BUFFER, self.pbos[read_index]);
+
+        const mapped_ptr: ?[*]const u8 = blk: {
+            // Try MapBufferRange first (more control), fall back to MapBuffer
+            if (gl.glad.context.MapBufferRange) |mapRange| {
+                break :blk @ptrCast(mapRange(GL_PIXEL_PACK_BUFFER, 0, @intCast(self.buffer_size), GL_MAP_READ_BIT));
+            } else if (gl.glad.context.MapBuffer) |mapBuf| {
+                break :blk @ptrCast(mapBuf(GL_PIXEL_PACK_BUFFER, GL_READ_ONLY));
+            }
+            break :blk null;
+        };
+
+        if (mapped_ptr == null) {
+            log.warn("PBO map failed for FBO read", .{});
+            bindBuffer(GL_PIXEL_PACK_BUFFER, 0);
+            return false;
+        }
+
+        // Simple row-by-row copy with vertical flip (tight packing)
+        const row_bytes = self.width * 4;
+        const src_ptr = mapped_ptr.?;
+        var y: u32 = 0;
+        while (y < self.height) : (y += 1) {
+            // Source: Read from PBO top-to-bottom
+            const src_offset = y * row_bytes;
+            // Dest: Write flipped (bottom-to-top becomes top-to-bottom)
+            const dst_offset = (self.height - 1 - y) * row_bytes;
+            @memcpy(dest_buffer[dst_offset..][0..row_bytes], src_ptr[src_offset..][0..row_bytes]);
+        }
+
+        // Unmap and unbind PBO
+        if (gl.glad.context.UnmapBuffer) |unmapBuf| {
+            _ = unmapBuf(GL_PIXEL_PACK_BUFFER);
+        }
+        bindBuffer(GL_PIXEL_PACK_BUFFER, 0);
+
+        // Swap write index for next frame
+        self.write_index +%= 1;
+
+        return true;
+    }
+};
+
+/// Per-surface PBO state manager
+/// Maps surface IDs (pointers) to their own PBO states to avoid race conditions between surfaces.
+/// CRITICAL: We key by surface_id (pointer) NOT fbo_id because FBO IDs can be recycled by OpenGL
+/// when surfaces are destroyed and recreated, causing state collisions between different panels.
+const PboStateManager = struct {
+    const MAX_SURFACES = 16; // Max concurrent surfaces
+
+    /// Entry mapping surface ID to its PBO state
+    const Entry = struct {
+        surface_id: usize = 0,
+        pbo_state: PboState = .{},
+        in_use: bool = false,
+    };
+
+    entries: [MAX_SURFACES]Entry = [_]Entry{.{}} ** MAX_SURFACES,
+
+    /// Get or create PBO state for a given surface ID and dimensions
+    /// If dimensions changed, the PBO is resized and is_primed is reset
+    pub fn getOrCreate(self: *PboStateManager, surface_id: usize, width: u32, height: u32) ?*PboState {
+        // First, look for existing entry
+        for (&self.entries) |*entry| {
+            if (entry.in_use and entry.surface_id == surface_id) {
+                // Check if dimensions changed (resize case)
+                if (entry.pbo_state.width != width or entry.pbo_state.height != height) {
+                    // Dimensions changed - must reallocate PBOs
+                    log.info("PBO resize: surface 0x{x} {}x{} -> {}x{}", .{
+                        surface_id,
+                        entry.pbo_state.width,
+                        entry.pbo_state.height,
+                        width,
+                        height,
+                    });
+                    // resize() calls deinit() then init() which resets is_primed=false
+                    if (!entry.pbo_state.resize(width, height)) {
+                        return null;
+                    }
+                }
+                return &entry.pbo_state;
+            }
+        }
+
+        // Not found, create new entry
+        for (&self.entries) |*entry| {
+            if (!entry.in_use) {
+                entry.surface_id = surface_id;
+                entry.in_use = true;
+                entry.pbo_state = .{};
+                log.info("PBO state created for surface 0x{x}", .{surface_id});
+                return &entry.pbo_state;
+            }
+        }
+
+        // No free slots
+        log.warn("PBO state manager full, cannot create state for surface 0x{x}", .{surface_id});
+        return null;
+    }
+
+    /// Remove PBO state for a given surface ID (call when surface is destroyed)
+    pub fn remove(self: *PboStateManager, surface_id: usize) void {
+        for (&self.entries) |*entry| {
+            if (entry.in_use and entry.surface_id == surface_id) {
+                entry.pbo_state.deinit();
+                entry.in_use = false;
+                entry.surface_id = 0;
+                log.info("PBO state removed for surface 0x{x}", .{surface_id});
+                return;
+            }
+        }
+    }
+};
+
+/// Per-surface PBO state manager instance
+var pbo_manager: PboStateManager = .{};
+
+/// Clean up PBO state for a given surface ID (call when surface is destroyed)
+pub fn cleanupPboState(surface_id: usize) void {
+    pbo_manager.remove(surface_id);
+}
+
+/// OpenGL constants for FBO binding
+const GL_READ_FRAMEBUFFER: c_uint = 0x8CA8;
+const GL_COLOR_ATTACHMENT0: c_uint = 0x8CE0;
+
+pub const EglHeadless = struct {
+    display: c.EGLDisplay,
+    context: c.EGLContext,
+    surface: c.EGLSurface,
+    use_gles: bool,
+
+    var drm_fd: ?posix.fd_t = null;
+    var gbm_device: gbm.Device = null;
+
+    pub fn init() !EglHeadless {
+        try c.loadEgl();
+
+        // Try GBM first (hardware GPU), then surfaceless, then default
+        // GBM requires DRM render node access
+        var try_gbm = false;
+        if (c.eglGetPlatformDisplayEXT != null) {
+            if (drm_fd == null) {
+                drm_fd = posix.open("/dev/dri/renderD128", .{ .ACCMODE = .RDWR }, 0) catch null;
+                if (drm_fd != null) {
+                    gbm_device = gbm.createDevice(@intCast(drm_fd.?));
+                    if (gbm_device == null) {
+                        posix.close(drm_fd.?);
+                        drm_fd = null;
+                    } else {
+                        try_gbm = true;
+                    }
+                }
+            } else if (gbm_device != null) {
+                try_gbm = true;
+            }
+        }
+
+        const platforms = [_]struct { name: []const u8, platform: ?c_int, native: ?*anyopaque }{
+            .{ .name = "gbm", .platform = c.EGL_PLATFORM_GBM_MESA, .native = gbm_device },
+            .{ .name = "surfaceless", .platform = c.EGL_PLATFORM_SURFACELESS_MESA, .native = c.EGL_DEFAULT_DISPLAY },
+            .{ .name = "default", .platform = null, .native = c.EGL_DEFAULT_DISPLAY },
+        };
+
+        for (platforms) |plat| {
+            // Skip GBM if we couldn't open the device
+            if (std.mem.eql(u8, plat.name, "gbm") and !try_gbm) continue;
+
+            var display: c.EGLDisplay = c.EGL_NO_DISPLAY;
+
+            if (plat.platform) |platform| {
+                if (c.eglGetPlatformDisplayEXT) |getPlatformDisplay| {
+                    const attribs = [_]c.EGLint{c.EGL_NONE};
+                    display = getPlatformDisplay(platform, plat.native, &attribs);
+                } else {
+                    continue;
+                }
+            } else {
+                display = c.eglGetDisplay(plat.native);
+            }
+
+            const is_surfaceless = std.mem.eql(u8, plat.name, "surfaceless");
+
+            if (display == c.EGL_NO_DISPLAY) continue;
+
+            var major: c.EGLint = 0;
+            var minor: c.EGLint = 0;
+            if (c.eglInitialize(display, &major, &minor) == c.EGL_FALSE) continue;
+
+            // Try desktop OpenGL first, then OpenGL ES
+            const api_configs = [_]struct { api: c_int, renderable: c_int, maj: c_int, min: c_int, name: []const u8, use_profile: bool }{
+                .{ .api = c.EGL_OPENGL_API, .renderable = c.EGL_OPENGL_BIT, .maj = 4, .min = 3, .name = "OpenGL 4.3", .use_profile = true },
+                .{ .api = c.EGL_OPENGL_API, .renderable = c.EGL_OPENGL_BIT, .maj = 3, .min = 3, .name = "OpenGL 3.3", .use_profile = true },
+                .{ .api = c.EGL_OPENGL_ES_API, .renderable = c.EGL_OPENGL_ES3_BIT, .maj = 3, .min = 2, .name = "OpenGL ES 3.2", .use_profile = false },
+                .{ .api = c.EGL_OPENGL_ES_API, .renderable = c.EGL_OPENGL_ES3_BIT, .maj = 3, .min = 1, .name = "OpenGL ES 3.1", .use_profile = false },
+                .{ .api = c.EGL_OPENGL_ES_API, .renderable = c.EGL_OPENGL_ES3_BIT, .maj = 3, .min = 0, .name = "OpenGL ES 3.0", .use_profile = false },
+            };
+
+            for (api_configs) |api_cfg| {
+                if (c.eglBindAPI(api_cfg.api) == c.EGL_FALSE) continue;
+
+                // Try different config attribute combinations
+                const config_variants = [_]struct { name: []const u8, attribs: []const c.EGLint }{
+                    .{ .name = "pbuffer", .attribs = &[_]c.EGLint{ c.EGL_SURFACE_TYPE, c.EGL_PBUFFER_BIT, c.EGL_RENDERABLE_TYPE, api_cfg.renderable, c.EGL_RED_SIZE, 8, c.EGL_GREEN_SIZE, 8, c.EGL_BLUE_SIZE, 8, c.EGL_ALPHA_SIZE, 8, c.EGL_NONE } },
+                    .{ .name = "surfaceless", .attribs = &[_]c.EGLint{ c.EGL_SURFACE_TYPE, 0, c.EGL_RENDERABLE_TYPE, api_cfg.renderable, c.EGL_RED_SIZE, 8, c.EGL_GREEN_SIZE, 8, c.EGL_BLUE_SIZE, 8, c.EGL_ALPHA_SIZE, 8, c.EGL_NONE } },
+                    .{ .name = "minimal", .attribs = &[_]c.EGLint{ c.EGL_RENDERABLE_TYPE, api_cfg.renderable, c.EGL_NONE } },
+                };
+
+                for (config_variants) |cfg_var| {
+                    var config: c.EGLConfig = null;
+                    var num_configs: c.EGLint = 0;
+                    const result = c.eglChooseConfig(display, cfg_var.attribs.ptr, &config, 1, &num_configs);
+                    if (result == c.EGL_FALSE or num_configs == 0) continue;
+
+                    // Surfaceless platform uses no surface, others try pbuffer
+                    var surface: c.EGLSurface = c.EGL_NO_SURFACE;
+                    if (!is_surfaceless) {
+                        const pbuffer_attribs = [_]c.EGLint{ c.EGL_WIDTH, 1, c.EGL_HEIGHT, 1, c.EGL_NONE };
+                        surface = c.eglCreatePbufferSurface(display, config, &pbuffer_attribs);
+                        // pbuffer is optional, continue even if it fails
+                    }
+
+                    var context_attribs: [7]c.EGLint = undefined;
+                    if (api_cfg.use_profile) {
+                        context_attribs = [_]c.EGLint{ c.EGL_CONTEXT_MAJOR_VERSION, api_cfg.maj, c.EGL_CONTEXT_MINOR_VERSION, api_cfg.min, c.EGL_CONTEXT_OPENGL_PROFILE_MASK, c.EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT, c.EGL_NONE };
+                    } else {
+                        context_attribs = [_]c.EGLint{ c.EGL_CONTEXT_MAJOR_VERSION, api_cfg.maj, c.EGL_CONTEXT_MINOR_VERSION, api_cfg.min, c.EGL_NONE, 0, 0 };
+                    }
+
+                    const context = c.eglCreateContext(display, config, c.EGL_NO_CONTEXT, &context_attribs);
+                    if (context == c.EGL_NO_CONTEXT) {
+                        if (surface != c.EGL_NO_SURFACE) _ = c.eglDestroySurface(display, surface);
+                        continue;
+                    }
+
+                    log.info("EGL context created: {s} via {s} platform", .{ api_cfg.name, plat.name });
+                    return .{ .display = display, .context = context, .surface = surface, .use_gles = api_cfg.api == c.EGL_OPENGL_ES_API };
+                }
+            }
+
+            _ = c.eglTerminate(display);
+        }
+
+        log.err("failed to create any valid EGL context", .{});
+        return error.EglContextFailed;
+    }
+
+    pub fn deinit(self: *EglHeadless) void {
+        _ = c.eglMakeCurrent(self.display, c.EGL_NO_SURFACE, c.EGL_NO_SURFACE, c.EGL_NO_CONTEXT);
+        _ = c.eglDestroyContext(self.display, self.context);
+        _ = c.eglDestroySurface(self.display, self.surface);
+        _ = c.eglTerminate(self.display);
+    }
+
+    pub fn makeCurrent(self: *EglHeadless) bool {
+        return c.eglMakeCurrent(self.display, self.surface, self.surface, self.context) == c.EGL_TRUE;
+    }
+
+    pub fn getProcAddress() *const fn ([*:0]const u8) callconv(.c) ?*const fn () callconv(.c) void {
+        return c.eglGetProcAddress;
+    }
+};
+
+var global_egl_context: ?EglHeadless = null;
+var gl_initialized: bool = false;
+
+pub fn initGlobalContext() !*EglHeadless {
+    if (global_egl_context) |*ctx| return ctx;
+    global_egl_context = try EglHeadless.init();
+    if (!global_egl_context.?.makeCurrent()) {
+        global_egl_context.?.deinit();
+        global_egl_context = null;
+        return error.EglMakeCurrentFailed;
+    }
+    return &global_egl_context.?;
+}
+
+pub fn isInitialized() bool {
+    return global_egl_context != null;
+}
+
+pub fn setGlInitialized() void {
+    gl_initialized = true;
+}
+
+pub fn isGlInitialized() bool {
+    return gl_initialized;
+}
+
+pub fn makeCurrentOnThread() bool {
+    if (global_egl_context) |*ctx| {
+        return ctx.makeCurrent();
+    }
+    return false;
+}
+
+pub fn releaseContext() void {
+    if (global_egl_context) |*ctx| {
+        _ = c.eglMakeCurrent(ctx.display, c.EGL_NO_SURFACE, c.EGL_NO_SURFACE, c.EGL_NO_CONTEXT);
+    }
+}
+
+/// Set the OpenGL viewport size. Must be called when surface size changes.
+pub fn setViewportSize(width: u32, height: u32) void {
+    if (!makeCurrentOnThread()) {
+        log.warn("setViewportSize: makeCurrent failed", .{});
+        return;
+    }
+
+    if (gl.glad.context.Viewport) |viewport| {
+        viewport(0, 0, @intCast(width), @intCast(height));
+        log.info("setViewportSize: {}x{}", .{ width, height });
+    }
+}
+
+/// Read pixels from the specified FBO (RGBA format)
+/// Uses per-surface double-buffered PBO for async readback.
+/// Each surface has its own PBO state to avoid race conditions between panels.
+/// @param fbo_id The OpenGL framebuffer object ID to read from (from renderer's last_target)
+/// @param surface_id Unique surface identifier (pointer) - used to key PBO state
+pub fn readPixels(buffer: [*]u8, buffer_len: usize, width: u32, height: u32, fbo_id: c_uint, surface_id: usize) bool {
+    // CRITICAL: Ensure GL context is current on this thread
+    if (!makeCurrentOnThread()) {
+        log.warn("readPixels: makeCurrent failed", .{});
+        return false;
+    }
+
+    // GL pipeline guarantees command execution order within the same context.
+    // glReadPixels will execute after all preceding rendering commands complete.
+    // No explicit glFinish needed — PBO double-buffering handles synchronization
+    // (we read the previous frame which had 33ms+ to complete).
+    if (gl.glad.context.Finish) |glFinish| {
+        glFinish();
+    }
+
+    // Bind the FBO for reading
+    if (gl.glad.context.BindFramebuffer) |bindFbo| {
+        bindFbo(GL_READ_FRAMEBUFFER, fbo_id);
+    }
+
+    // Set viewport to match the FBO dimensions (prevent state leak between surfaces)
+    if (gl.glad.context.Viewport) |viewport| {
+        viewport(0, 0, @intCast(width), @intCast(height));
+    }
+
+    // Try async PBO readback (returns previous frame, one frame behind)
+    if (pbo_manager.getOrCreate(surface_id, width, height)) |pbo_state| {
+        if (pbo_state.readPixelsAsync(buffer, buffer_len, width, height, fbo_id)) {
+            return true;
+        }
+    }
+
+    // Fallback to sync reads (first frame or PBO unavailable)
+    return readPixelsSync(buffer, buffer_len, width, height, fbo_id);
+}
+
+/// Synchronous fallback for cases where we absolutely need the current frame
+/// (e.g., single-shot capture). Slower but provides immediate data.
+pub fn readPixelsSync(buffer: [*]u8, buffer_len: usize, width: u32, height: u32, fbo_id: c_uint) bool {
+    _ = fbo_id; // FBO already bound by caller
+    const readPixelsFn = gl.glad.context.ReadPixels orelse return false;
+    const pixelStorei = gl.glad.context.PixelStorei orelse return false;
+
+    const expected_size = @as(usize, width) * @as(usize, height) * 4;
+    if (buffer_len < expected_size) return false;
+
+    // CRITICAL: Ensure no PBO is bound, or glReadPixels writes to PBO offset 0 instead of buffer!
+    if (gl.glad.context.BindBuffer) |bindBuf| {
+        bindBuf(0x88EB, 0); // GL_PIXEL_PACK_BUFFER = 0x88EB
+    }
+
+    // For FBO reading, use GL_COLOR_ATTACHMENT0 (not GL_BACK)
+    if (gl.glad.context.ReadBuffer) |readBuf| {
+        readBuf(GL_COLOR_ATTACHMENT0);
+    }
+
+    // STRICT STATE ISOLATION: Set ALL packing parameters before EVERY read
+    // This prevents state pollution from other panels sharing the GL context
+    pixelStorei(gl.c.GL_PACK_ALIGNMENT, 1); // Tight byte alignment
+    pixelStorei(gl.c.GL_PACK_ROW_LENGTH, 0); // Row length = width (no padding)
+    pixelStorei(gl.c.GL_PACK_SKIP_PIXELS, 0); // Start at column 0
+    pixelStorei(gl.c.GL_PACK_SKIP_ROWS, 0); // Start at row 0
+
+    // Read pixels in BGRA format (Intel native, avoids format conversion)
+    readPixelsFn(0, 0, @intCast(width), @intCast(height), 0x80E1, gl.c.GL_UNSIGNED_BYTE, buffer);
+
+    // Flip image vertically (OpenGL has origin at bottom-left, we need top-left)
+    const row_size = width * 4;
+    var temp_row: [4096 * 4]u8 = undefined; // Support up to 4K width
+    if (row_size <= temp_row.len) {
+        var y: u32 = 0;
+        while (y < height / 2) : (y += 1) {
+            const top_offset = y * row_size;
+            const bottom_offset = (height - 1 - y) * row_size;
+
+            // Swap rows
+            @memcpy(temp_row[0..row_size], buffer[top_offset..][0..row_size]);
+            @memcpy(buffer[top_offset..][0..row_size], buffer[bottom_offset..][0..row_size]);
+            @memcpy(buffer[bottom_offset..][0..row_size], temp_row[0..row_size]);
+        }
+    }
+
+    return true;
+}
diff --git a/src/apprt/embedded.zig b/src/apprt/embedded.zig
index dcf8a6357..654db8963 100644
--- a/src/apprt/embedded.zig
+++ b/src/apprt/embedded.zig
@@ -26,6 +26,9 @@ const log = std.log.scoped(.embedded_window);
 pub const resourcesDir = internal_os.resourcesDir;
 
 pub const App = struct {
+    /// For embedded Linux with OpenGL, drawing must be done from the app thread
+    /// because EGL contexts can only be current on one thread at a time.
+    pub const must_draw_from_app_thread = if (builtin.target.os.tag == .linux) true else false;
     /// Because we only expect the embedding API to be used in embedded
     /// environments, the options are extern so that we can expose it
     /// directly to a C callconv and not pay for any translation costs.
@@ -342,6 +345,7 @@ pub const App = struct {
 pub const Platform = union(PlatformTag) {
     macos: MacOS,
     ios: IOS,
+    linux: Linux,
 
     // If our build target for libghostty is not darwin then we do
     // not include macos support at all.
@@ -355,6 +359,12 @@ pub const Platform = union(PlatformTag) {
         uiview: objc.Object,
     } else void;
 
+    pub const Linux = if (builtin.target.os.tag == .linux) struct {
+        shm_fd: std.posix.fd_t,
+        shm_ptr: ?*anyopaque,
+        shm_size: usize,
+    } else void;
+
     // The C ABI compatible version of this union. The tag is expected
     // to be stored elsewhere.
     pub const C = extern union {
@@ -365,6 +375,12 @@ pub const Platform = union(PlatformTag) {
         ios: extern struct {
             uiview: ?*anyopaque,
         },
+
+        linux: extern struct {
+            shm_fd: c_int,
+            shm_ptr: ?*anyopaque,
+            shm_size: usize,
+        },
     };
 
     /// Initialize a Platform a tag and configuration from the C ABI.
@@ -384,6 +400,12 @@ pub const Platform = union(PlatformTag) {
                     break :ios error.UIViewMustBeSet);
                 break :ios .{ .ios = .{ .uiview = uiview } };
             } else error.UnsupportedPlatform,
+
+            .linux => if (Linux != void) .{ .linux = .{
+                .shm_fd = @intCast(c_platform.linux.shm_fd),
+                .shm_ptr = c_platform.linux.shm_ptr,
+                .shm_size = c_platform.linux.shm_size,
+            } } else error.UnsupportedPlatform,
         };
     }
 };
@@ -394,6 +416,7 @@ pub const PlatformTag = enum(c_int) {
 
     macos = 1,
     ios = 2,
+    linux = 3,
 };
 
 pub const EnvVar = extern struct {
@@ -414,6 +437,18 @@ pub const Surface = struct {
     cursor_pos: apprt.CursorPos,
     inspector: ?*Inspector = null,
 
+    /// Headless focus state. Set directly by the app thread to control
+    /// which surface shows the active cursor. Synced to core_surface.focused
+    /// and renderer.focused in draw() without any mailbox or mutex overhead.
+    headless_focused: bool = true,
+
+    /// Cursor blink state for headless mode. When must_draw_from_app_thread
+    /// is true, the renderer thread's blink timer cannot drive rendering
+    /// (its renderCallback is a no-op). Instead, we toggle the blink state
+    /// directly on the app thread using a frame counter.
+    blink_counter: u16 = 0,
+    cursor_blink_visible: bool = true,
+
     /// The current title of the surface. The embedded apprt saves this so
     /// that getTitle works without the implementer needing to save it.
     title: ?[:0]const u8 = null,
@@ -590,6 +625,13 @@ pub const Surface = struct {
         // Free our title
         if (self.title) |v| self.app.core_app.alloc.free(v);
 
+        // Clean up PBO state for this surface (Linux only)
+        // Use surface pointer as ID (not FBO ID which can be recycled)
+        if (comptime builtin.target.os.tag == .linux) {
+            const egl_headless = @import("egl_headless.zig");
+            egl_headless.cleanupPboState(@intFromPtr(self));
+        }
+
         // Remove ourselves from the list of known surfaces in the app.
         self.app.core_app.deleteSurface(self);
 
@@ -756,6 +798,54 @@ pub const Surface = struct {
     }
 
     pub fn draw(self: *Surface) void {
+        // On Linux with headless EGL, set viewport before each draw to prevent
+        // viewport state leak between surfaces sharing the same GL context.
+        // OpenGL.surfaceSize() reads GL_VIEWPORT to determine dimensions,
+        // so we must set it to THIS surface's size before rendering.
+        if (comptime builtin.target.os.tag == .linux) {
+            const egl_headless = @import("egl_headless.zig");
+            egl_headless.setViewportSize(self.size.width, self.size.height);
+        }
+        // When must_draw_from_app_thread, updateFrame must run on the same
+        // thread as drawFrame. The renderer thread skips updateFrame to avoid
+        // a data race on terminal_state (heap corruption / double free).
+        if (comptime App.must_draw_from_app_thread) {
+            // Sync focus state from the headless_focused flag (set directly
+            // by the app without any ghostty API overhead). This drives both
+            // the renderer's cursor style and the blink timer.
+            const was_focused = self.core_surface.focused;
+            self.core_surface.focused = self.headless_focused;
+            self.core_surface.renderer.focused = self.headless_focused;
+
+            // Reset blink on focus gain so cursor is immediately visible.
+            if (self.headless_focused and !was_focused) {
+                self.blink_counter = 0;
+                self.cursor_blink_visible = true;
+            }
+
+            // Toggle cursor blink on the app thread. The renderer thread's
+            // blink timer cannot drive rendering in headless mode because
+            // renderCallback is a no-op. 18 frames ≈ 600ms at 30fps.
+            // Only blink when focused — unfocused surfaces show solid block.
+            if (self.headless_focused) {
+                const blink_interval = 18;
+                self.blink_counter += 1;
+                if (self.blink_counter >= blink_interval) {
+                    self.blink_counter = 0;
+                    self.cursor_blink_visible = !self.cursor_blink_visible;
+                }
+            } else {
+                self.blink_counter = 0;
+                self.cursor_blink_visible = true;
+            }
+
+            self.core_surface.renderer.updateFrame(
+                &self.core_surface.renderer_state,
+                self.cursor_blink_visible,
+            ) catch |err| {
+                log.warn("error in updateFrame err={}", .{err});
+            };
+        }
         self.core_surface.draw() catch |err| {
             log.err("error in draw err={}", .{err});
             return;
@@ -781,6 +871,15 @@ pub const Surface = struct {
     }
 
     pub fn updateSize(self: *Surface, width: u32, height: u32) void {
+        log.info("updateSize called: {}x{} (current: {}x{})", .{ width, height, self.size.width, self.size.height });
+
+        // For embedded Linux with headless EGL, ALWAYS set the OpenGL viewport
+        // even if size hasn't changed, to ensure it's set on first call.
+        if (comptime builtin.target.os.tag == .linux) {
+            const egl_headless = @import("egl_headless.zig");
+            egl_headless.setViewportSize(width, height);
+        }
+
         // Runtimes sometimes generate superfluous resize events even
         // if the size did not actually change (SwiftUI). We check
         // that the size actually changed from what we last recorded
@@ -1255,6 +1354,10 @@ pub const CAPI = struct {
         height_px: u32,
         cell_width_px: u32,
         cell_height_px: u32,
+        padding_top_px: u32,
+        padding_bottom_px: u32,
+        padding_left_px: u32,
+        padding_right_px: u32,
     };
 
     // ghostty_clipboard_content_s
@@ -1682,6 +1785,10 @@ pub const CAPI = struct {
             .height_px = surface.core_surface.size.screen.height,
             .cell_width_px = surface.core_surface.size.cell.width,
             .cell_height_px = surface.core_surface.size.cell.height,
+            .padding_top_px = surface.core_surface.size.padding.top,
+            .padding_bottom_px = surface.core_surface.size.padding.bottom,
+            .padding_left_px = surface.core_surface.size.padding.left,
+            .padding_right_px = surface.core_surface.size.padding.right,
         };
     }
 
@@ -1708,6 +1815,13 @@ pub const CAPI = struct {
         surface.focusCallback(focused);
     }
 
+    /// Set headless focus state. This is a zero-overhead flag write —
+    /// no mailbox push, no mutex, no key release processing. The flag
+    /// is synced to core_surface.focused and renderer.focused in draw().
+    export fn ghostty_surface_set_headless_focus(surface: *Surface, focused: bool) void {
+        surface.headless_focused = focused;
+    }
+
     /// Update the occlusion state of a surface.
     export fn ghostty_surface_set_occlusion(surface: *Surface, visible: bool) void {
         surface.occlusionCallback(visible);
@@ -2204,4 +2318,83 @@ pub const CAPI = struct {
             }
         }
     };
+
+    // Linux-only C APIs
+    const Linux = struct {
+        /// Get cursor position, style, visibility, and color for headless rendering.
+        /// Returns cursor info in terminal cell coordinates.
+        /// Color is resolved from: OSC 12 override -> config default -> foreground color.
+        /// Caller must hold renderer_state.mutex (or call from same thread after draw).
+        export fn ghostty_surface_cursor_info(
+            ptr: *Surface,
+            out_col: *u16,
+            out_row: *u16,
+            out_style: *u8,
+            out_visible: *u8,
+            out_color_r: *u8,
+            out_color_g: *u8,
+            out_color_b: *u8,
+        ) void {
+            ptr.core_surface.renderer_state.mutex.lock();
+            defer ptr.core_surface.renderer_state.mutex.unlock();
+            const t = ptr.core_surface.renderer_state.terminal;
+            const screen = t.screens.active;
+            out_col.* = @intCast(screen.cursor.x);
+            out_row.* = @intCast(screen.cursor.y);
+            out_style.* = @intFromEnum(screen.cursor.cursor_style);
+            out_visible.* = if (t.modes.get(.cursor_visible)) 1 else 0;
+
+            // Resolve cursor color: OSC 12 override -> config default -> foreground -> fallback
+            if (t.colors.cursor.get()) |rgb| {
+                out_color_r.* = rgb.r;
+                out_color_g.* = rgb.g;
+                out_color_b.* = rgb.b;
+            } else if (t.colors.foreground.get()) |rgb| {
+                out_color_r.* = rgb.r;
+                out_color_g.* = rgb.g;
+                out_color_b.* = rgb.b;
+            } else {
+                out_color_r.* = 0xc8;
+                out_color_g.* = 0xc8;
+                out_color_b.* = 0xc8;
+            }
+        }
+
+        /// Read pixels from the OpenGL framebuffer for video encoding
+        export fn ghostty_surface_read_pixels(ptr: *Surface, buffer: [*]u8, buffer_len: usize) bool {
+            const width = ptr.size.width;
+            const height = ptr.size.height;
+
+            if (width == 0 or height == 0) return false;
+
+            if (comptime builtin.target.os.tag == .linux) {
+                const egl_headless = @import("egl_headless.zig");
+
+                // Get the FBO ID from the renderer's last_target
+                // Path: Surface -> core_surface -> renderer -> api -> last_target -> framebuffer.id
+                const fbo_id: c_uint = blk: {
+                    const last_target = ptr.core_surface.renderer.api.last_target orelse {
+                        // No target rendered yet - surface hasn't presented a frame
+                        return false;
+                    };
+                    const id = last_target.framebuffer.id;
+                    // FBO ID 0 means default framebuffer (not our offscreen FBO)
+                    if (id == 0) return false;
+                    break :blk id;
+                };
+
+                // Use surface pointer as unique ID for PBO state management
+                // This prevents PBO state collisions when FBO IDs are recycled
+                const surface_id = @intFromPtr(ptr);
+
+                return egl_headless.readPixels(buffer, buffer_len, width, height, fbo_id, surface_id);
+            }
+            return false;
+        }
+    };
+    comptime {
+        if (builtin.target.os.tag == .linux) {
+            _ = Linux;
+        }
+    }
 };
diff --git a/src/font/sprite/draw/special.zig b/src/font/sprite/draw/special.zig
index 8cad9ceba..141757811 100644
--- a/src/font/sprite/draw/special.zig
+++ b/src/font/sprite/draw/special.zig
@@ -286,15 +286,12 @@ pub fn cursor_rect(
     height: u32,
     metrics: font.Metrics,
 ) !void {
+    // Cursor rendering disabled: CSS overlay handles all cursor visuals.
     _ = cp;
+    _ = canvas;
+    _ = width;
+    _ = height;
     _ = metrics;
-
-    canvas.rect(.{
-        .x = 0,
-        .y = 0,
-        .width = @intCast(width),
-        .height = @intCast(height),
-    }, .on);
 }
 
 pub fn cursor_hollow_rect(
@@ -304,22 +301,12 @@ pub fn cursor_hollow_rect(
     height: u32,
     metrics: font.Metrics,
 ) !void {
+    // Cursor rendering disabled: CSS overlay handles all cursor visuals.
     _ = cp;
-
-    // We fill the entire rect and then hollow out the inside, this isn't very
-    // efficient but it doesn't need to be and it's the easiest way to write it.
-    canvas.rect(.{
-        .x = 0,
-        .y = 0,
-        .width = @intCast(width),
-        .height = @intCast(height),
-    }, .on);
-    canvas.rect(.{
-        .x = @intCast(metrics.cursor_thickness),
-        .y = @intCast(metrics.cursor_thickness),
-        .width = @intCast(width -| metrics.cursor_thickness * 2),
-        .height = @intCast(height -| metrics.cursor_thickness * 2),
-    }, .off);
+    _ = canvas;
+    _ = width;
+    _ = height;
+    _ = metrics;
 }
 
 pub fn cursor_bar(
@@ -329,20 +316,12 @@ pub fn cursor_bar(
     height: u32,
     metrics: font.Metrics,
 ) !void {
+    // Cursor rendering disabled: CSS overlay handles all cursor visuals.
     _ = cp;
+    _ = canvas;
     _ = width;
-
-    // We place the bar cursor half of its thickness over the left edge of the
-    // cell, so that it sits centered between characters, not biased to a side.
-    //
-    // We round up (add 1 before dividing by 2) because, empirically, having a
-    // 1px cursor shifted left a pixel looks better than having it not shifted.
-    canvas.rect(.{
-        .x = -@as(i32, @intCast((metrics.cursor_thickness + 1) / 2)),
-        .y = 0,
-        .width = @intCast(metrics.cursor_thickness),
-        .height = @intCast(height),
-    }, .on);
+    _ = height;
+    _ = metrics;
 }
 
 pub fn cursor_underline(
@@ -352,21 +331,10 @@ pub fn cursor_underline(
     height: u32,
     metrics: font.Metrics,
 ) !void {
+    // Cursor rendering disabled: CSS overlay handles all cursor visuals.
     _ = cp;
-
-    // We can go beyond the height of the cell a bit, but
-    // we want to be sure never to exceed the height of the
-    // canvas, which extends a quarter cell below the cell
-    // height.
-    const y = @min(
-        metrics.underline_position,
-        height +| canvas.padding_y -| metrics.underline_thickness,
-    );
-
-    canvas.rect(.{
-        .x = 0,
-        .y = @intCast(y),
-        .width = @intCast(width),
-        .height = @intCast(metrics.cursor_thickness),
-    }, .on);
+    _ = canvas;
+    _ = width;
+    _ = height;
+    _ = metrics;
 }
diff --git a/src/renderer/OpenGL.zig b/src/renderer/OpenGL.zig
index 4b01da0c5..8d5edd8f4 100644
--- a/src/renderer/OpenGL.zig
+++ b/src/renderer/OpenGL.zig
@@ -170,9 +170,16 @@ pub fn surfaceInit(surface: *apprt.Surface) !void {
         => try prepareContext(null),
 
         apprt.embedded => {
-            // TODO(mitchellh): this does nothing today to allow libghostty
-            // to compile for OpenGL targets but libghostty is strictly
-            // broken for rendering on this platforms.
+            if (comptime builtin.target.os.tag == .linux) {
+                // Initialize headless EGL for Linux embedded rendering
+                const egl_headless = @import("../apprt/egl_headless.zig");
+                if (!egl_headless.isGlInitialized()) {
+                    _ = try egl_headless.initGlobalContext();
+                    try prepareContext(egl_headless.EglHeadless.getProcAddress());
+                    egl_headless.setGlInitialized();
+                    log.info("OpenGL initialized via headless EGL", .{});
+                }
+            }
         },
     }
 
@@ -191,6 +198,8 @@ pub fn surfaceInit(surface: *apprt.Surface) !void {
 pub fn finalizeSurfaceInit(self: *const OpenGL, surface: *apprt.Surface) !void {
     _ = self;
     _ = surface;
+    // For embedded Linux, we keep the EGL context on the main thread.
+    // Drawing is done from the app thread (must_draw_from_app_thread = true).
 }
 
 /// Callback called by renderer.Thread when it begins.
@@ -209,9 +218,9 @@ pub fn threadEnter(self: *const OpenGL, surface: *apprt.Surface) !void {
         },
 
         apprt.embedded => {
-            // TODO(mitchellh): this does nothing today to allow libghostty
-            // to compile for OpenGL targets but libghostty is strictly
-            // broken for rendering on this platforms.
+            // For embedded Linux with OpenGL, all drawing happens on the app
+            // thread (must_draw_from_app_thread = true), so the renderer thread
+            // doesn't need to set up an OpenGL context.
         },
     }
 }
diff --git a/src/renderer/Thread.zig b/src/renderer/Thread.zig
index c6217fcd1..e803de701 100644
--- a/src/renderer/Thread.zig
+++ b/src/renderer/Thread.zig
@@ -608,15 +608,19 @@ fn renderCallback(
         return .disarm;
     };
 
-    // Update our frame data
-    t.renderer.updateFrame(
-        t.state,
-        t.flags.cursor_blink_visible,
-    ) catch |err|
-        log.warn("error rendering err={}", .{err});
-
-    // Draw
-    t.drawFrame(false);
+    // When must_draw_from_app_thread is true, both updateFrame and drawFrame
+    // happen on the app thread (in Surface.draw) to avoid a data race on
+    // terminal_state that causes heap corruption. Skip both here.
+    if (!must_draw_from_app_thread) {
+        t.renderer.updateFrame(
+            t.state,
+            t.flags.cursor_blink_visible,
+        ) catch |err|
+            log.warn("error rendering err={}", .{err});
+
+        // Draw
+        t.drawFrame(false);
+    }
 
     return .disarm;
 }
diff --git a/src/renderer/cursor.zig b/src/renderer/cursor.zig
index bfa92f31d..88bc81ed5 100644
--- a/src/renderer/cursor.zig
+++ b/src/renderer/cursor.zig
@@ -55,9 +55,9 @@ pub fn style(
     // If the cursor is explicitly not visible by terminal mode, we don't render.
     if (!state.cursor.visible) return null;
 
-    // If we're not focused, our cursor is always visible so that
-    // we can show the hollow box.
-    if (!opts.focused) return .block_hollow;
+    // If we're not focused, show a solid block cursor so that inactive
+    // split panes display a filled rectangle (matching expected behavior).
+    if (!opts.focused) return .block;
 
     // If the cursor is blinking and our blink state is not visible,
     // then we don't show the cursor.
diff --git a/src/renderer/generic.zig b/src/renderer/generic.zig
index c8acebd0f..4f0ca6018 100644
--- a/src/renderer/generic.zig
+++ b/src/renderer/generic.zig
@@ -2434,14 +2434,19 @@ pub fn Renderer(comptime GraphicsAPI: type) type {
                     break :cursor_color state.colors.foreground;
                 };
 
-                self.addCursor(
-                    &state.cursor,
-                    style,
-                    cursor_color,
-                );
+                // Skip cursor glyph and text recoloring when cursor is fully transparent.
+                // With opacity=0 the glyph is invisible and text recoloring would make
+                // the character under the cursor disappear (background-on-background).
+                if (self.config.cursor_opacity > 0 or !self.focused) {
+                    self.addCursor(
+                        &state.cursor,
+                        style,
+                        cursor_color,
+                    );
+                }
 
                 // If the cursor is visible then we set our uniforms.
-                if (style == .block) {
+                if (style == .block and (self.config.cursor_opacity > 0 or !self.focused)) {
                     const wide = state.cursor.cell.wide;
 
                     self.uniforms.cursor_pos = .{
