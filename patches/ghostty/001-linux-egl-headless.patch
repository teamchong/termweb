From 5f0b413f8855d25e000e73a55a8c7b773028aa98 Mon Sep 17 00:00:00 2001
From: teamchong <steven@keplogic.com>
Date: Wed, 4 Feb 2026 10:45:53 -0500
Subject: [PATCH 1/6] feat(linux): add headless EGL rendering with PBO and
 viewport

---
 include/ghostty.h          |  13 +
 src/apprt/egl_headless.zig | 504 +++++++++++++++++++++++++++++++++++++
 src/apprt/embedded.zig     |  52 ++++
 src/renderer/OpenGL.zig    |  21 +-
 4 files changed, 584 insertions(+), 6 deletions(-)
 create mode 100644 src/apprt/egl_headless.zig

diff --git a/include/ghostty.h b/include/ghostty.h
index 3d3973084..e04c2fabe 100644
--- a/include/ghostty.h
+++ b/include/ghostty.h
@@ -38,6 +38,7 @@ typedef enum {
   GHOSTTY_PLATFORM_INVALID,
   GHOSTTY_PLATFORM_MACOS,
   GHOSTTY_PLATFORM_IOS,
+  GHOSTTY_PLATFORM_LINUX,
 } ghostty_platform_e;
 
 typedef enum {
@@ -426,9 +427,16 @@ typedef struct {
   void* uiview;
 } ghostty_platform_ios_s;
 
+typedef struct {
+  int shm_fd;
+  void* shm_ptr;
+  size_t shm_size;
+} ghostty_platform_linux_s;
+
 typedef union {
   ghostty_platform_macos_s macos;
   ghostty_platform_ios_s ios;
+  ghostty_platform_linux_s linux_shm;
 } ghostty_platform_u;
 
 typedef enum {
@@ -1146,6 +1154,11 @@ void ghostty_inspector_metal_render(ghostty_inspector_t, void*, void*);
 bool ghostty_inspector_metal_shutdown(ghostty_inspector_t);
 #endif
 
+#ifdef __linux__
+// Read pixels from the OpenGL framebuffer (for video encoding)
+bool ghostty_surface_read_pixels(ghostty_surface_t, uint8_t*, size_t);
+#endif
+
 // APIs I'd like to get rid of eventually but are still needed for now.
 // Don't use these unless you know what you're doing.
 void ghostty_set_window_background_blur(ghostty_app_t, void*);
diff --git a/src/apprt/egl_headless.zig b/src/apprt/egl_headless.zig
new file mode 100644
index 000000000..666b80909
--- /dev/null
+++ b/src/apprt/egl_headless.zig
@@ -0,0 +1,504 @@
+const std = @import("std");
+const builtin = @import("builtin");
+const posix = std.posix;
+const gl = @import("opengl");
+
+// GBM types and functions
+const gbm = struct {
+    const Device = ?*anyopaque;
+    const CreateDeviceFn = *const fn (c_int) callconv(.c) Device;
+    const DestroyDeviceFn = *const fn (Device) callconv(.c) void;
+
+    var lib: ?std.DynLib = null;
+    var gbm_create_device: ?CreateDeviceFn = null;
+    var gbm_device_destroy: ?DestroyDeviceFn = null;
+
+    fn load() void {
+        if (lib != null) return;
+        lib = std.DynLib.open("libgbm.so.1") catch std.DynLib.open("libgbm.so") catch return;
+        gbm_create_device = lib.?.lookup(CreateDeviceFn, "gbm_create_device");
+        gbm_device_destroy = lib.?.lookup(DestroyDeviceFn, "gbm_device_destroy");
+    }
+
+    fn createDevice(fd: c_int) Device {
+        load();
+        if (gbm_create_device) |func| return func(fd);
+        return null;
+    }
+};
+
+const c = struct {
+    pub const EGL_DEFAULT_DISPLAY: ?*anyopaque = null;
+    pub const EGL_NO_DISPLAY: ?*anyopaque = null;
+    pub const EGL_NO_CONTEXT: ?*anyopaque = null;
+    pub const EGL_NO_SURFACE: ?*anyopaque = null;
+    pub const EGL_FALSE: c_int = 0;
+    pub const EGL_TRUE: c_int = 1;
+    pub const EGL_SURFACE_TYPE: c_int = 0x3033;
+    pub const EGL_PBUFFER_BIT: c_int = 0x0001;
+    pub const EGL_RENDERABLE_TYPE: c_int = 0x3040;
+    pub const EGL_OPENGL_BIT: c_int = 0x0008;
+    pub const EGL_OPENGL_ES2_BIT: c_int = 0x0004;
+    pub const EGL_OPENGL_ES3_BIT: c_int = 0x0040;
+    pub const EGL_RED_SIZE: c_int = 0x3024;
+    pub const EGL_GREEN_SIZE: c_int = 0x3025;
+    pub const EGL_BLUE_SIZE: c_int = 0x3026;
+    pub const EGL_ALPHA_SIZE: c_int = 0x3027;
+    pub const EGL_NONE: c_int = 0x3038;
+    pub const EGL_WIDTH: c_int = 0x3057;
+    pub const EGL_HEIGHT: c_int = 0x3058;
+    pub const EGL_CONTEXT_MAJOR_VERSION: c_int = 0x3098;
+    pub const EGL_CONTEXT_MINOR_VERSION: c_int = 0x30FB;
+    pub const EGL_CONTEXT_OPENGL_PROFILE_MASK: c_int = 0x30FD;
+    pub const EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT: c_int = 0x00000001;
+    pub const EGL_OPENGL_API: c_int = 0x30A2;
+    pub const EGL_OPENGL_ES_API: c_int = 0x30A0;
+    // EGL_EXT_platform_device
+    pub const EGL_PLATFORM_DEVICE_EXT: c_int = 0x313F;
+    // EGL_MESA_platform_surfaceless
+    pub const EGL_PLATFORM_SURFACELESS_MESA: c_int = 0x31DD;
+    // EGL_MESA_platform_gbm
+    pub const EGL_PLATFORM_GBM_MESA: c_int = 0x31D7;
+
+    pub const EGLDisplay = ?*anyopaque;
+    pub const EGLConfig = ?*anyopaque;
+    pub const EGLContext = ?*anyopaque;
+    pub const EGLSurface = ?*anyopaque;
+    pub const EGLint = c_int;
+
+    var lib: ?std.DynLib = null;
+
+    pub var eglGetDisplay: *const fn (?*anyopaque) callconv(.c) EGLDisplay = undefined;
+    pub var eglInitialize: *const fn (EGLDisplay, ?*EGLint, ?*EGLint) callconv(.c) c_int = undefined;
+    pub var eglChooseConfig: *const fn (EGLDisplay, [*]const EGLint, ?*EGLConfig, EGLint, *EGLint) callconv(.c) c_int = undefined;
+    pub var eglBindAPI: *const fn (c_int) callconv(.c) c_int = undefined;
+    pub var eglCreatePbufferSurface: *const fn (EGLDisplay, EGLConfig, [*]const EGLint) callconv(.c) EGLSurface = undefined;
+    pub var eglCreateContext: *const fn (EGLDisplay, EGLConfig, EGLContext, [*]const EGLint) callconv(.c) EGLContext = undefined;
+    pub var eglMakeCurrent: *const fn (EGLDisplay, EGLSurface, EGLSurface, EGLContext) callconv(.c) c_int = undefined;
+    pub var eglDestroyContext: *const fn (EGLDisplay, EGLContext) callconv(.c) c_int = undefined;
+    pub var eglDestroySurface: *const fn (EGLDisplay, EGLSurface) callconv(.c) c_int = undefined;
+    pub var eglTerminate: *const fn (EGLDisplay) callconv(.c) c_int = undefined;
+    pub var eglSwapBuffers: *const fn (EGLDisplay, EGLSurface) callconv(.c) c_int = undefined;
+    pub var eglGetError: *const fn () callconv(.c) EGLint = undefined;
+    pub var eglGetProcAddress: *const fn ([*:0]const u8) callconv(.c) ?*const fn () callconv(.c) void = undefined;
+    // EGL_EXT_device_enumeration / EGL_EXT_platform_device
+    pub var eglQueryDevicesEXT: ?*const fn (c_int, [*]?*anyopaque, *c_int) callconv(.c) c_int = null;
+    pub var eglGetPlatformDisplayEXT: ?*const fn (c_int, ?*anyopaque, [*]const c_int) callconv(.c) EGLDisplay = null;
+
+    pub fn loadEgl() !void {
+        if (lib != null) return;
+        lib = std.DynLib.open("libEGL.so.1") catch
+            std.DynLib.open("libEGL.so") catch
+            return error.EglLibraryNotFound;
+        eglGetDisplay = lib.?.lookup(@TypeOf(eglGetDisplay), "eglGetDisplay") orelse return error.EglSymbolNotFound;
+        eglInitialize = lib.?.lookup(@TypeOf(eglInitialize), "eglInitialize") orelse return error.EglSymbolNotFound;
+        eglChooseConfig = lib.?.lookup(@TypeOf(eglChooseConfig), "eglChooseConfig") orelse return error.EglSymbolNotFound;
+        eglBindAPI = lib.?.lookup(@TypeOf(eglBindAPI), "eglBindAPI") orelse return error.EglSymbolNotFound;
+        eglCreatePbufferSurface = lib.?.lookup(@TypeOf(eglCreatePbufferSurface), "eglCreatePbufferSurface") orelse return error.EglSymbolNotFound;
+        eglCreateContext = lib.?.lookup(@TypeOf(eglCreateContext), "eglCreateContext") orelse return error.EglSymbolNotFound;
+        eglMakeCurrent = lib.?.lookup(@TypeOf(eglMakeCurrent), "eglMakeCurrent") orelse return error.EglSymbolNotFound;
+        eglDestroyContext = lib.?.lookup(@TypeOf(eglDestroyContext), "eglDestroyContext") orelse return error.EglSymbolNotFound;
+        eglDestroySurface = lib.?.lookup(@TypeOf(eglDestroySurface), "eglDestroySurface") orelse return error.EglSymbolNotFound;
+        eglTerminate = lib.?.lookup(@TypeOf(eglTerminate), "eglTerminate") orelse return error.EglSymbolNotFound;
+        eglSwapBuffers = lib.?.lookup(@TypeOf(eglSwapBuffers), "eglSwapBuffers") orelse return error.EglSymbolNotFound;
+        eglGetError = lib.?.lookup(@TypeOf(eglGetError), "eglGetError") orelse return error.EglSymbolNotFound;
+        eglGetProcAddress = lib.?.lookup(@TypeOf(eglGetProcAddress), "eglGetProcAddress") orelse return error.EglSymbolNotFound;
+        // Optional extensions for headless - must use eglGetProcAddress
+        if (eglGetProcAddress("eglQueryDevicesEXT")) |ptr| {
+            eglQueryDevicesEXT = @ptrCast(ptr);
+        }
+        if (eglGetProcAddress("eglGetPlatformDisplayEXT")) |ptr| {
+            eglGetPlatformDisplayEXT = @ptrCast(ptr);
+        }
+    }
+};
+
+const log = std.log.scoped(.egl_headless);
+
+/// Double-buffered PBO state for async pixel readback
+pub const PboState = struct {
+    /// Two PBOs for ping-pong buffering
+    pbos: [2]c_uint = .{ 0, 0 },
+    /// Current PBO index (the one we're reading INTO via glReadPixels)
+    current_index: u1 = 0,
+    /// Buffer size for validation
+    buffer_size: usize = 0,
+    /// Dimensions for validation
+    width: u32 = 0,
+    height: u32 = 0,
+    /// Frame counter - 0 means first frame (no previous data)
+    frame_count: u32 = 0,
+
+    // OpenGL constants
+    const GL_PIXEL_PACK_BUFFER: c_uint = 0x88EB;
+    const GL_STREAM_READ: c_uint = 0x88E1;
+    const GL_MAP_READ_BIT: c_uint = 0x0001;
+    const GL_READ_ONLY: c_uint = 0x88B8;
+
+    pub fn init(self: *PboState, width: u32, height: u32) bool {
+        const genBuffers = gl.glad.context.GenBuffers orelse return false;
+        const bindBuffer = gl.glad.context.BindBuffer orelse return false;
+        const bufferData = gl.glad.context.BufferData orelse return false;
+
+        self.width = width;
+        self.height = height;
+        self.buffer_size = @as(usize, width) * @as(usize, height) * 4;
+        self.frame_count = 0;
+
+        // Generate 2 PBOs
+        genBuffers(2, &self.pbos);
+
+        // Allocate storage for both PBOs
+        for (self.pbos) |pbo| {
+            bindBuffer(GL_PIXEL_PACK_BUFFER, pbo);
+            bufferData(GL_PIXEL_PACK_BUFFER, @intCast(self.buffer_size), null, GL_STREAM_READ);
+        }
+
+        // Unbind
+        bindBuffer(GL_PIXEL_PACK_BUFFER, 0);
+
+        log.info("PBO initialized: 2x {}x{} ({} bytes each)", .{ width, height, self.buffer_size });
+        return true;
+    }
+
+    pub fn deinit(self: *PboState) void {
+        if (self.pbos[0] != 0) {
+            if (gl.glad.context.DeleteBuffers) |deleteBuffers| {
+                deleteBuffers(2, &self.pbos);
+            }
+            self.pbos = .{ 0, 0 };
+        }
+    }
+
+    pub fn resize(self: *PboState, width: u32, height: u32) bool {
+        if (self.width == width and self.height == height) return true;
+        self.deinit();
+        return self.init(width, height);
+    }
+
+    /// Async readPixels using double-buffered PBO
+    /// Returns false on first frame (no previous data available yet)
+    pub fn readPixelsAsync(self: *PboState, dest_buffer: [*]u8, dest_len: usize, width: u32, height: u32) bool {
+        // Validate dimensions
+        const expected_size = @as(usize, width) * @as(usize, height) * 4;
+        if (dest_len < expected_size) return false;
+
+        // Resize PBOs if needed
+        if (self.pbos[0] == 0 or self.width != width or self.height != height) {
+            if (!self.resize(width, height)) return false;
+        }
+
+        const bindBuffer = gl.glad.context.BindBuffer orelse return false;
+        const glReadPixels = gl.glad.context.ReadPixels orelse return false;
+
+        // Set read buffer
+        if (gl.glad.context.ReadBuffer) |readBuf| {
+            readBuf(gl.c.GL_BACK);
+        }
+
+        const next_index: u1 = self.current_index +% 1;
+
+        // 1. Bind next PBO and start async read (returns immediately)
+        bindBuffer(GL_PIXEL_PACK_BUFFER, self.pbos[next_index]);
+        glReadPixels(0, 0, @intCast(width), @intCast(height), gl.c.GL_RGBA, gl.c.GL_UNSIGNED_BYTE, null);
+
+        // 2. First frame: no previous data to read, just swap and return false
+        if (self.frame_count == 0) {
+            bindBuffer(GL_PIXEL_PACK_BUFFER, 0);
+            self.current_index = next_index;
+            self.frame_count = 1;
+            return false;
+        }
+
+        // 3. Bind current (previous) PBO and map it
+        bindBuffer(GL_PIXEL_PACK_BUFFER, self.pbos[self.current_index]);
+
+        const mapped_ptr: ?[*]const u8 = blk: {
+            // Try MapBufferRange first (more control), fall back to MapBuffer
+            if (gl.glad.context.MapBufferRange) |mapRange| {
+                break :blk @ptrCast(mapRange(GL_PIXEL_PACK_BUFFER, 0, @intCast(self.buffer_size), GL_MAP_READ_BIT));
+            } else if (gl.glad.context.MapBuffer) |mapBuf| {
+                break :blk @ptrCast(mapBuf(GL_PIXEL_PACK_BUFFER, GL_READ_ONLY));
+            }
+            break :blk null;
+        };
+
+        if (mapped_ptr == null) {
+            bindBuffer(GL_PIXEL_PACK_BUFFER, 0);
+            return false;
+        }
+
+        // 4. Copy with vertical flip (OpenGL origin is bottom-left)
+        // Read linearly from mapped memory, write flipped to dest
+        const row_size = width * 4;
+        var y: u32 = 0;
+        while (y < height) : (y += 1) {
+            const src_row = (height - 1 - y) * row_size; // Bottom-to-top
+            const dst_row = y * row_size; // Top-to-bottom
+            @memcpy(dest_buffer[dst_row..][0..row_size], mapped_ptr.?[src_row..][0..row_size]);
+        }
+
+        // 5. Unmap and unbind
+        if (gl.glad.context.UnmapBuffer) |unmapBuf| {
+            _ = unmapBuf(GL_PIXEL_PACK_BUFFER);
+        }
+        bindBuffer(GL_PIXEL_PACK_BUFFER, 0);
+
+        // 6. Swap indices for next frame
+        self.current_index = next_index;
+        self.frame_count +|= 1;
+
+        return true;
+    }
+};
+
+/// Global PBO state for async readback
+var global_pbo_state: PboState = .{};
+
+pub const EglHeadless = struct {
+    display: c.EGLDisplay,
+    context: c.EGLContext,
+    surface: c.EGLSurface,
+    use_gles: bool,
+
+    var drm_fd: ?posix.fd_t = null;
+    var gbm_device: gbm.Device = null;
+
+    pub fn init() !EglHeadless {
+        try c.loadEgl();
+
+        // Try GBM first (hardware GPU), then surfaceless, then default
+        // GBM requires DRM render node access
+        var try_gbm = false;
+        if (c.eglGetPlatformDisplayEXT != null) {
+            if (drm_fd == null) {
+                drm_fd = posix.open("/dev/dri/renderD128", .{ .ACCMODE = .RDWR }, 0) catch null;
+                if (drm_fd != null) {
+                    gbm_device = gbm.createDevice(@intCast(drm_fd.?));
+                    if (gbm_device == null) {
+                        posix.close(drm_fd.?);
+                        drm_fd = null;
+                    } else {
+                        try_gbm = true;
+                    }
+                }
+            } else if (gbm_device != null) {
+                try_gbm = true;
+            }
+        }
+
+        const platforms = [_]struct { name: []const u8, platform: ?c_int, native: ?*anyopaque }{
+            .{ .name = "gbm", .platform = c.EGL_PLATFORM_GBM_MESA, .native = gbm_device },
+            .{ .name = "surfaceless", .platform = c.EGL_PLATFORM_SURFACELESS_MESA, .native = c.EGL_DEFAULT_DISPLAY },
+            .{ .name = "default", .platform = null, .native = c.EGL_DEFAULT_DISPLAY },
+        };
+
+        for (platforms) |plat| {
+            // Skip GBM if we couldn't open the device
+            if (std.mem.eql(u8, plat.name, "gbm") and !try_gbm) continue;
+
+            var display: c.EGLDisplay = c.EGL_NO_DISPLAY;
+
+            if (plat.platform) |platform| {
+                if (c.eglGetPlatformDisplayEXT) |getPlatformDisplay| {
+                    const attribs = [_]c.EGLint{c.EGL_NONE};
+                    display = getPlatformDisplay(platform, plat.native, &attribs);
+                } else {
+                    continue;
+                }
+            } else {
+                display = c.eglGetDisplay(plat.native);
+            }
+
+            const is_surfaceless = std.mem.eql(u8, plat.name, "surfaceless");
+
+            if (display == c.EGL_NO_DISPLAY) continue;
+
+            var major: c.EGLint = 0;
+            var minor: c.EGLint = 0;
+            if (c.eglInitialize(display, &major, &minor) == c.EGL_FALSE) continue;
+
+            // Try desktop OpenGL first, then OpenGL ES
+            const api_configs = [_]struct { api: c_int, renderable: c_int, maj: c_int, min: c_int, name: []const u8, use_profile: bool }{
+                .{ .api = c.EGL_OPENGL_API, .renderable = c.EGL_OPENGL_BIT, .maj = 4, .min = 3, .name = "OpenGL 4.3", .use_profile = true },
+                .{ .api = c.EGL_OPENGL_API, .renderable = c.EGL_OPENGL_BIT, .maj = 3, .min = 3, .name = "OpenGL 3.3", .use_profile = true },
+                .{ .api = c.EGL_OPENGL_ES_API, .renderable = c.EGL_OPENGL_ES3_BIT, .maj = 3, .min = 2, .name = "OpenGL ES 3.2", .use_profile = false },
+                .{ .api = c.EGL_OPENGL_ES_API, .renderable = c.EGL_OPENGL_ES3_BIT, .maj = 3, .min = 1, .name = "OpenGL ES 3.1", .use_profile = false },
+                .{ .api = c.EGL_OPENGL_ES_API, .renderable = c.EGL_OPENGL_ES3_BIT, .maj = 3, .min = 0, .name = "OpenGL ES 3.0", .use_profile = false },
+            };
+
+            for (api_configs) |api_cfg| {
+                if (c.eglBindAPI(api_cfg.api) == c.EGL_FALSE) continue;
+
+                // Try different config attribute combinations
+                const config_variants = [_]struct { name: []const u8, attribs: []const c.EGLint }{
+                    .{ .name = "pbuffer", .attribs = &[_]c.EGLint{ c.EGL_SURFACE_TYPE, c.EGL_PBUFFER_BIT, c.EGL_RENDERABLE_TYPE, api_cfg.renderable, c.EGL_RED_SIZE, 8, c.EGL_GREEN_SIZE, 8, c.EGL_BLUE_SIZE, 8, c.EGL_ALPHA_SIZE, 8, c.EGL_NONE } },
+                    .{ .name = "surfaceless", .attribs = &[_]c.EGLint{ c.EGL_SURFACE_TYPE, 0, c.EGL_RENDERABLE_TYPE, api_cfg.renderable, c.EGL_RED_SIZE, 8, c.EGL_GREEN_SIZE, 8, c.EGL_BLUE_SIZE, 8, c.EGL_ALPHA_SIZE, 8, c.EGL_NONE } },
+                    .{ .name = "minimal", .attribs = &[_]c.EGLint{ c.EGL_RENDERABLE_TYPE, api_cfg.renderable, c.EGL_NONE } },
+                };
+
+                for (config_variants) |cfg_var| {
+                    var config: c.EGLConfig = null;
+                    var num_configs: c.EGLint = 0;
+                    const result = c.eglChooseConfig(display, cfg_var.attribs.ptr, &config, 1, &num_configs);
+                    if (result == c.EGL_FALSE or num_configs == 0) continue;
+
+                    // Surfaceless platform uses no surface, others try pbuffer
+                    var surface: c.EGLSurface = c.EGL_NO_SURFACE;
+                    if (!is_surfaceless) {
+                        const pbuffer_attribs = [_]c.EGLint{ c.EGL_WIDTH, 1, c.EGL_HEIGHT, 1, c.EGL_NONE };
+                        surface = c.eglCreatePbufferSurface(display, config, &pbuffer_attribs);
+                        // pbuffer is optional, continue even if it fails
+                    }
+
+                    var context_attribs: [7]c.EGLint = undefined;
+                    if (api_cfg.use_profile) {
+                        context_attribs = [_]c.EGLint{ c.EGL_CONTEXT_MAJOR_VERSION, api_cfg.maj, c.EGL_CONTEXT_MINOR_VERSION, api_cfg.min, c.EGL_CONTEXT_OPENGL_PROFILE_MASK, c.EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT, c.EGL_NONE };
+                    } else {
+                        context_attribs = [_]c.EGLint{ c.EGL_CONTEXT_MAJOR_VERSION, api_cfg.maj, c.EGL_CONTEXT_MINOR_VERSION, api_cfg.min, c.EGL_NONE, 0, 0 };
+                    }
+
+                    const context = c.eglCreateContext(display, config, c.EGL_NO_CONTEXT, &context_attribs);
+                    if (context == c.EGL_NO_CONTEXT) {
+                        if (surface != c.EGL_NO_SURFACE) _ = c.eglDestroySurface(display, surface);
+                        continue;
+                    }
+
+                    log.info("EGL context created: {s} via {s} platform", .{ api_cfg.name, plat.name });
+                    return .{ .display = display, .context = context, .surface = surface, .use_gles = api_cfg.api == c.EGL_OPENGL_ES_API };
+                }
+            }
+
+            _ = c.eglTerminate(display);
+        }
+
+        log.err("failed to create any valid EGL context", .{});
+        return error.EglContextFailed;
+    }
+
+    pub fn deinit(self: *EglHeadless) void {
+        _ = c.eglMakeCurrent(self.display, c.EGL_NO_SURFACE, c.EGL_NO_SURFACE, c.EGL_NO_CONTEXT);
+        _ = c.eglDestroyContext(self.display, self.context);
+        _ = c.eglDestroySurface(self.display, self.surface);
+        _ = c.eglTerminate(self.display);
+    }
+
+    pub fn makeCurrent(self: *EglHeadless) bool {
+        return c.eglMakeCurrent(self.display, self.surface, self.surface, self.context) == c.EGL_TRUE;
+    }
+
+    pub fn getProcAddress() *const fn ([*:0]const u8) callconv(.c) ?*const fn () callconv(.c) void {
+        return c.eglGetProcAddress;
+    }
+};
+
+var global_egl_context: ?EglHeadless = null;
+var gl_initialized: bool = false;
+
+pub fn initGlobalContext() !*EglHeadless {
+    if (global_egl_context) |*ctx| return ctx;
+    global_egl_context = try EglHeadless.init();
+    if (!global_egl_context.?.makeCurrent()) {
+        global_egl_context.?.deinit();
+        global_egl_context = null;
+        return error.EglMakeCurrentFailed;
+    }
+    return &global_egl_context.?;
+}
+
+pub fn isInitialized() bool {
+    return global_egl_context != null;
+}
+
+pub fn setGlInitialized() void {
+    gl_initialized = true;
+}
+
+pub fn isGlInitialized() bool {
+    return gl_initialized;
+}
+
+pub fn makeCurrentOnThread() bool {
+    if (global_egl_context) |*ctx| {
+        return ctx.makeCurrent();
+    }
+    return false;
+}
+
+pub fn releaseContext() void {
+    if (global_egl_context) |*ctx| {
+        _ = c.eglMakeCurrent(ctx.display, c.EGL_NO_SURFACE, c.EGL_NO_SURFACE, c.EGL_NO_CONTEXT);
+    }
+}
+
+/// Set the OpenGL viewport size. Must be called when surface size changes
+/// so that rendering and readPixels work correctly.
+pub fn setViewportSize(width: u32, height: u32) void {
+    if (!makeCurrentOnThread()) {
+        log.warn("setViewportSize: makeCurrent failed", .{});
+        return;
+    }
+    if (gl.glad.context.Viewport) |viewport| {
+        viewport(0, 0, @intCast(width), @intCast(height));
+        log.info("setViewportSize: {}x{}", .{ width, height });
+    }
+}
+
+/// Read pixels from the current OpenGL framebuffer (RGBA format)
+/// Uses double-buffered PBO for async readback with sync fallback.
+/// PBO returns previous frame's data while current frame reads (pipelined).
+/// Falls back to sync read on first frame to ensure we always have data.
+pub fn readPixels(buffer: [*]u8, buffer_len: usize, width: u32, height: u32) bool {
+    // Try async PBO first
+    const pbo_ok = global_pbo_state.readPixelsAsync(buffer, buffer_len, width, height);
+    if (pbo_ok) {
+        return true;
+    }
+    // Fall back to sync read (first frame or PBO error)
+    const sync_ok = readPixelsSync(buffer, buffer_len, width, height);
+    // Debug: log first pixel after sync read
+    if (sync_ok and buffer_len >= 4) {
+        const first_pixel = buffer[0..4];
+        if (global_pbo_state.frame_count < 3) {
+            log.info("readPixels sync fallback: frame={}, first_pixel=({},{},{},{})", .{
+                global_pbo_state.frame_count, first_pixel[0], first_pixel[1], first_pixel[2], first_pixel[3],
+            });
+        }
+    }
+    return sync_ok;
+}
+
+/// Synchronous fallback for cases where we absolutely need the current frame
+/// (e.g., single-shot capture). Slower but provides immediate data.
+pub fn readPixelsSync(buffer: [*]u8, buffer_len: usize, width: u32, height: u32) bool {
+    const readPixelsFn = gl.glad.context.ReadPixels orelse return false;
+
+    const expected_size = @as(usize, width) * @as(usize, height) * 4;
+    if (buffer_len < expected_size) return false;
+
+    // Ensure we're reading from the right buffer
+    if (gl.glad.context.ReadBuffer) |readBuf| {
+        readBuf(gl.c.GL_BACK);
+    }
+
+    // Read pixels (OpenGL origin is bottom-left)
+    readPixelsFn(0, 0, @intCast(width), @intCast(height), gl.c.GL_RGBA, gl.c.GL_UNSIGNED_BYTE, buffer);
+
+    // Flip image vertically (OpenGL has origin at bottom-left, we need top-left)
+    const row_size = width * 4;
+    var temp_row: [4096 * 4]u8 = undefined; // Support up to 4K width
+    if (row_size <= temp_row.len) {
+        var y: u32 = 0;
+        while (y < height / 2) : (y += 1) {
+            const top_offset = y * row_size;
+            const bottom_offset = (height - 1 - y) * row_size;
+
+            // Swap rows
+            @memcpy(temp_row[0..row_size], buffer[top_offset..][0..row_size]);
+            @memcpy(buffer[top_offset..][0..row_size], buffer[bottom_offset..][0..row_size]);
+            @memcpy(buffer[bottom_offset..][0..row_size], temp_row[0..row_size]);
+        }
+    }
+
+    return true;
+}
diff --git a/src/apprt/embedded.zig b/src/apprt/embedded.zig
index dcf8a6357..2887c84b4 100644
--- a/src/apprt/embedded.zig
+++ b/src/apprt/embedded.zig
@@ -26,6 +26,9 @@ const log = std.log.scoped(.embedded_window);
 pub const resourcesDir = internal_os.resourcesDir;
 
 pub const App = struct {
+    /// For embedded Linux with OpenGL, drawing must be done from the app thread
+    /// because EGL contexts can only be current on one thread at a time.
+    pub const must_draw_from_app_thread = if (builtin.target.os.tag == .linux) true else false;
     /// Because we only expect the embedding API to be used in embedded
     /// environments, the options are extern so that we can expose it
     /// directly to a C callconv and not pay for any translation costs.
@@ -342,6 +345,7 @@ pub const App = struct {
 pub const Platform = union(PlatformTag) {
     macos: MacOS,
     ios: IOS,
+    linux: Linux,
 
     // If our build target for libghostty is not darwin then we do
     // not include macos support at all.
@@ -355,6 +359,12 @@ pub const Platform = union(PlatformTag) {
         uiview: objc.Object,
     } else void;
 
+    pub const Linux = if (builtin.target.os.tag == .linux) struct {
+        shm_fd: std.posix.fd_t,
+        shm_ptr: ?*anyopaque,
+        shm_size: usize,
+    } else void;
+
     // The C ABI compatible version of this union. The tag is expected
     // to be stored elsewhere.
     pub const C = extern union {
@@ -365,6 +375,12 @@ pub const Platform = union(PlatformTag) {
         ios: extern struct {
             uiview: ?*anyopaque,
         },
+
+        linux: extern struct {
+            shm_fd: c_int,
+            shm_ptr: ?*anyopaque,
+            shm_size: usize,
+        },
     };
 
     /// Initialize a Platform a tag and configuration from the C ABI.
@@ -384,6 +400,12 @@ pub const Platform = union(PlatformTag) {
                     break :ios error.UIViewMustBeSet);
                 break :ios .{ .ios = .{ .uiview = uiview } };
             } else error.UnsupportedPlatform,
+
+            .linux => if (Linux != void) .{ .linux = .{
+                .shm_fd = @intCast(c_platform.linux.shm_fd),
+                .shm_ptr = c_platform.linux.shm_ptr,
+                .shm_size = c_platform.linux.shm_size,
+            } } else error.UnsupportedPlatform,
         };
     }
 };
@@ -394,6 +416,7 @@ pub const PlatformTag = enum(c_int) {
 
     macos = 1,
     ios = 2,
+    linux = 3,
 };
 
 pub const EnvVar = extern struct {
@@ -792,6 +815,13 @@ pub const Surface = struct {
             .height = height,
         };
 
+        // For embedded Linux with headless EGL, set the OpenGL viewport
+        // so that readPixels returns actual content instead of black.
+        if (comptime builtin.target.os.tag == .linux) {
+            const egl_headless = @import("egl_headless.zig");
+            egl_headless.setViewportSize(width, height);
+        }
+
         // Call the primary callback.
         self.core_surface.sizeCallback(self.size) catch |err| {
             log.err("error in size callback err={}", .{err});
@@ -2204,4 +2234,26 @@ pub const CAPI = struct {
             }
         }
     };
+
+    // Linux-only C APIs
+    const Linux = struct {
+        /// Read pixels from the OpenGL framebuffer for video encoding
+        export fn ghostty_surface_read_pixels(ptr: *Surface, buffer: [*]u8, buffer_len: usize) bool {
+            const width = ptr.size.width;
+            const height = ptr.size.height;
+
+            if (width == 0 or height == 0) return false;
+
+            if (comptime builtin.target.os.tag == .linux) {
+                const egl_headless = @import("egl_headless.zig");
+                return egl_headless.readPixels(buffer, buffer_len, width, height);
+            }
+            return false;
+        }
+    };
+    comptime {
+        if (builtin.target.os.tag == .linux) {
+            _ = Linux;
+        }
+    }
 };
diff --git a/src/renderer/OpenGL.zig b/src/renderer/OpenGL.zig
index 4b01da0c5..8d5edd8f4 100644
--- a/src/renderer/OpenGL.zig
+++ b/src/renderer/OpenGL.zig
@@ -170,9 +170,16 @@ pub fn surfaceInit(surface: *apprt.Surface) !void {
         => try prepareContext(null),
 
         apprt.embedded => {
-            // TODO(mitchellh): this does nothing today to allow libghostty
-            // to compile for OpenGL targets but libghostty is strictly
-            // broken for rendering on this platforms.
+            if (comptime builtin.target.os.tag == .linux) {
+                // Initialize headless EGL for Linux embedded rendering
+                const egl_headless = @import("../apprt/egl_headless.zig");
+                if (!egl_headless.isGlInitialized()) {
+                    _ = try egl_headless.initGlobalContext();
+                    try prepareContext(egl_headless.EglHeadless.getProcAddress());
+                    egl_headless.setGlInitialized();
+                    log.info("OpenGL initialized via headless EGL", .{});
+                }
+            }
         },
     }
 
@@ -191,6 +198,8 @@ pub fn surfaceInit(surface: *apprt.Surface) !void {
 pub fn finalizeSurfaceInit(self: *const OpenGL, surface: *apprt.Surface) !void {
     _ = self;
     _ = surface;
+    // For embedded Linux, we keep the EGL context on the main thread.
+    // Drawing is done from the app thread (must_draw_from_app_thread = true).
 }
 
 /// Callback called by renderer.Thread when it begins.
@@ -209,9 +218,9 @@ pub fn threadEnter(self: *const OpenGL, surface: *apprt.Surface) !void {
         },
 
         apprt.embedded => {
-            // TODO(mitchellh): this does nothing today to allow libghostty
-            // to compile for OpenGL targets but libghostty is strictly
-            // broken for rendering on this platforms.
+            // For embedded Linux with OpenGL, all drawing happens on the app
+            // thread (must_draw_from_app_thread = true), so the renderer thread
+            // doesn't need to set up an OpenGL context.
         },
     }
 }
-- 
2.43.0


From 2fec32064a2d4d477a87beecd92fa827408070c4 Mon Sep 17 00:00:00 2001
From: teamchong <steven@keplogic.com>
Date: Wed, 4 Feb 2026 10:53:13 -0500
Subject: [PATCH 2/6] feat(linux): add headless EGL rendering support for
 embedded platform

---
 src/apprt/egl_headless.zig | 130 +++++++++++++++++++++++++++++++++++--
 src/apprt/embedded.zig     |  16 +++--
 src/renderer/OpenGL.zig    |  10 ++-
 3 files changed, 142 insertions(+), 14 deletions(-)

diff --git a/src/apprt/egl_headless.zig b/src/apprt/egl_headless.zig
index 666b80909..5fa56451d 100644
--- a/src/apprt/egl_headless.zig
+++ b/src/apprt/egl_headless.zig
@@ -191,9 +191,9 @@ pub const PboState = struct {
         const bindBuffer = gl.glad.context.BindBuffer orelse return false;
         const glReadPixels = gl.glad.context.ReadPixels orelse return false;
 
-        // Set read buffer
+        // For FBO reading, use GL_COLOR_ATTACHMENT0 (not GL_BACK)
         if (gl.glad.context.ReadBuffer) |readBuf| {
-            readBuf(gl.c.GL_BACK);
+            readBuf(OffscreenFbo.GL_COLOR_ATTACHMENT0);
         }
 
         const next_index: u1 = self.current_index +% 1;
@@ -255,6 +255,106 @@ pub const PboState = struct {
 /// Global PBO state for async readback
 var global_pbo_state: PboState = .{};
 
+/// Offscreen FBO for headless rendering
+/// Required because headless EGL has no real default framebuffer
+pub const OffscreenFbo = struct {
+    fbo: c_uint = 0,
+    rbo: c_uint = 0,
+    width: u32 = 0,
+    height: u32 = 0,
+
+    // OpenGL constants
+    const GL_FRAMEBUFFER: c_uint = 0x8D40;
+    const GL_DRAW_FRAMEBUFFER: c_uint = 0x8CA9;
+    const GL_READ_FRAMEBUFFER: c_uint = 0x8CA8;
+    const GL_RENDERBUFFER: c_uint = 0x8D41;
+    const GL_COLOR_ATTACHMENT0: c_uint = 0x8CE0;
+    const GL_FRAMEBUFFER_COMPLETE: c_uint = 0x8CD5;
+    const GL_RGBA8: c_uint = 0x8058;
+
+    pub fn init(self: *OffscreenFbo, width: u32, height: u32) bool {
+        if (width == 0 or height == 0) return false;
+
+        const genFramebuffers = gl.glad.context.GenFramebuffers orelse return false;
+        const genRenderbuffers = gl.glad.context.GenRenderbuffers orelse return false;
+        const bindFramebuffer = gl.glad.context.BindFramebuffer orelse return false;
+        const bindRenderbuffer = gl.glad.context.BindRenderbuffer orelse return false;
+        const renderbufferStorage = gl.glad.context.RenderbufferStorage orelse return false;
+        const framebufferRenderbuffer = gl.glad.context.FramebufferRenderbuffer orelse return false;
+        const checkStatus = gl.glad.context.CheckFramebufferStatus orelse return false;
+
+        // Generate FBO and RBO
+        genFramebuffers(1, &self.fbo);
+        genRenderbuffers(1, &self.rbo);
+
+        // Setup renderbuffer with RGBA8 format
+        bindRenderbuffer(GL_RENDERBUFFER, self.rbo);
+        renderbufferStorage(GL_RENDERBUFFER, GL_RGBA8, @intCast(width), @intCast(height));
+
+        // Attach renderbuffer to FBO
+        bindFramebuffer(GL_FRAMEBUFFER, self.fbo);
+        framebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, self.rbo);
+
+        // Check completeness
+        const status = checkStatus(GL_FRAMEBUFFER);
+        if (status != GL_FRAMEBUFFER_COMPLETE) {
+            log.err("FBO incomplete: status=0x{X}", .{status});
+            self.deinit();
+            return false;
+        }
+
+        // Keep FBO bound as draw target
+        bindFramebuffer(GL_DRAW_FRAMEBUFFER, self.fbo);
+
+        self.width = width;
+        self.height = height;
+        log.info("Offscreen FBO created: {}x{}", .{ width, height });
+        return true;
+    }
+
+    pub fn deinit(self: *OffscreenFbo) void {
+        if (self.fbo != 0) {
+            if (gl.glad.context.DeleteFramebuffers) |del| {
+                del(1, &self.fbo);
+            }
+            self.fbo = 0;
+        }
+        if (self.rbo != 0) {
+            if (gl.glad.context.DeleteRenderbuffers) |del| {
+                del(1, &self.rbo);
+            }
+            self.rbo = 0;
+        }
+        self.width = 0;
+        self.height = 0;
+    }
+
+    pub fn resize(self: *OffscreenFbo, width: u32, height: u32) bool {
+        if (self.width == width and self.height == height and self.fbo != 0) return true;
+        self.deinit();
+        return self.init(width, height);
+    }
+
+    /// Bind the FBO as the draw target (call before rendering)
+    pub fn bindForDraw(self: *OffscreenFbo) void {
+        if (self.fbo == 0) return;
+        if (gl.glad.context.BindFramebuffer) |bind| {
+            bind(GL_DRAW_FRAMEBUFFER, self.fbo);
+        }
+    }
+
+    /// Bind the FBO as the read target (call before readPixels)
+    pub fn bindForRead(self: *OffscreenFbo) void {
+        if (self.fbo == 0) return;
+        if (gl.glad.context.BindFramebuffer) |bind| {
+            bind(GL_READ_FRAMEBUFFER, self.fbo);
+        }
+    }
+};
+
+/// Global offscreen FBO
+var global_offscreen_fbo: OffscreenFbo = .{};
+
 pub const EglHeadless = struct {
     display: c.EGLDisplay,
     context: c.EGLContext,
@@ -433,22 +533,40 @@ pub fn releaseContext() void {
 
 /// Set the OpenGL viewport size. Must be called when surface size changes
 /// so that rendering and readPixels work correctly.
+/// Also creates/resizes the offscreen FBO for headless rendering.
 pub fn setViewportSize(width: u32, height: u32) void {
     if (!makeCurrentOnThread()) {
         log.warn("setViewportSize: makeCurrent failed", .{});
         return;
     }
+
+    // Create/resize offscreen FBO for headless rendering
+    // This FBO is where Ghostty's blit will render to
+    if (!global_offscreen_fbo.resize(width, height)) {
+        log.warn("setViewportSize: failed to create offscreen FBO", .{});
+    }
+
+    // Set viewport
     if (gl.glad.context.Viewport) |viewport| {
         viewport(0, 0, @intCast(width), @intCast(height));
-        log.info("setViewportSize: {}x{}", .{ width, height });
+        log.info("setViewportSize: {}x{} (FBO={})", .{ width, height, global_offscreen_fbo.fbo });
     }
 }
 
-/// Read pixels from the current OpenGL framebuffer (RGBA format)
+/// Bind the offscreen FBO as the draw target.
+/// Call this before Ghostty's present() to ensure the blit goes to our FBO.
+pub fn bindOffscreenFboForDraw() void {
+    global_offscreen_fbo.bindForDraw();
+}
+
+/// Read pixels from the offscreen FBO (RGBA format)
 /// Uses double-buffered PBO for async readback with sync fallback.
 /// PBO returns previous frame's data while current frame reads (pipelined).
 /// Falls back to sync read on first frame to ensure we always have data.
 pub fn readPixels(buffer: [*]u8, buffer_len: usize, width: u32, height: u32) bool {
+    // Bind FBO for reading
+    global_offscreen_fbo.bindForRead();
+
     // Try async PBO first
     const pbo_ok = global_pbo_state.readPixelsAsync(buffer, buffer_len, width, height);
     if (pbo_ok) {
@@ -476,9 +594,9 @@ pub fn readPixelsSync(buffer: [*]u8, buffer_len: usize, width: u32, height: u32)
     const expected_size = @as(usize, width) * @as(usize, height) * 4;
     if (buffer_len < expected_size) return false;
 
-    // Ensure we're reading from the right buffer
+    // For FBO reading, use GL_COLOR_ATTACHMENT0 (not GL_BACK)
     if (gl.glad.context.ReadBuffer) |readBuf| {
-        readBuf(gl.c.GL_BACK);
+        readBuf(OffscreenFbo.GL_COLOR_ATTACHMENT0);
     }
 
     // Read pixels (OpenGL origin is bottom-left)
diff --git a/src/apprt/embedded.zig b/src/apprt/embedded.zig
index 2887c84b4..2cb4f5947 100644
--- a/src/apprt/embedded.zig
+++ b/src/apprt/embedded.zig
@@ -804,6 +804,15 @@ pub const Surface = struct {
     }
 
     pub fn updateSize(self: *Surface, width: u32, height: u32) void {
+        log.info("updateSize called: {}x{} (current: {}x{})", .{ width, height, self.size.width, self.size.height });
+
+        // For embedded Linux with headless EGL, ALWAYS set the OpenGL viewport
+        // even if size hasn't changed, to ensure it's set on first call.
+        if (comptime builtin.target.os.tag == .linux) {
+            const egl_headless = @import("egl_headless.zig");
+            egl_headless.setViewportSize(width, height);
+        }
+
         // Runtimes sometimes generate superfluous resize events even
         // if the size did not actually change (SwiftUI). We check
         // that the size actually changed from what we last recorded
@@ -815,13 +824,6 @@ pub const Surface = struct {
             .height = height,
         };
 
-        // For embedded Linux with headless EGL, set the OpenGL viewport
-        // so that readPixels returns actual content instead of black.
-        if (comptime builtin.target.os.tag == .linux) {
-            const egl_headless = @import("egl_headless.zig");
-            egl_headless.setViewportSize(width, height);
-        }
-
         // Call the primary callback.
         self.core_surface.sizeCallback(self.size) catch |err| {
             log.err("error in size callback err={}", .{err});
diff --git a/src/renderer/OpenGL.zig b/src/renderer/OpenGL.zig
index 8d5edd8f4..3a024624f 100644
--- a/src/renderer/OpenGL.zig
+++ b/src/renderer/OpenGL.zig
@@ -260,9 +260,17 @@ pub fn displayRealized(self: *const OpenGL) void {
 
 /// Actions taken before doing anything in `drawFrame`.
 ///
-/// Right now there's nothing we need to do for OpenGL.
+/// For embedded Linux, bind the offscreen FBO as the draw target
+/// so that the blit in present() goes to our FBO instead of the
+/// non-existent default framebuffer.
 pub fn drawFrameStart(self: *OpenGL) void {
     _ = self;
+    if (comptime builtin.target.os.tag == .linux) {
+        if (comptime apprt.runtime == apprt.embedded) {
+            const egl_headless = @import("../apprt/egl_headless.zig");
+            egl_headless.bindOffscreenFboForDraw();
+        }
+    }
 }
 
 /// Actions taken after `drawFrame` is done.
-- 
2.43.0


From 5a0c16887e537b87bda90285db1b7c9910d5dbd2 Mon Sep 17 00:00:00 2001
From: teamchong <steven@keplogic.com>
Date: Wed, 4 Feb 2026 11:06:56 -0500
Subject: [PATCH 3/6] feat(linux): add headless EGL rendering support for
 embedded platform

---
 src/apprt/egl_headless.zig | 151 ++++++-------------------------------
 src/apprt/embedded.zig     |  13 +++-
 src/renderer/OpenGL.zig    |  10 +--
 3 files changed, 36 insertions(+), 138 deletions(-)

diff --git a/src/apprt/egl_headless.zig b/src/apprt/egl_headless.zig
index 5fa56451d..0198cd862 100644
--- a/src/apprt/egl_headless.zig
+++ b/src/apprt/egl_headless.zig
@@ -178,7 +178,9 @@ pub const PboState = struct {
 
     /// Async readPixels using double-buffered PBO
     /// Returns false on first frame (no previous data available yet)
-    pub fn readPixelsAsync(self: *PboState, dest_buffer: [*]u8, dest_len: usize, width: u32, height: u32) bool {
+    /// @param fbo_id The FBO to read from (already bound by caller)
+    pub fn readPixelsAsync(self: *PboState, dest_buffer: [*]u8, dest_len: usize, width: u32, height: u32, fbo_id: c_uint) bool {
+        _ = fbo_id; // FBO already bound by caller
         // Validate dimensions
         const expected_size = @as(usize, width) * @as(usize, height) * 4;
         if (dest_len < expected_size) return false;
@@ -193,7 +195,7 @@ pub const PboState = struct {
 
         // For FBO reading, use GL_COLOR_ATTACHMENT0 (not GL_BACK)
         if (gl.glad.context.ReadBuffer) |readBuf| {
-            readBuf(OffscreenFbo.GL_COLOR_ATTACHMENT0);
+            readBuf(GL_COLOR_ATTACHMENT0);
         }
 
         const next_index: u1 = self.current_index +% 1;
@@ -255,105 +257,9 @@ pub const PboState = struct {
 /// Global PBO state for async readback
 var global_pbo_state: PboState = .{};
 
-/// Offscreen FBO for headless rendering
-/// Required because headless EGL has no real default framebuffer
-pub const OffscreenFbo = struct {
-    fbo: c_uint = 0,
-    rbo: c_uint = 0,
-    width: u32 = 0,
-    height: u32 = 0,
-
-    // OpenGL constants
-    const GL_FRAMEBUFFER: c_uint = 0x8D40;
-    const GL_DRAW_FRAMEBUFFER: c_uint = 0x8CA9;
-    const GL_READ_FRAMEBUFFER: c_uint = 0x8CA8;
-    const GL_RENDERBUFFER: c_uint = 0x8D41;
-    const GL_COLOR_ATTACHMENT0: c_uint = 0x8CE0;
-    const GL_FRAMEBUFFER_COMPLETE: c_uint = 0x8CD5;
-    const GL_RGBA8: c_uint = 0x8058;
-
-    pub fn init(self: *OffscreenFbo, width: u32, height: u32) bool {
-        if (width == 0 or height == 0) return false;
-
-        const genFramebuffers = gl.glad.context.GenFramebuffers orelse return false;
-        const genRenderbuffers = gl.glad.context.GenRenderbuffers orelse return false;
-        const bindFramebuffer = gl.glad.context.BindFramebuffer orelse return false;
-        const bindRenderbuffer = gl.glad.context.BindRenderbuffer orelse return false;
-        const renderbufferStorage = gl.glad.context.RenderbufferStorage orelse return false;
-        const framebufferRenderbuffer = gl.glad.context.FramebufferRenderbuffer orelse return false;
-        const checkStatus = gl.glad.context.CheckFramebufferStatus orelse return false;
-
-        // Generate FBO and RBO
-        genFramebuffers(1, &self.fbo);
-        genRenderbuffers(1, &self.rbo);
-
-        // Setup renderbuffer with RGBA8 format
-        bindRenderbuffer(GL_RENDERBUFFER, self.rbo);
-        renderbufferStorage(GL_RENDERBUFFER, GL_RGBA8, @intCast(width), @intCast(height));
-
-        // Attach renderbuffer to FBO
-        bindFramebuffer(GL_FRAMEBUFFER, self.fbo);
-        framebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, self.rbo);
-
-        // Check completeness
-        const status = checkStatus(GL_FRAMEBUFFER);
-        if (status != GL_FRAMEBUFFER_COMPLETE) {
-            log.err("FBO incomplete: status=0x{X}", .{status});
-            self.deinit();
-            return false;
-        }
-
-        // Keep FBO bound as draw target
-        bindFramebuffer(GL_DRAW_FRAMEBUFFER, self.fbo);
-
-        self.width = width;
-        self.height = height;
-        log.info("Offscreen FBO created: {}x{}", .{ width, height });
-        return true;
-    }
-
-    pub fn deinit(self: *OffscreenFbo) void {
-        if (self.fbo != 0) {
-            if (gl.glad.context.DeleteFramebuffers) |del| {
-                del(1, &self.fbo);
-            }
-            self.fbo = 0;
-        }
-        if (self.rbo != 0) {
-            if (gl.glad.context.DeleteRenderbuffers) |del| {
-                del(1, &self.rbo);
-            }
-            self.rbo = 0;
-        }
-        self.width = 0;
-        self.height = 0;
-    }
-
-    pub fn resize(self: *OffscreenFbo, width: u32, height: u32) bool {
-        if (self.width == width and self.height == height and self.fbo != 0) return true;
-        self.deinit();
-        return self.init(width, height);
-    }
-
-    /// Bind the FBO as the draw target (call before rendering)
-    pub fn bindForDraw(self: *OffscreenFbo) void {
-        if (self.fbo == 0) return;
-        if (gl.glad.context.BindFramebuffer) |bind| {
-            bind(GL_DRAW_FRAMEBUFFER, self.fbo);
-        }
-    }
-
-    /// Bind the FBO as the read target (call before readPixels)
-    pub fn bindForRead(self: *OffscreenFbo) void {
-        if (self.fbo == 0) return;
-        if (gl.glad.context.BindFramebuffer) |bind| {
-            bind(GL_READ_FRAMEBUFFER, self.fbo);
-        }
-    }
-};
-
-/// Global offscreen FBO
-var global_offscreen_fbo: OffscreenFbo = .{};
+/// OpenGL constants for FBO binding
+const GL_READ_FRAMEBUFFER: c_uint = 0x8CA8;
+const GL_COLOR_ATTACHMENT0: c_uint = 0x8CE0;
 
 pub const EglHeadless = struct {
     display: c.EGLDisplay,
@@ -531,55 +437,43 @@ pub fn releaseContext() void {
     }
 }
 
-/// Set the OpenGL viewport size. Must be called when surface size changes
-/// so that rendering and readPixels work correctly.
-/// Also creates/resizes the offscreen FBO for headless rendering.
+/// Set the OpenGL viewport size. Must be called when surface size changes.
 pub fn setViewportSize(width: u32, height: u32) void {
     if (!makeCurrentOnThread()) {
         log.warn("setViewportSize: makeCurrent failed", .{});
         return;
     }
 
-    // Create/resize offscreen FBO for headless rendering
-    // This FBO is where Ghostty's blit will render to
-    if (!global_offscreen_fbo.resize(width, height)) {
-        log.warn("setViewportSize: failed to create offscreen FBO", .{});
-    }
-
-    // Set viewport
     if (gl.glad.context.Viewport) |viewport| {
         viewport(0, 0, @intCast(width), @intCast(height));
-        log.info("setViewportSize: {}x{} (FBO={})", .{ width, height, global_offscreen_fbo.fbo });
+        log.info("setViewportSize: {}x{}", .{ width, height });
     }
 }
 
-/// Bind the offscreen FBO as the draw target.
-/// Call this before Ghostty's present() to ensure the blit goes to our FBO.
-pub fn bindOffscreenFboForDraw() void {
-    global_offscreen_fbo.bindForDraw();
-}
-
-/// Read pixels from the offscreen FBO (RGBA format)
+/// Read pixels from the specified FBO (RGBA format)
 /// Uses double-buffered PBO for async readback with sync fallback.
 /// PBO returns previous frame's data while current frame reads (pipelined).
 /// Falls back to sync read on first frame to ensure we always have data.
-pub fn readPixels(buffer: [*]u8, buffer_len: usize, width: u32, height: u32) bool {
-    // Bind FBO for reading
-    global_offscreen_fbo.bindForRead();
+/// @param fbo_id The OpenGL framebuffer object ID to read from (from renderer's last_target)
+pub fn readPixels(buffer: [*]u8, buffer_len: usize, width: u32, height: u32, fbo_id: c_uint) bool {
+    // Bind the renderer's FBO for reading
+    if (gl.glad.context.BindFramebuffer) |bindFbo| {
+        bindFbo(GL_READ_FRAMEBUFFER, fbo_id);
+    }
 
     // Try async PBO first
-    const pbo_ok = global_pbo_state.readPixelsAsync(buffer, buffer_len, width, height);
+    const pbo_ok = global_pbo_state.readPixelsAsync(buffer, buffer_len, width, height, fbo_id);
     if (pbo_ok) {
         return true;
     }
     // Fall back to sync read (first frame or PBO error)
-    const sync_ok = readPixelsSync(buffer, buffer_len, width, height);
+    const sync_ok = readPixelsSync(buffer, buffer_len, width, height, fbo_id);
     // Debug: log first pixel after sync read
     if (sync_ok and buffer_len >= 4) {
         const first_pixel = buffer[0..4];
         if (global_pbo_state.frame_count < 3) {
-            log.info("readPixels sync fallback: frame={}, first_pixel=({},{},{},{})", .{
-                global_pbo_state.frame_count, first_pixel[0], first_pixel[1], first_pixel[2], first_pixel[3],
+            log.info("readPixels sync (fbo={}): frame={}, first_pixel=({},{},{},{})", .{
+                fbo_id, global_pbo_state.frame_count, first_pixel[0], first_pixel[1], first_pixel[2], first_pixel[3],
             });
         }
     }
@@ -588,7 +482,8 @@ pub fn readPixels(buffer: [*]u8, buffer_len: usize, width: u32, height: u32) boo
 
 /// Synchronous fallback for cases where we absolutely need the current frame
 /// (e.g., single-shot capture). Slower but provides immediate data.
-pub fn readPixelsSync(buffer: [*]u8, buffer_len: usize, width: u32, height: u32) bool {
+pub fn readPixelsSync(buffer: [*]u8, buffer_len: usize, width: u32, height: u32, fbo_id: c_uint) bool {
+    _ = fbo_id; // FBO already bound by caller
     const readPixelsFn = gl.glad.context.ReadPixels orelse return false;
 
     const expected_size = @as(usize, width) * @as(usize, height) * 4;
@@ -596,7 +491,7 @@ pub fn readPixelsSync(buffer: [*]u8, buffer_len: usize, width: u32, height: u32)
 
     // For FBO reading, use GL_COLOR_ATTACHMENT0 (not GL_BACK)
     if (gl.glad.context.ReadBuffer) |readBuf| {
-        readBuf(OffscreenFbo.GL_COLOR_ATTACHMENT0);
+        readBuf(GL_COLOR_ATTACHMENT0);
     }
 
     // Read pixels (OpenGL origin is bottom-left)
diff --git a/src/apprt/embedded.zig b/src/apprt/embedded.zig
index 2cb4f5947..b7177b70f 100644
--- a/src/apprt/embedded.zig
+++ b/src/apprt/embedded.zig
@@ -2248,7 +2248,18 @@ pub const CAPI = struct {
 
             if (comptime builtin.target.os.tag == .linux) {
                 const egl_headless = @import("egl_headless.zig");
-                return egl_headless.readPixels(buffer, buffer_len, width, height);
+
+                // Get the FBO ID from the renderer's last_target
+                // Path: Surface -> core_surface -> renderer -> api -> last_target -> framebuffer.id
+                const fbo_id: c_uint = blk: {
+                    const last_target = ptr.core_surface.renderer.api.last_target orelse {
+                        // No target rendered yet
+                        return false;
+                    };
+                    break :blk last_target.framebuffer.id;
+                };
+
+                return egl_headless.readPixels(buffer, buffer_len, width, height, fbo_id);
             }
             return false;
         }
diff --git a/src/renderer/OpenGL.zig b/src/renderer/OpenGL.zig
index 3a024624f..8d5edd8f4 100644
--- a/src/renderer/OpenGL.zig
+++ b/src/renderer/OpenGL.zig
@@ -260,17 +260,9 @@ pub fn displayRealized(self: *const OpenGL) void {
 
 /// Actions taken before doing anything in `drawFrame`.
 ///
-/// For embedded Linux, bind the offscreen FBO as the draw target
-/// so that the blit in present() goes to our FBO instead of the
-/// non-existent default framebuffer.
+/// Right now there's nothing we need to do for OpenGL.
 pub fn drawFrameStart(self: *OpenGL) void {
     _ = self;
-    if (comptime builtin.target.os.tag == .linux) {
-        if (comptime apprt.runtime == apprt.embedded) {
-            const egl_headless = @import("../apprt/egl_headless.zig");
-            egl_headless.bindOffscreenFboForDraw();
-        }
-    }
 }
 
 /// Actions taken after `drawFrame` is done.
-- 
2.43.0


From be266ea93e90012c3e94c55e7241bc7a761dce6c Mon Sep 17 00:00:00 2001
From: teamchong <steven@keplogic.com>
Date: Wed, 4 Feb 2026 11:12:56 -0500
Subject: [PATCH 4/6] feat(linux): add headless EGL rendering support for
 embedded platform

---
 src/apprt/egl_headless.zig | 25 +++++--------------------
 1 file changed, 5 insertions(+), 20 deletions(-)

diff --git a/src/apprt/egl_headless.zig b/src/apprt/egl_headless.zig
index 0198cd862..5bc488dd4 100644
--- a/src/apprt/egl_headless.zig
+++ b/src/apprt/egl_headless.zig
@@ -451,9 +451,9 @@ pub fn setViewportSize(width: u32, height: u32) void {
 }
 
 /// Read pixels from the specified FBO (RGBA format)
-/// Uses double-buffered PBO for async readback with sync fallback.
-/// PBO returns previous frame's data while current frame reads (pipelined).
-/// Falls back to sync read on first frame to ensure we always have data.
+/// Currently uses synchronous readPixels. PBO is disabled because the global
+/// PBO state is shared across all surfaces, causing race conditions.
+/// TODO: Implement per-surface PBO state for async readback.
 /// @param fbo_id The OpenGL framebuffer object ID to read from (from renderer's last_target)
 pub fn readPixels(buffer: [*]u8, buffer_len: usize, width: u32, height: u32, fbo_id: c_uint) bool {
     // Bind the renderer's FBO for reading
@@ -461,23 +461,8 @@ pub fn readPixels(buffer: [*]u8, buffer_len: usize, width: u32, height: u32, fbo
         bindFbo(GL_READ_FRAMEBUFFER, fbo_id);
     }
 
-    // Try async PBO first
-    const pbo_ok = global_pbo_state.readPixelsAsync(buffer, buffer_len, width, height, fbo_id);
-    if (pbo_ok) {
-        return true;
-    }
-    // Fall back to sync read (first frame or PBO error)
-    const sync_ok = readPixelsSync(buffer, buffer_len, width, height, fbo_id);
-    // Debug: log first pixel after sync read
-    if (sync_ok and buffer_len >= 4) {
-        const first_pixel = buffer[0..4];
-        if (global_pbo_state.frame_count < 3) {
-            log.info("readPixels sync (fbo={}): frame={}, first_pixel=({},{},{},{})", .{
-                fbo_id, global_pbo_state.frame_count, first_pixel[0], first_pixel[1], first_pixel[2], first_pixel[3],
-            });
-        }
-    }
-    return sync_ok;
+    // Use synchronous read - PBO disabled due to global state shared across surfaces
+    return readPixelsSync(buffer, buffer_len, width, height, fbo_id);
 }
 
 /// Synchronous fallback for cases where we absolutely need the current frame
-- 
2.43.0


From 63bae98fedffe550851b343569b6726ca01ee74f Mon Sep 17 00:00:00 2001
From: teamchong <steven@keplogic.com>
Date: Wed, 4 Feb 2026 11:14:40 -0500
Subject: [PATCH 5/6] feat(linux): add headless EGL rendering support for
 embedded platform

---
 src/apprt/egl_headless.zig | 73 ++++++++++++++++++++++++++++++++++----
 1 file changed, 67 insertions(+), 6 deletions(-)

diff --git a/src/apprt/egl_headless.zig b/src/apprt/egl_headless.zig
index 5bc488dd4..1827817ae 100644
--- a/src/apprt/egl_headless.zig
+++ b/src/apprt/egl_headless.zig
@@ -254,8 +254,59 @@ pub const PboState = struct {
     }
 };
 
-/// Global PBO state for async readback
-var global_pbo_state: PboState = .{};
+/// Per-FBO PBO state manager
+/// Maps FBO IDs to their own PBO states to avoid race conditions between surfaces
+const PboStateManager = struct {
+    const MAX_SURFACES = 16; // Max concurrent surfaces/FBOs
+
+    /// Entry mapping FBO ID to its PBO state
+    const Entry = struct {
+        fbo_id: c_uint = 0,
+        pbo_state: PboState = .{},
+        in_use: bool = false,
+    };
+
+    entries: [MAX_SURFACES]Entry = [_]Entry{.{}} ** MAX_SURFACES,
+
+    /// Get or create PBO state for a given FBO ID
+    pub fn getOrCreate(self: *PboStateManager, fbo_id: c_uint) ?*PboState {
+        // First, look for existing entry
+        for (&self.entries) |*entry| {
+            if (entry.in_use and entry.fbo_id == fbo_id) {
+                return &entry.pbo_state;
+            }
+        }
+
+        // Not found, create new entry
+        for (&self.entries) |*entry| {
+            if (!entry.in_use) {
+                entry.fbo_id = fbo_id;
+                entry.in_use = true;
+                entry.pbo_state = .{};
+                return &entry.pbo_state;
+            }
+        }
+
+        // No free slots
+        log.warn("PBO state manager full, cannot create state for FBO {}", .{fbo_id});
+        return null;
+    }
+
+    /// Remove PBO state for a given FBO ID (call when surface is destroyed)
+    pub fn remove(self: *PboStateManager, fbo_id: c_uint) void {
+        for (&self.entries) |*entry| {
+            if (entry.in_use and entry.fbo_id == fbo_id) {
+                entry.pbo_state.deinit();
+                entry.in_use = false;
+                entry.fbo_id = 0;
+                return;
+            }
+        }
+    }
+};
+
+/// Per-FBO PBO state manager instance
+var pbo_manager: PboStateManager = .{};
 
 /// OpenGL constants for FBO binding
 const GL_READ_FRAMEBUFFER: c_uint = 0x8CA8;
@@ -451,9 +502,8 @@ pub fn setViewportSize(width: u32, height: u32) void {
 }
 
 /// Read pixels from the specified FBO (RGBA format)
-/// Currently uses synchronous readPixels. PBO is disabled because the global
-/// PBO state is shared across all surfaces, causing race conditions.
-/// TODO: Implement per-surface PBO state for async readback.
+/// Uses per-FBO double-buffered PBO for async readback with sync fallback.
+/// Each FBO has its own PBO state to avoid race conditions between surfaces.
 /// @param fbo_id The OpenGL framebuffer object ID to read from (from renderer's last_target)
 pub fn readPixels(buffer: [*]u8, buffer_len: usize, width: u32, height: u32, fbo_id: c_uint) bool {
     // Bind the renderer's FBO for reading
@@ -461,7 +511,18 @@ pub fn readPixels(buffer: [*]u8, buffer_len: usize, width: u32, height: u32, fbo
         bindFbo(GL_READ_FRAMEBUFFER, fbo_id);
     }
 
-    // Use synchronous read - PBO disabled due to global state shared across surfaces
+    // Get per-FBO PBO state
+    const pbo_state = pbo_manager.getOrCreate(fbo_id) orelse {
+        // Fall back to sync if we can't get PBO state
+        return readPixelsSync(buffer, buffer_len, width, height, fbo_id);
+    };
+
+    // Try async PBO first
+    if (pbo_state.readPixelsAsync(buffer, buffer_len, width, height, fbo_id)) {
+        return true;
+    }
+
+    // Fall back to sync read (first frame or PBO error)
     return readPixelsSync(buffer, buffer_len, width, height, fbo_id);
 }
 
-- 
2.43.0


From eb117cd0930aac1ff5b4c00bc6f9c20425a4d6a1 Mon Sep 17 00:00:00 2001
From: teamchong <steven@keplogic.com>
Date: Wed, 4 Feb 2026 11:17:00 -0500
Subject: [PATCH 6/6] feat(linux): add headless EGL rendering support for
 embedded platform

---
 src/apprt/egl_headless.zig | 5 +++++
 src/apprt/embedded.zig     | 8 ++++++++
 2 files changed, 13 insertions(+)

diff --git a/src/apprt/egl_headless.zig b/src/apprt/egl_headless.zig
index 1827817ae..a10cec773 100644
--- a/src/apprt/egl_headless.zig
+++ b/src/apprt/egl_headless.zig
@@ -308,6 +308,11 @@ const PboStateManager = struct {
 /// Per-FBO PBO state manager instance
 var pbo_manager: PboStateManager = .{};
 
+/// Clean up PBO state for a given FBO ID (call when surface is destroyed)
+pub fn cleanupPboState(fbo_id: c_uint) void {
+    pbo_manager.remove(fbo_id);
+}
+
 /// OpenGL constants for FBO binding
 const GL_READ_FRAMEBUFFER: c_uint = 0x8CA8;
 const GL_COLOR_ATTACHMENT0: c_uint = 0x8CE0;
diff --git a/src/apprt/embedded.zig b/src/apprt/embedded.zig
index b7177b70f..bac683c8b 100644
--- a/src/apprt/embedded.zig
+++ b/src/apprt/embedded.zig
@@ -613,6 +613,14 @@ pub const Surface = struct {
         // Free our title
         if (self.title) |v| self.app.core_app.alloc.free(v);
 
+        // Clean up PBO state for this surface's FBO (Linux only)
+        if (comptime builtin.target.os.tag == .linux) {
+            if (self.core_surface.renderer.api.last_target) |target| {
+                const egl_headless = @import("egl_headless.zig");
+                egl_headless.cleanupPboState(target.framebuffer.id);
+            }
+        }
+
         // Remove ourselves from the list of known surfaces in the app.
         self.app.core_app.deleteSurface(self);
 
-- 
2.43.0

